<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BASE TOKEN LAUNCHER</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

    <link rel="stylesheet" href="../css/styles.css">


    <!-- Mark that we're handling the wallet button ourselves -->
    <script>
        window.BASE_LAUNCH_HANDLES_WALLET_BUTTON = true;

        // AGGRESSIVE ANTI-AUTO-CONNECTION: Block all wallet property access until user clicks connect
        window.WALLET_AUTO_CONNECTION_BLOCKED = true;
        console.log('🚫 Base launch page: Wallet auto-connection globally blocked until user interaction');
    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            background: var(--panel);
            min-height: 100vh;
            color: #f8fafc;
            margin: 0;
            padding: 16px;
            line-height: 1.6;
            text-align: center;
            font-weight: 400;
            background-attachment: fixed;
        }


        /* Tweak these if you like */
        :root {
            --panel-max-width: 420px;
            /* overall width of the vertical panel */
            --wallet-strip-gap: 1.5rem;
            /* vertical spacing between items */
            --wallet-strip-radius: 12px;
            /* corner radius on images */
            --wallet-strip-hover-scale: 1.03;
            /* how much they grow on hover/focus */
            --shadow: 0 2px 8px rgba(0, 0, 0, .25);
            --shadow-hover: 0 8px 20px rgba(0, 0, 0, .35);
        }

        /* Vertical panel container */
        .link-panel {
            max-width: var(--panel-max-width);
            margin-inline: auto;
            /* center horizontally on the page */
            display: flex;
            flex-direction: column;
            gap: var(--wallet-strip-gap);
        }

        /* Each clickable image */
        .panel-item {
            display: block;
            width: 100%;
            border-radius: var(--wallet-strip-radius);
            border: 0px solid var(--light-blue-60);
            background-color: var(--panel);
            overflow: hidden;
            box-shadow: var(--shadow);
            transform: translateZ(0);
            /* prevents hover jank on some GPUs */
            transition: transform 160ms ease, box-shadow 160ms ease, filter 160ms ease;
            box-shadow: 0 0 4px var(--light-blue-60);
        }

        /* Keep all items the same visual height with cropping */
        .panel-item img {
            display: block;
            width: 100%;
            aspect-ratio: 35 / 10;
            /* uniform landscape slot */
            object-fit: cover;
        }

        /* Feedback on hover & keyboard focus */
        .panel-item:hover,
        .panel-item:focus-visible {
            transform: scale(var(--wallet-strip-hover-scale));
            box-shadow: var(--shadow-hover);
            box-shadow: 0 0 8px var(--light-blue);
        }

        /* Respect reduced motion preferences */
        @media (prefers-reduced-motion: reduce) {
            .panel-item {
                transition: none;
            }
        }




        /* Override centering for specific elements that need left alignment */
        .form-input,
        input,
        textarea,
        select {
            text-align: left;
        }

        .page-wrapper {
            max-width: 1200px;
            margin: 0 auto;
            padding-top: 60px;
        }

        .main-header {
            text-align: center;
            margin-bottom: 48px;
            position: relative;
        }

        .main-header::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 4px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #06b6d4);
            border-radius: 2px;
            animation: headerGlow 3s ease-in-out infinite alternate;
        }

        @keyframes headerGlow {
            from {
                box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            }

            to {
                box-shadow: 0 0 40px rgba(139, 92, 246, 0.8);
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes cardPulse {

            0%,
            100% {
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08), 0 4px 8px rgba(0, 0, 0, 0.12);
            }

            50% {
                box-shadow: 0 12px 35px rgba(102, 126, 234, 0.15), 0 6px 12px rgba(118, 75, 162, 0.2);
            }
        }

        .main-header h1 {
            font-size: 2.75rem;
            font-weight: 800;
            margin: 0 0 12px 0;
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 50%, #06b6d4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 30px rgba(59, 130, 246, 0.3);
        }

        .main-header p {
            font-size: 1.1rem;
            color: #94a3b8;
            margin: 0;
            font-weight: 500;
            opacity: 0.9;
        }

        .card {
            background: var(--dark-violet-60);
            border: 1px solid rgba(148, 163, 184, 0.15);
            border-radius: 20px;
            padding: 32px;
            margin-bottom: 32px;
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            width: 100%;
            max-width: none;
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--pink), var(--violet), var(--mid-blue));
            opacity: 0.8;
        }

        :root {
            --neon: #00eaff;
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--pink) 0%, var(--mid-blue) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            position: relative;
            padding-bottom: 12px;
        }

        .card-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 2px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            border-radius: 1px;
        }

        /* Token Card Specific Styles */
        .token-card {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform;
        }

        .token-card:hover {
            transform: translateY(-4px) scale(1.02);
        }

        .token-icon {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            animation: iconPulse 2s ease-in-out infinite alternate;
        }

        @keyframes iconPulse {
            from {
                box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.3);
            }

            to {
                box-shadow: 0 0 0 8px rgba(102, 126, 234, 0.1);
            }
        }

        .status-badge {
            animation: statusBadgeGlow 3s ease-in-out infinite;
        }

        @keyframes statusBadgeGlow {

            0%,
            100% {
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            50% {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2), 0 0 8px rgba(255, 255, 255, 0.1);
            }
        }

        .contract-address {
            transition: all 0.2s ease;
        }

        .contract-address:hover {
            transform: scale(1.05);
            background: #f0f4ff !important;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        @media (max-width: 768px) {
            .info-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .token-card {
                padding: 16px;
                margin-bottom: 12px;
            }
        }

        .form-group {
            margin-bottom: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .form-label {
            display: block;
            font-size: 0.9rem;
            font-weight: 600;
            color: #a0a8b8;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            text-align: center;
        }

        .form-input {
            width: 100%;
            padding: 16px 20px;
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            color: #f8fafc;
            font-size: 1rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            position: relative;
        }

        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            background: rgba(15, 23, 42, 0.95);
            box-shadow:
                0 0 0 4px rgba(59, 130, 246, 0.1),
                0 8px 25px rgba(59, 130, 246, 0.15);
            transform: translateY(-1px);
        }

        .form-input::placeholder {
            color: #6b7280;
        }

        /* Breathtaking Button Animation System */
        .btn {
            background: linear-gradient(135deg, #0070f3, #0051cc, #003d99);
            background-size: 300% 300%;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 14px 20px;
            font-family: var(--font-ui);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-transform: uppercase;
            width: 100%;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
            animation: gradientShift 4s ease infinite;
            box-shadow: 0 4px 15px rgba(0, 112, 243, 0.3);
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.01);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #0080ff, #0066e6, #004db3);
            background-size: 300% 300%;
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 12px 35px rgba(0, 112, 243, 0.5), 0 0 30px rgba(0, 112, 243, 0.3);
            animation: gradientShift 2s ease infinite, pulse 1.5s ease infinite;
        }

        .btn:hover:not(:disabled)::before {
            left: 100%;
        }

        .btn:active:not(:disabled) {
            transform: translateY(-1px) scale(0.98);
            transition: all 0.1s ease;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            animation: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #1e40af, #1e3a8a, #1d4ed8);
            background-size: 300% 300%;
            box-shadow: 0 4px 15px rgba(30, 64, 175, 0.3);
        }

        .btn-secondary:hover:not(:disabled) {
            background: linear-gradient(135deg, #3b82f6, #2563eb, #1d4ed8);
            background-size: 300% 300%;
            box-shadow: 0 12px 35px rgba(30, 64, 175, 0.5), 0 0 30px rgba(30, 64, 175, 0.3);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #0070f3;
            color: #0070f3;
            box-shadow: 0 4px 15px rgba(0, 112, 243, 0.2);
            animation: none;
        }

        .btn-outline:hover:not(:disabled) {
            background: linear-gradient(135deg, #0070f3, #0051cc);
            background-size: 300% 300%;
            color: white;
            border-color: transparent;
            animation: gradientShift 3s ease infinite;
            box-shadow: 0 12px 35px rgba(0, 112, 243, 0.4);
        }

        /* Subtle animations for connected wallet button */
        .btn[style*="00c851"] {
            background: linear-gradient(135deg, #0070f3, #00c851, #0051cc) !important;
            background-size: 200% 200% !important;
            animation: gradientShift 8s ease infinite !important;
        }

        .btn-group {
            display: flex;
            gap: 12px;
            margin: 16px 0;
            flex-wrap: wrap;
            align-items: stretch;
        }

        .btn-group .btn {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            letter-spacing: 0.2rem;
        }

        /* Two-column button layout */
        .btn-group-2 .btn {
            flex: 0 0 calc(50% - 6px);
        }

        /* When a button in a 2-group is hidden, make the visible one full width */
        .btn-group-2 .btn:only-child {
            flex: 0 0 100%;
        }

        /* Three-column button layout */
        .btn-group-3 .btn {
            flex: 0 0 calc(33.333% - 8px);
        }

        /* Full-width button layout */
        .btn-group-full .btn {
            flex: 0 0 100%;
        }

        .status {
            padding: 12px 16px;
            border-radius: 10px;
            margin: 12px 0;
            font-weight: 500;
            text-align: center;
            font-size: 0.9rem;
        }

        .status-info {
            border: 0px solid rgba(255, 0, 0, 0.745);
            color: var(--panel);
            font-weight: bold;
            background: var(--yellow);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);

        }

        .status-success {
            background: rgba(34, 197, 94, 0.1);
            border: 1px var(--yellow-60);
            color: var(--yellow);
        }

        .status-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
        }

        .balance-display {
            background: rgba(15, 19, 24, 0.6);
            padding: 16px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(108, 140, 255, 0.2);
        }

        .balance-amount {
            font-size: 1.2rem;
            font-weight: 600;
            color: #6c8cff;
            margin-bottom: 4px;
        }

        .balance-label {
            font-size: 0.8rem;
            color: #a0a8b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 16px 0;
        }

        .info-item {
            background: rgba(15, 19, 24, 0.4);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid rgba(108, 140, 255, 0.1);
            text-align: center;
        }

        .info-label {
            font-size: 0.75rem;
            color: #a0a8b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 0.9rem;
            color: #e6eaf3;
            font-weight: 500;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
        }

        th,
        td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid rgba(108, 140, 255, 0.1);
            font-size: 0.85rem;
        }

        th {
            background: rgba(15, 19, 24, 0.6);
            color: #6c8cff;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            body {
                padding: 16px;
                font-size: 14px;
            }

            .page-wrapper {
                padding-top: 60px;
                max-width: none;
            }

            .main-header {
                margin-bottom: 32px;
            }

            .main-header h1 {
                font-size: 1.6rem;
                line-height: 1.3;
                word-break: normal;
                margin-bottom: 16px;
            }

            .main-header p {
                font-size: 0.9rem;
                line-height: 1.4;
            }

            .card {
                padding: 20px;
                border-radius: 16px;
                margin-bottom: 24px;
            }

            .card-title {
                font-size: 1rem;
                line-height: 1.4;
                word-break: normal;
                margin-bottom: 20px;
            }

            .btn-group {
                gap: 12px;
                margin: 20px 0;
            }

            .btn-group-2 .btn,
            .btn-group-3 .btn {
                flex: 0 0 100%;
                margin-bottom: 12px;
            }

            .btn-group-2 .btn:last-child,
            .btn-group-3 .btn:last-child {
                margin-bottom: 0;
            }

            .btn-group .btn {
                min-height: 48px;
                font-size: 0.85rem;
                padding: 14px 18px;
                line-height: 1.3;
            }

            .btn {
                font-size: 0.85rem;
                padding: 14px 18px;
                line-height: 1.3;
                min-height: 48px;
            }

            /* Stack cards vertically on mobile */
            .grid-2 {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            #backToMainBtn {
                top: 12px;
                right: 12px;
                font-size: 0.75rem;
                padding: 6px 10px;
                white-space: nowrap;
            }

            .form-input {
                font-size: 16px;
                /* Prevents zoom on iOS */
                line-height: 1.4;
                padding: 14px 16px;
                margin-bottom: 4px;
                font-family: var(--font-ui);
            }

            .form-label {
                font-size: 0.85rem;
                margin-bottom: 8px;
                font-family: var(--font-ui);
            }

            .form-group {
                margin-bottom: 24px;
                font-family: var(--font-ui);
            }

            .status {
                font-size: 0.85rem;
                line-height: 1.4;
                text-align: left;
                word-break: normal;
                padding: 14px 16px;
                margin: 16px 0;
            }

            .balance-display {
                padding: 16px;
                margin: 16px 0;
            }

            .balance-amount {
                font-size: 1.1rem;
                margin-bottom: 6px;
            }

            .balance-label {
                font-size: 0.75rem;
            }

            /* Better text handling */
            p,
            div,
            span {
                word-break: normal;
                overflow-wrap: break-word;
                hyphens: auto;
            }

            /* Address and hash specific styling */
            .address-text,
            .hash-text {
                font-size: 0.65rem;
                word-break: break-all;
                overflow-wrap: anywhere;
            }

            /* Specific mobile sizing for token lists */
            #myTokensList,
            #allTokensList {
                font-size: 0.75rem;
                line-height: 1.3;
                padding: 8px;
                max-height: 350px;
            }

            table {
                font-size: 0.75rem;
                margin: 12px 0;
            }

            th,
            td {
                padding: 8px 6px;
                font-size: 0.75rem;
            }

            /* Mobile price status */
            #priceStatus {
                font-size: 0.8rem;
            }

            /* Mobile notification adjustments */
            #statusContainer {
                top: 10px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                width: 95% !important;
                max-width: 350px !important;
            }

            /* Creator Token Cards Mobile Styling */
            .token-card {
                margin-bottom: 16px !important;
                padding: 20px !important;
                border-radius: 12px !important;
            }

            /* Contract Address Section Mobile Centering */
            .token-card .contract-address {
                text-align: center !important;
                margin: 0 auto !important;
                min-width: unset !important;
                word-break: break-all !important;
                font-size: 0.75rem !important;
                padding: 10px 12px !important;
            }

            /* Mobile Contract Address Container */
            .token-card div[style*="flex-wrap: wrap"] {
                flex-direction: column !important;
                align-items: center !important;
                gap: 12px !important;
            }

            /* Explore Button Mobile */
            .token-card a[href*="basescan.org"] {
                align-self: center !important;
                font-size: 0.75rem !important;
                padding: 10px 20px !important;
            }

            /* Info Grid Mobile - Stack Vertically */
            .info-grid {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
                margin: 16px 0 !important;
            }

            /* Token Card Header Mobile */
            .token-card div[style*="display: flex; justify-content: space-between"] {
                flex-direction: column !important;
                align-items: center !important;
                text-align: center !important;
                gap: 12px !important;
                margin-bottom: 16px !important;
            }

            /* Status Badge Mobile */
            .token-card .status-badge {
                font-size: 0.75rem !important;
                padding: 6px 12px !important;
            }

            /* Token Name Mobile */
            .token-card div[style*="font-weight: 800"] {
                font-size: 1.1rem !important;
                text-align: center !important;
            }

            /* Token Symbol Mobile */
            .token-card div[style*="color: #718096"] {
                text-align: center !important;
                font-size: 0.85rem !important;
            }
        }

        /* Additional mobile optimizations for smaller screens */
        @media (max-width: 480px) {
            .token-card {
                padding: 16px !important;
                margin-bottom: 12px !important;
            }

            .token-card .contract-address {
                font-size: 0.7rem !important;
                padding: 8px 10px !important;
            }

            .token-card a[href*="basescan.org"] {
                font-size: 0.7rem !important;
                padding: 8px 16px !important;
            }

            .info-grid>div {
                padding: 16px !important;
            }

            .token-card div[id*="fees-section"] {
                padding: 18px !important;
            }
        }

        /* Mobile token management section spacing */
        @media (max-width: 768px) {
            #tokenManagementSection {
                margin-top: 30px !important;
                gap: 24px !important;
            }

            /* Mobile token cards improvements */
            #myTokensCard,
            #adminTokensCard {
                padding: 20px !important;
            }

            /* Mobile token list container */
            #myTokensList {
                padding: 12px !important;
                border-radius: 12px;
                background: rgba(15, 19, 24, 0.3);
                border: 1px solid rgba(108, 140, 255, 0.1);
            }
        }

        /* Professional Enhancement Styles */
        .page-wrapper {
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Enhanced Loading States */
        .loading-shimmer {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            background-size: 200% 100%;
            animation: shimmerEffect 1.5s infinite;
        }

        @keyframes shimmerEffect {
            0% {
                background-position: -200% 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        /* Premium Status Indicators */
        .status-success {
            background: linear-gradient(135deg, #10b981, #059669);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .status-error {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }

        /* Elegant Balance Display */
        .balance-display {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .balance-display::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
            transition: left 0.5s;
        }

        .balance-display:hover::before {
            left: 100%;
        }

        .balance-display:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .balance-amount {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f8fafc;
            margin-bottom: 4px;
        }

        .balance-label {
            font-size: 0.85rem;
            color: #94a3b8;
            font-weight: 500;
        }

        /* Refined Grid Layouts */
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 32px;
            margin-bottom: 32px;
        }

        @media (max-width: 968px) {
            .grid-2 {
                grid-template-columns: 1fr;
                gap: 24px;
            }
        }

        /* Premium Form Labels */
        .form-label {
            display: block;
            font-size: 0.9rem;
            font-weight: 600;
            color: #94a3b8;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
            position: relative;
        }

        /* Enhanced Back Button */
        #backToMainBtn {
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #backToMainBtn:hover {
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        /* Tablet and larger */
        @media (min-width: 769px) {
            .page-wrapper {
                padding: 60px 32px 40px 32px;
            }

            .main-header h1 {
                font-size: 2.5rem;
            }

            .btn-group {
                flex-direction: row;
            }

            .info-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }

            .layout-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 32px;
                align-items: start;
            }
        }

        /* Desktop */
        @media (min-width: 1024px) {
            .main-header h1 {
                font-size: 2.8rem;
            }

            .card {
                padding: 28px;
            }
        }

        /* Hide elements initially */
        [style*="display:none"],
        [style*="display: none"] {
            display: none !important;
        }

        /* Content containment fixes */
        .card-content {
            overflow: hidden;
            word-wrap: break-word;
            max-width: 100%;
        }

        #myTokensList,
        #allTokensList {
            overflow-x: auto;
            overflow-y: auto;
            max-height: 400px;
            word-wrap: break-word;
            word-break: break-all;
            white-space: normal;
            line-height: 1.4;
            scrollbar-width: thin;
            scrollbar-color: rgba(108, 140, 255, 0.3) transparent;
        }

        #myTokensList::-webkit-scrollbar,
        #allTokensList::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        #myTokensList::-webkit-scrollbar-track,
        #allTokensList::-webkit-scrollbar-track {
            background: rgba(15, 19, 24, 0.4);
            border-radius: 3px;
        }

        #myTokensList::-webkit-scrollbar-thumb,
        #allTokensList::-webkit-scrollbar-thumb {
            background: rgba(108, 140, 255, 0.3);
            border-radius: 3px;
        }

        #myTokensList::-webkit-scrollbar-thumb:hover,
        #allTokensList::-webkit-scrollbar-thumb:hover {
            background: rgba(108, 140, 255, 0.5);
        }

        /* Loading spinner animation */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e2e8f0;
            border-top: 2px solid #0ea5e9;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Table containment */
        .token-table {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            margin: 8px 0;
        }

        .token-table th,
        .token-table td {
            padding: 8px 6px;
            text-align: left;
            border-bottom: 1px solid rgba(108, 140, 255, 0.1);
            font-size: 0.75rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .token-table th {
            background: rgba(15, 19, 24, 0.6);
            color: #6c8cff;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* Mobile table adjustments */
        @media (max-width: 768px) {

            #myTokensList,
            #allTokensList {
                max-height: 280px;
                font-size: 0.7rem;
                line-height: 1.2;
                word-break: break-all;
                overflow-wrap: anywhere;
            }

            .token-table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }

            .token-table thead,
            .token-table tbody,
            .token-table th,
            .token-table td,
            .token-table tr {
                display: block;
            }

            .token-table thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }

            .token-table tr {
                border: 1px solid rgba(108, 140, 255, 0.1);
                margin-bottom: 8px;
                padding: 6px;
                border-radius: 6px;
                background: rgba(15, 19, 24, 0.3);
            }

            .token-table td {
                border: none;
                padding: 3px 0;
                text-align: left;
                white-space: normal;
                word-break: break-all;
                overflow-wrap: anywhere;
                font-size: 0.7rem;
            }

            .token-table td:before {
                content: attr(data-label) ": ";
                font-weight: 600;
                color: #6c8cff;
                display: inline-block;
                width: 70px;
                margin-right: 6px;
                flex-shrink: 0;
                font-size: 0.65rem;
            }
        }

        /* Token Selection Modal Styling */
        .token-selection-modal button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            opacity: 0.9;
        }

        .token-selection-modal button:active {
            transform: translateY(0);
        }

        .token-selection-modal label:hover {
            background-color: #e6f7e6 !important;
            border-color: #20c997 !important;
            transition: all 0.2s ease;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .token-selection-modal input[type="checkbox"] {
            transform: scale(1.3);
        }

        .token-selection-modal label {
            transition: all 0.2s ease;
        }

        .token-selection-modal label[disabled] {
            opacity: 0.6;
            cursor: not-allowed !important;
        }
    </style>
</head>

<body class="page-launch"> <!-- Determines hero picture -->
    <!-- Top chrome: fixed wrapper that always stays above the page -->
    <div class="site-chrome">
        <!-- Transaction Ticker Widget -->
        <iframe id="transaction-ticker-iframe" src="../transaction-ticker-widget.html" scrolling="no"
            title="Transaction Ticker">
        </iframe>

        <!-- ========== Nav Bar =============
        ====================================
        =================================-->

        <nav class="navbar">

            <!-- Left: Logo -->
            <div class="navlogo">WILD WEST</div>

            <!-- Center: Main Links -->
            <ul class="nav-links">
                <li><a href="../index.html">Home</a></li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Launch Token ▾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <!-- NOTE: from /pages/ use same-folder path, not ./pages/... -->
                        <li><a href="launch-base.html" role="menuitem" aria-current="page">Base</a></li>
                        <li><a href="coming-soon.html" role="menuitem">Solana (Coming soon!)</a></li>
                    </ul>
                </li>

                <li><a href="coming-soon.html">NFT Marketplace</a></li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Staking ▾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <li><a href="coming-soon.html" role="menuitem">Base</a></li>
                        <li><a href="coming-soon.html" role="menuitem">Solana (Coming soon!)</a></li>
                    </ul>
                </li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Token Locking ▾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <li><a href="locking-base.html" role="menuitem">Base</a></li>
                        <li><a href="locking-solana.html" role="menuitem">Solana</a></li>
                    </ul>
                </li>

                <li><a href="furnace.html">Token Furnace</a></li>
                <li><a href="the-team.html">The Team</a></li>
                <li><a href="coming-soon.html">Arcade</a></li> <!-- (double-check: both go to team.html) -->
            </ul>

            <!-- Right: Icons -->
            <div class="nav-actions">
                <a href="https://t.me/wildwestlaunchpad" target="_blank" rel="noopener">
                    <img src="../images/icons/icons8-telegram-app-240_WHITE.png" alt="Telegram" class="nav-icon">
                </a>
                <a href="https://x.com/WILDWESTLP?t=wmcDfvCKnkAaLCtJbmAxgA" target="_blank" rel="noopener">
                    <img src="../images/icons/icons8-twitterx-240_WHITE.png" alt="Twitter/X" class="nav-icon">
                </a>
                <a href="https://dexscreener.com/base/0x8129609e5303910464fce3022a809fa44455fe9a" target="_blank"
                    rel="noopener">
                    <img src="../images/icons/661375b92a7e161501f4b5e5_dexscreener.322a5a2d_WHITE.png" alt="DEXScreener"
                        class="nav-icon">
                </a>
                <div class="connect-wallet-btn">
                    <a>Connect Wallet</a>
                </div>
            </div>
        </nav>

        <!-- Token Furnace Style Wallet Modal System -->
        <script>
            // Utility function for mobile detection
            function isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
            }

            // Get mobile-aware wallet message
            function getMobileAwareWalletMessage() {
                if (isMobileDevice()) {
                    return 'Please open this website in your EVM wallet browser (MetaMask, Trust Wallet, Coinbase Wallet, etc.)';
                } else {
                    return 'Please install MetaMask or another compatible EVM wallet to use this application';
                }
            }

            // Token Furnace Style Wallet Modal Implementation for Base Launch
            document.addEventListener('DOMContentLoaded', function () {
                console.log('🚀 Base Launch: Setting up token furnace style wallet');
                setupBaseLaunchWallet();
            });

            function showChainSelectionModal() {
                console.log('🚀 Base Launch: showChainSelectionModal called!');

                // Focus on Ethereum/Base wallets only for base launch page
                const availableWallets = {
                    ethereum: []
                };

                // Detect Ethereum/Base wallets
                if (window.ethereum) {
                    const providers = window.ethereum.providers || [window.ethereum];

                    providers.forEach(provider => {
                        if (provider.isMetaMask) {
                            availableWallets.ethereum.push({ name: 'MetaMask', provider: provider });
                        }
                        if (provider.isCoinbaseWallet) {
                            availableWallets.ethereum.push({ name: 'Coinbase Wallet', provider: provider });
                        }
                        if (provider.isRabby) {
                            availableWallets.ethereum.push({ name: 'Rabby Wallet', provider: provider });
                        }
                        if (provider.isTrust) {
                            availableWallets.ethereum.push({ name: 'Trust Wallet', provider: provider });
                        }
                    });

                    if (availableWallets.ethereum.length === 0) {
                        availableWallets.ethereum.push({ name: 'Ethereum Wallet', provider: window.ethereum });
                    }
                }

                console.log('🔍 Base Launch: Detected wallets:', availableWallets);

                const modal = document.createElement('div');
                modal.id = 'walletConnectionModal'; // Add ID for easier reference
                modal.className = 'wallet-modal';
                modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center;
                z-index: 10000; animation: fadeIn 0.2s ease-out;
            `;

                let walletOptionsHTML = '';

                if (availableWallets.ethereum.length > 0) {
                    walletOptionsHTML += '<h4 style="color: #00eaff; margin: 1rem 0 0.5rem 0; font-size: 1rem; text-align: center;">Base Network (Ethereum)</h4>';
                    availableWallets.ethereum.forEach((wallet, index) => {
                        walletOptionsHTML += `
                        <button onclick="connectSpecificWallet('ethereum', ${index})" style="
                            display: block; width: 100%; margin: 8px 0; padding: 12px 16px;
                            background: linear-gradient(135deg, #0052ff, #0041cc);
                            color: white; border: 1px solid rgba(0, 234, 255, 0.3); border-radius: 8px;
                            cursor: pointer;
                            transition: all 0.3s ease; text-align: center;
                        " onmouseover="this.style.background='linear-gradient(135deg, #0066ff, #0052ff)'; this.style.borderColor='#00eaff'; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='linear-gradient(135deg, #0052ff, #0041cc)'; this.style.borderColor='rgba(0, 234, 255, 0.3)'; this.style.transform='translateY(0)'">
                            Connect ${wallet.name}
                        </button>
                    `;
                    });
                } else {
                    // Mobile-aware messaging when no wallets detected
                    if (isMobileDevice()) {
                        walletOptionsHTML = `
                        <div style="text-align: center; padding: 1rem; color: #ff6b6b;">
                            <h4 style="color: #ff6b6b; margin-bottom: 1rem; text-align: center;">Open in Wallet Browser</h4>
                            <p style="margin-bottom: 1.5rem; color: #c0c0c0; text-align: center; line-height: 1.5;">To use this application on mobile, please open this website in your EVM wallet's built-in browser:</p>
                            <div style="text-align: center; margin-bottom: 1.5rem;">
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">📱 MetaMask Mobile</span> → Browser Tab → Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">📱 Trust Wallet</span> → Browser Tab → Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">📱 Coinbase Wallet</span> → Browser Tab → Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">📱 Other EVM Wallets</span> → In-App Browser</p>
                            </div>
                            <div style="background: rgba(0, 234, 255, 0.1); border: 1px solid rgba(0, 234, 255, 0.3); border-radius: 8px; padding: 1rem; margin-top: 1rem;">
                                <p style="margin: 0; color: #00eaff; font-size: 0.85rem; font-weight: 500;">💡 Tip: Copy this URL and paste it in your mobile wallet's browser</p>
                            </div>
                        </div>
                    `;
                    } else {
                        walletOptionsHTML = `
                        <div style="text-align: center; padding: 1rem; color: #ff6b6b;">
                            <h4 style="color: #ff6b6b; margin-bottom: 1rem; text-align: center;">No Base Wallets Detected</h4>
                            <p style="margin-bottom: 1rem; color: #c0c0c0; text-align: center;">Please install a Base-compatible wallet:</p>
                            <section class="link-panel link-panel--center-vertically">
                              <a class="panel-item" href="https://metamask.io/" target="_blank" rel="noopener">
                                <img src="../images/metamask-strip-white.webp" alt="Project One" loading="lazy">
                              </a>

                              <a class="panel-item" href="https://www.coinbase.com/wallet" target="_blank" rel="noopener">
                                <img src="../images/coinbase-strip-white.webp" alt="Project Two" loading="lazy">
                              </a>

                              <a class="panel-item" href="https://trustwallet.com/" target="_blank" rel="noopener">
                                <img src="../images/trustwallet-strip-white.webp" alt="Project Three" loading="lazy">
                              </a>
                            </section>
                        </div>
                    `;
                    }
                }

                modal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #1a1a2e, #16213e);
                    border: 2px solid #00eaff;
                    border-radius: 16px;
                    box-shadow: 0 0 30px rgba(0, 234, 255, 0.3);
                    max-width: 400px;
                    width: 90vw;
                    max-height: 80vh;
                    overflow-y: auto;
                ">
                    <div style="
                        padding: 1.5rem;
                        border-bottom: 1px solid rgba(0, 234, 255, 0.2);
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <h3 style="margin: 0; color: #00eaff; font-size: 1.25rem; text-align: center;">Connect Base Wallet</h3>
                        <button class="close-modal-btn" style="
                            background: none; border: none; color: #00eaff; font-size: 1.5rem;
                            cursor: pointer; padding: 0; width: 30px; height: 30px;
                            display: flex; align-items: center; justify-content: center;
                            border-radius: 50%; transition: background-color 0.2s;
                        ">×</button>
                    </div>
                    <div style="padding: 1.5rem;">
                        ${walletOptionsHTML}
                        <button class="cancel-modal-btn" style="
                            display: block; width: 100%; margin-top: 1rem; padding: 10px;
                            background: rgba(102, 102, 102, 0.8); color: white;
                            border: 1px solid rgba(0, 234, 255, 0.2); border-radius: 8px;
                            cursor: pointer;
                            font-family: var(--font-ui);
                        ">Cancel</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);

                const closeBtn = modal.querySelector('.close-modal-btn');
                const cancelBtn = modal.querySelector('.cancel-modal-btn');

                function closeModal() {
                    modal.remove();
                }

                closeBtn.addEventListener('click', closeModal);
                cancelBtn.addEventListener('click', closeModal);
                modal.addEventListener('click', function (e) {
                    if (e.target === modal) closeModal();
                });

                // Store modal reference globally for easy closing
                window.currentWalletModal = modal;
                window.availableWallets = availableWallets;
            }

            window.connectSpecificWallet = async function (network, walletIndex) {
                console.log(`🔗 Base Launch: Connecting to wallet ${walletIndex} on ${network} network`);

                try {
                    if (network === 'ethereum') {
                        const wallet = window.availableWallets.ethereum[walletIndex];
                        if (!wallet) {
                            throw new Error(`Wallet not found at index ${walletIndex}`);
                        }

                        console.log(`📋 Base Launch: Connecting to ${wallet.name}`);

                        const accounts = await wallet.provider.request({ method: 'eth_requestAccounts' });
                        if (accounts.length > 0) {
                            try {
                                await wallet.provider.request({
                                    method: 'wallet_switchEthereumChain',
                                    params: [{ chainId: '0x2105' }], // Base mainnet
                                });
                            } catch (switchError) {
                                if (switchError.code === 4902) {
                                    await wallet.provider.request({
                                        method: 'wallet_addEthereumChain',
                                        params: [{
                                            chainId: '0x2105',
                                            chainName: 'Base',
                                            nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                                            rpcUrls: [BASE_RPC_URL],
                                            blockExplorerUrls: ['https://basescan.org']
                                        }]
                                    });
                                }
                            }

                            // Update global state for launch page
                            window.currentAddress = accounts[0];
                            window.currentChain = 'base';
                            window.currentProvider = wallet.provider;

                            // CRITICAL: Set the main script variables immediately
                            provider = new ethers.providers.Web3Provider(wallet.provider);
                            signer = provider.getSigner();
                            userAddress = accounts[0];

                            // Initialize CONTRACT
                            CONTRACT = new ethers.Contract(TOKEN_FACTORY_ADDRESS, TOKEN_FACTORY_ABI, signer);

                            console.log('🔧 Base Launch: FIXED - Set provider:', !!provider);
                            console.log('🔧 Base Launch: FIXED - Set userAddress:', userAddress);

                            // Close modal IMMEDIATELY after successful connection
                            if (window.currentWalletModal) {
                                console.log('🔄 Base Launch: Closing wallet modal immediately');
                                window.currentWalletModal.remove();
                                window.currentWalletModal = null;
                            }

                            // Fallback: close modal by ID if reference didn't work
                            const modalById = document.getElementById('walletConnectionModal');
                            if (modalById) {
                                console.log('🔄 Base Launch: Closing modal by ID (fallback)');
                                modalById.remove();
                            }

                            // Fallback: close any remaining wallet modal by class
                            const modalByClass = document.querySelector('.wallet-modal');
                            if (modalByClass) {
                                console.log('🔄 Base Launch: Closing modal by class (fallback)');
                                modalByClass.remove();
                            }

                            // Update UI
                            updateBaseLaunchUI(accounts[0]);

                            console.log(`✅ Base Launch: ${wallet.name} connected successfully!`);

                            // Load dashboards directly instead of page reload
                            setTimeout(async () => {
                                console.log('🔄 Base Launch: Loading user tokens...');
                                try {
                                    await connectWallet();
                                    await refreshDashboards();
                                } catch (e) {
                                    console.error('Dashboard loading failed:', e);
                                }
                            }, 500);

                            console.log(`✅ Base Launch: ${wallet.name} connected successfully!`);
                        }
                    }
                } catch (error) {
                    const walletName = window.availableWallets.ethereum[walletIndex]?.name;
                    console.error(`❌ Base Launch: ${walletName} connection failed:`, error);
                    alert(`Connection failed: ${error.message}`);
                }
            };

            function updateBaseLaunchUI(address) {
                const connectBtn = document.getElementById('connectBtn');

                if (connectBtn) {
                    const shortAddr = `${address.slice(0, 6)}...${address.slice(-4)}`;
                    connectBtn.textContent = `Connected: ${shortAddr}`;
                    connectBtn.style.background = 'linear-gradient(135deg, #0070f3, #00c851, #0051cc)';
                    connectBtn.style.backgroundSize = '200% 200%';
                    connectBtn.style.animation = 'gradientShift 6s ease infinite';
                    connectBtn.disabled = false; // Keep button clickable for disconnect option
                    connectBtn.style.cursor = 'pointer'; // Show it's still clickable
                }

                // Hide the connection prompt when wallet is connected
                const connectionStatus = document.getElementById('connectionStatus');
                if (connectionStatus) {
                    connectionStatus.style.display = 'none';
                }

                // Show main content after wallet connection
                const mainContent = document.getElementById('mainContent');
                const priceStatus = document.getElementById('priceStatus');
                const tokenManagement = document.getElementById('tokenManagementSection');
                if (mainContent) mainContent.style.display = 'block';
                if (priceStatus) priceStatus.style.display = 'block';
                if (tokenManagement) tokenManagement.style.display = 'block';

                // Enable functionality
                document.querySelectorAll('.form-input, .btn').forEach(el => {
                    if (el.id !== 'connectBtn') {
                        el.disabled = false;
                    }
                });

                // Update displays
                if (typeof updateDisplays === 'function') {
                    updateDisplays();
                }

                console.log('✅ Base Launch: UI updated and functionality enabled');
            }

            function setupBaseLaunchWallet() {
                console.log('🔧 Base Launch: Setting up wallet connection');

                const connectBtn = document.getElementById('connectBtn');
                if (!connectBtn) {
                    console.error('❌ Base Launch: Connect wallet button not found');
                    return;
                }

                connectBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🔗 Base Launch: Connect button clicked');
                    handleConnectButtonClick();
                });

                // Ensure button is properly centered on page load
                adjustButtonGroupLayout();

                console.log('✅ Base Launch: Wallet setup complete');
            }

            // Smart connect button handler - connects or disconnects based on current state
            function handleConnectButtonClick() {
                // Check if wallet is already connected
                if (userAddress && provider) {
                    // Wallet is connected, ask if user wants to disconnect
                    const shortAddr = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                    const confirmDisconnect = confirm(`Disconnect wallet ${shortAddr}?\n\nThis will hide all token management features and return you to the connection screen.`);

                    if (confirmDisconnect) {
                        console.log('🔌 User requested wallet disconnection');
                        handleWalletDisconnect();
                    }
                } else {
                    // Wallet is not connected, show connection modal
                    console.log('🔗 User wants to connect wallet');
                    showChainSelectionModal();
                }
            }

            // Global variables
            window.currentAddress = null;
            window.currentChain = null;
            window.currentProvider = null;

            // NEW ANTI-SNIPER & ENHANCED FUNCTIONS

            // Helper function to load user tokens using createdTokens mapping
            async function getUserTokens(userAddress) {
                const tokens = [];
                let tokenIndex = 0;
                let maxAttempts = 100; // Prevent infinite loops

                try {
                    while (tokenIndex < maxAttempts) {
                        try {
                            const tokenInfo = await CONTRACT.createdTokens(userAddress, tokenIndex);
                            // Check if we got a valid token (tokenAddress != 0x0)
                            if (tokenInfo[0] && tokenInfo[0] !== '0x0000000000000000000000000000000000000000') {
                                tokens.push(tokenInfo);
                                tokenIndex++;
                            } else {
                                break; // No more tokens
                            }
                        } catch (e) {
                            break; // No more tokens or error occurred
                        }
                    }
                } catch (err) {
                    console.log('Error loading user tokens:', err.message);
                }

                return tokens;
            }

            // Batch swap accumulated token fees
            async function batchSwapTokens() {
                console.log('🚀 batchSwapTokens() function called!');
                console.log('CONTRACT:', CONTRACT);
                console.log('User Address:', userAddress);

                if (!CONTRACT || !userAddress) {
                    console.log('❌ Missing CONTRACT or userAddress');
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    console.log('🔄 Starting token fee swap...');

                    // First get user's tokens to check if they have any
                    const userTokens = await getUserTokens(userAddress);
                    console.log('📋 User tokens found:', userTokens.length);

                    if (userTokens.length === 0) {
                        showStatus('No tokens found. Please create a token first.', 'error');
                        return;
                    }

                    // Check different types of balances that might be stuck
                    console.log('🔍 Checking for different types of stuck tokens...');

                    // Check creator token balance (fees earned as tokens)
                    const tokenBalance = await CONTRACT.getCreatorTokenBalance(userAddress);
                    console.log('💰 Creator token balance:', ethers.utils.formatEther(tokenBalance), 'tokens');

                    // Check if there are any LP token fees accumulated
                    let hasStuckTokens = false;
                    const tokenAddress = userTokens[0][0]; // First token address
                    console.log('🎯 Checking token:', tokenAddress);

                    // Try to check if CONTRACT has any of the user's tokens
                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function decimals() view returns (uint8)",
                        "function symbol() view returns (string)"
                    ];

                    const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                    const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                    const tokenSymbol = await tokenCONTRACT.symbol();

                    console.log('🏦 CONTRACT balance of', tokenSymbol + ':', ethers.utils.formatEther(CONTRACTTokenBalance));

                    if (tokenBalance.gt(0)) {
                        console.log('✅ Found creator token fees to swap');
                        hasStuckTokens = true;
                    } else if (CONTRACTTokenBalance.gt(0)) {
                        console.log('✅ Found CONTRACT token balance that might need swapping');
                        hasStuckTokens = true;
                    } else {
                        showStatus('No stuck tokens found to swap. Token balance: ' + ethers.utils.formatEther(tokenBalance) + ', CONTRACT balance: ' + ethers.utils.formatEther(CONTRACTTokenBalance), 'info');
                        return;
                    }

                    // Proceed with swap
                    console.log('🔄 Attempting to swap tokens for:', tokenAddress);
                    console.log('📊 Creator token balance to swap:', ethers.utils.formatEther(tokenBalance));
                    console.log('🏦 CONTRACT token balance found:', ethers.utils.formatEther(CONTRACTTokenBalance));

                    // The tokens are stuck in the CONTRACT but not assigned to creator yet
                    // Try rescueAndSellStuckTokens function instead
                    console.log('💡 Using rescueAndSellStuckTokens to rescue stuck tokens...');
                    showStatus('Collecting rewards from your tokens...', 'info');

                    try {
                        console.log('� Calling rescueAndSellStuckTokens for token:', tokenAddress);
                        const rescueTx = await CONTRACT.rescueAndSellStuckTokens([tokenAddress]);
                        console.log('⏳ Rescue transaction sent:', rescueTx.hash);

                        const rescueReceipt = await rescueTx.wait();
                        console.log('✅ Rescue confirmed:', rescueReceipt.transactionHash);

                        if (rescueReceipt.logs && rescueReceipt.logs.length > 0) {
                            console.log('� Rescue completed with', rescueReceipt.logs.length, 'events');
                        }

                        showStatus('Rewards successfully collected and converted to ETH!', 'success');

                        // Refresh displays to show updated ETH balances
                        await checkPlatformFees();
                        return;

                    } catch (rescueError) {
                        console.error('Rescue tokens error:', rescueError);
                        let errorMsg = 'Rescue failed: ' + rescueError.message;

                        if (rescueError.message.includes('execution reverted')) {
                            errorMsg = 'Rescue failed - may be insufficient tokens or no liquidity';
                        } else if (rescueError.message.includes('user rejected')) {
                            errorMsg = 'Transaction rejected by user';
                        } else if (rescueError.message.includes('insufficient funds')) {
                            errorMsg = 'Insufficient ETH for gas fees';
                        }

                        showStatus('❌ ' + errorMsg, 'error');
                        return;
                    }

                    showStatus('Testing batch swap function directly...', 'info');

                    // First test with callStatic to see what the error is
                    try {
                        console.log('🧪 Testing batchSwapTokenFees with callStatic...');
                        const result = await CONTRACT.callStatic.batchSwapTokenFees(userAddress, tokenAddress);
                        console.log('✅ callStatic succeeded, result:', result);
                    } catch (testError) {
                        console.log('❌ callStatic failed:', testError.message);
                        if (testError.message.includes('INSUFFICIENT_BALANCE')) {
                            showStatus('Insufficient tokens available for processing', 'error');
                            return;
                        } else if (testError.message.includes('NO_LIQUIDITY')) {
                            showStatus('Trading liquidity not yet available for this token', 'error');
                            return;
                        } else if (testError.message.includes('NOT_AUTHORIZED')) {
                            showStatus('Unable to process tokens at this time', 'error');
                            return;
                        }
                        // Continue anyway to see the real error
                        console.log('🤔 Continuing with actual transaction despite callStatic error...');
                    }

                    showStatus('Processing token fees...', 'info');

                    // Call the batch swap function
                    const tx = await CONTRACT.batchSwapTokenFees(userAddress, tokenAddress);
                    console.log('⏳ Swap transaction sent:', tx.hash);

                    const receipt = await tx.wait();
                    console.log('✅ Swap confirmed:', receipt.transactionHash);

                    // Check how much was swapped
                    if (receipt.logs && receipt.logs.length > 0) {
                        console.log('📋 Swap completed with', receipt.logs.length, 'events');
                    }

                    showStatus('Token fees successfully processed!', 'success');

                    // Refresh displays to show updated ETH balances
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Batch swap error:', error);
                    let errorMsg = 'Batch swap failed: ' + error.message;

                    if (error.message.includes('execution reverted')) {
                        errorMsg = 'Swap failed - may be insufficient liquidity or slippage too high';
                    } else if (error.message.includes('user rejected')) {
                        errorMsg = 'Transaction rejected by user';
                    } else if (error.message.includes('insufficient funds')) {
                        errorMsg = 'Insufficient ETH for gas fees';
                    }

                    showStatus('❌ ' + errorMsg, 'error');
                }
            }

            // Show token selection dialog for multi-project fee collection
            async function showTokenSelectionDialog(tokenOptions) {
                return new Promise((resolve) => {
                    // Create modal dialog
                    const modal = document.createElement('div');
                    modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                    const dialog = document.createElement('div');
                    dialog.className = 'token-selection-modal';
                    dialog.style.cssText = `
                    background: white;
                    border-radius: 10px;
                    padding: 30px;
                    max-width: 600px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;

                    const tokensWithRewards = tokenOptions.filter(opt => opt.hasRewards);
                    const tokensWithoutRewards = tokenOptions.filter(opt => !opt.hasRewards);

                    dialog.innerHTML = `
                    <h2 style="margin-top: 0; color: #333; text-align: center;">Select Tokens to Collect Rewards</h2>
                    <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 12px; margin-bottom: 20px; color: #856404;">
                        <strong>Multiple Transaction Notice:</strong> Each selected token will require a separate transaction. You'll need to approve each transaction in your wallet.
                    </div>
                    <p style="color: #666; text-align: center; margin-bottom: 25px;">
                        Choose which tokens you want to collect LP rewards from to save on gas fees.
                    </p>
                    
                    ${tokensWithRewards.length > 0 ? `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #28a745; margin-bottom: 15px;">Tokens with Available Rewards:</h3>
                            ${tokensWithRewards.map(opt => `
                                <label style="display: block; margin-bottom: 10px; padding: 15px; border: 2px solid #28a745; border-radius: 8px; cursor: pointer; background-color: #f8fff8;">
                                    <input type="checkbox" value="${opt.index}" checked style="margin-right: 10px; transform: scale(1.3);">
                                    <div style="color: #333;">
                                        <strong style="font-size: 16px; color: #1a5f1a;">${opt.symbol}</strong>
                                        <br>
                                        <span style="color: #555; font-size: 14px;">Available: ${opt.rewardDisplay}</span>
                                        <br>
                                        <span style="color: #777; font-size: 12px;">Position ID: ${opt.tokenId}</span>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${tokensWithoutRewards.length > 0 ? `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #dc3545; margin-bottom: 15px;">Tokens without Rewards:</h3>
                            ${tokensWithoutRewards.map(opt => `
                                <label style="display: block; margin-bottom: 10px; padding: 15px; border: 2px solid #ddd; border-radius: 8px; background-color: #f8f8f8;">
                                    <input type="checkbox" value="${opt.index}" disabled style="margin-right: 10px; transform: scale(1.3);">
                                    <div style="color: #666;">
                                        <strong style="font-size: 16px; color: #999;">${opt.symbol}</strong>
                                        <br>
                                        <span style="color: #999; font-size: 14px;">No rewards available</span>
                                        <br>
                                        <span style="color: #bbb; font-size: 12px;">Position ID: ${opt.tokenId || 'unknown'}</span>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 30px; flex-wrap: wrap;">
                        <button id="selectAll" style="padding: 12px 24px; background-color: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Select All Available
                        </button>
                        <button id="confirmSelection" style="padding: 12px 24px; background-color: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Collect Selected (${tokensWithRewards.length} txns)
                        </button>
                        <button id="cancelSelection" style="padding: 12px 24px; background-color: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Cancel
                        </button>
                    </div>
                `;

                    modal.appendChild(dialog);
                    document.body.appendChild(modal);

                    // Event listeners
                    const selectAllBtn = dialog.querySelector('#selectAll');
                    const confirmBtn = dialog.querySelector('#confirmSelection');
                    const cancelBtn = dialog.querySelector('#cancelSelection');
                    const checkboxes = dialog.querySelectorAll('input[type="checkbox"]:not([disabled])');

                    // Function to update button text based on selection
                    const updateConfirmButtonText = () => {
                        const selectedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
                        confirmBtn.textContent = `Collect Selected (${selectedCount} txns)`;
                        confirmBtn.disabled = selectedCount === 0;
                        confirmBtn.style.opacity = selectedCount === 0 ? '0.5' : '1';
                    };

                    // Add change listeners to checkboxes
                    checkboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', updateConfirmButtonText);
                    });

                    selectAllBtn.addEventListener('click', () => {
                        checkboxes.forEach(cb => cb.checked = true);
                        updateConfirmButtonText();
                    });

                    confirmBtn.addEventListener('click', () => {
                        const selected = Array.from(checkboxes)
                            .filter(cb => cb.checked)
                            .map(cb => parseInt(cb.value));

                        document.body.removeChild(modal);
                        resolve(selected);
                    });

                    cancelBtn.addEventListener('click', () => {
                        document.body.removeChild(modal);
                        resolve(null);
                    });

                    // Close on backdrop click
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            document.body.removeChild(modal);
                            resolve(null);
                        }
                    });
                });
            }

            // Collect tokens directly to creator wallet (no conversion needed)
            async function transferTokensToCreator() {
                console.log('🚀 Collect creator tokens from selected projects directly to wallet!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    console.log('🔄 Starting direct creator token collection...');

                    // Get current creator's tokens
                    const userTokens = await getUserTokens(userAddress);
                    if (userTokens.length === 0) {
                        showStatus('No tokens found for your wallet address', 'error');
                        return;
                    }

                    console.log(`📊 Found ${userTokens.length} token(s) available for collection`);

                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function symbol() view returns (string)"
                    ];

                    // Step 1: If multiple tokens, let user select which ones to collect
                    let selectedTokens = userTokens;

                    if (userTokens.length === 1) {
                        console.log('🔄 Single token found, processing directly...');
                        const tokenInfo = userTokens[0];
                        const tokenAddress = tokenInfo[0];
                        const tokenId = tokenInfo[4];

                        // Quick check if single token has rewards
                        try {
                            const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                            const contractBalance = await tokenContract.balanceOf(CONTRACT.address);
                            const tokenSymbol = await tokenContract.symbol();

                            console.log(`📊 Single token ${tokenSymbol} - contract balance:`, ethers.utils.formatEther(contractBalance));

                            if (contractBalance.eq(0)) {
                                // Check position rewards as well
                                try {
                                    const positionManagerContract = new ethers.Contract(
                                        '0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1',
                                        [
                                            "function positions(uint256) view returns (uint96, address, address, address, uint24, int24, int24, uint128, uint256, uint256, uint128, uint128)"
                                        ],
                                        provider
                                    );

                                    const position = await positionManagerContract.positions(tokenId);
                                    const tokensOwed0 = position[10];
                                    const tokensOwed1 = position[11];

                                    console.log(`💰 Single token position ${tokenId} - tokensOwed0:`, ethers.utils.formatEther(tokensOwed0));
                                    console.log(`💰 Single token position ${tokenId} - tokensOwed1:`, ethers.utils.formatEther(tokensOwed1));

                                    if (tokensOwed0.eq(0) && tokensOwed1.eq(0)) {
                                        showStatus(`No LP rewards available for ${tokenSymbol}. Position may need to be refreshed.`, 'info');
                                        return;
                                    }
                                } catch (posError) {
                                    console.log('⚠️ Could not check position for single token:', posError.message);
                                    showStatus(`No LP rewards available for ${tokenSymbol}. Contract balance is zero.`, 'info');
                                    return;
                                }
                            }
                        } catch (error) {
                            console.log('❌ Error checking single token:', error.message);
                        }
                    } else {
                        console.log('Multiple tokens found, reading reward data from existing cards...');
                        showStatus('Reading reward data from your token cards...', 'info');

                        // Get reward data from existing cards instead of re-detecting
                        const tokenOptions = [];
                        for (let i = 0; i < userTokens.length; i++) {
                            const tokenInfo = userTokens[i];
                            const tokenAddress = tokenInfo[0];
                            const tokenId = tokenInfo[4];

                            try {
                                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                                const tokenSymbol = await tokenContract.symbol();

                                // Find the corresponding fee section by token ID
                                const feesSectionId = `fees-section-${tokenId}`;
                                const feesSection = document.getElementById(feesSectionId);
                                let cardRewardText = '';
                                let hasRewards = false;

                                if (feesSection) {
                                    // Extract ETH and token amounts from the fee section
                                    const ethFeesElement = feesSection.querySelector('.eth-fees span');
                                    const tokenFeesElement = feesSection.querySelector('.token-fees span');

                                    const ethText = ethFeesElement ? ethFeesElement.textContent : '';
                                    const tokenText = tokenFeesElement ? tokenFeesElement.textContent : '';

                                    console.log(`Token ${tokenSymbol} - ETH text: "${ethText}", Token text: "${tokenText}"`);

                                    // Check if there are meaningful rewards
                                    const ethMatch = ethText.match(/([0-9.]+)\s*ETH/);
                                    const tokenMatch = tokenText.match(/\+\s*([0-9.]+)\s*\S+/);

                                    const ethAmount = ethMatch ? parseFloat(ethMatch[1]) : 0; // This is already creator's 50% share
                                    const tokenAmount = tokenMatch ? parseFloat(tokenMatch[1]) : 0;

                                    hasRewards = ethAmount > 0.000001 || tokenAmount > 0.000001;

                                    if (hasRewards) {
                                        const parts = [];
                                        if (ethAmount > 0.000001) parts.push(`${ethAmount.toFixed(6)} ETH`);
                                        if (tokenAmount > 0.000001) parts.push(`${tokenAmount.toFixed(6)} ${tokenSymbol}`);
                                        cardRewardText = parts.join(' + ');
                                    } else {
                                        cardRewardText = 'Very small or no rewards';
                                    }

                                    console.log(`Token ${tokenSymbol} - Final: hasRewards=${hasRewards}, display="${cardRewardText}"`);
                                } else {
                                    console.log(`No fee section found for token ID ${tokenId}`);
                                    cardRewardText = 'Fee section not found';
                                }

                                tokenOptions.push({
                                    index: i,
                                    tokenInfo: tokenInfo,
                                    symbol: tokenSymbol,
                                    hasRewards: hasRewards,
                                    rewardDisplay: cardRewardText.trim() || 'No reward data found',
                                    tokenId: tokenId.toString()
                                });

                            } catch (error) {
                                console.log(`Error processing token ${i}:`, error.message);
                                tokenOptions.push({
                                    index: i,
                                    tokenInfo: tokenInfo,
                                    symbol: `Token ${i + 1}`,
                                    hasRewards: false,
                                    rewardDisplay: 'Error loading data',
                                    tokenId: 'unknown'
                                });
                            }
                        }

                        // Show selection dialog
                        const tokensWithRewards = tokenOptions.filter(opt => opt.hasRewards);
                        const tokensWithoutRewards = tokenOptions.filter(opt => !opt.hasRewards);

                        console.log('📊 Token options summary:');
                        console.log('  Total tokens:', tokenOptions.length);
                        console.log('  Tokens with rewards:', tokensWithRewards.length);
                        console.log('  Tokens without rewards:', tokensWithoutRewards.length);

                        tokenOptions.forEach((opt, i) => {
                            console.log(`  ${i + 1}. ${opt.symbol}: hasRewards=${opt.hasRewards}, ETH=${opt.ethRewards}, Tokens=${opt.tokenRewards}`);
                        });

                        if (tokensWithRewards.length === 0) {
                            console.log('No tokens with rewards found');
                            showStatus('No LP rewards are currently available for your tokens. Try refreshing the page or waiting for more trading activity.', 'info');
                            return;
                        }

                        const selection = await showTokenSelectionDialog(tokenOptions);
                        if (!selection || selection.length === 0) {
                            showStatus('Collection cancelled by user.', 'info');
                            return;
                        }

                        selectedTokens = selection.map(index => userTokens[index]);
                        console.log(`👤 User selected ${selectedTokens.length} token(s) for collection`);
                    }

                    let totalCollected = 0;
                    let successfulCollections = 0;
                    const collectionResults = [];

                    // Step 2: Process each selected token project
                    for (let i = 0; i < selectedTokens.length; i++) {
                        const tokenInfo = selectedTokens[i];
                        const tokenAddress = tokenInfo[0];
                        const tokenId = tokenInfo[4];
                        const creatorAddress = userAddress;

                        console.log(`\n🔄 Processing selected token ${i + 1}/${selectedTokens.length}:`);
                        console.log('👤 Creator:', creatorAddress);
                        console.log('🪙 Token:', tokenAddress);
                        console.log('🆔 Token ID:', tokenId.toString());

                        try {
                            // Check current token balances for this token
                            const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                            const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                            const creatorWalletBalance = await tokenCONTRACT.balanceOf(creatorAddress);
                            const tokenSymbol = await tokenCONTRACT.symbol();

                            console.log(`🏦 CONTRACT has ${ethers.utils.formatEther(CONTRACTTokenBalance)} ${tokenSymbol}`);
                            console.log(`👤 Creator wallet has ${ethers.utils.formatEther(creatorWalletBalance)} ${tokenSymbol}`);

                            if (CONTRACTTokenBalance.eq(0)) {
                                console.log(`ℹ️ No LP fees available for ${tokenSymbol}, skipping...`);
                                collectionResults.push({ symbol: tokenSymbol, collected: '0', status: 'No fees available' });
                                continue;
                            }

                            // Collect LP fees from Uniswap position for this token
                            showStatus(`Collecting rewards from ${tokenSymbol} position (${i + 1}/${selectedTokens.length})...`, 'info');
                            try {
                                const collectTx = await CONTRACT.collectFees(tokenId);
                                console.log(`⏳ CollectFees transaction sent for ${tokenSymbol}:`, collectTx.hash);

                                const collectReceipt = await collectTx.wait();
                                console.log(`✅ CollectFees confirmed for ${tokenSymbol}:`, collectReceipt.transactionHash);

                                if (collectReceipt.logs && collectReceipt.logs.length > 0) {
                                    console.log(`📋 Collection completed for ${tokenSymbol} with ${collectReceipt.logs.length} events`);
                                }

                                // Check what we collected for this token
                                const newCONTRACTBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                                const newCreatorWalletBalance = await tokenCONTRACT.balanceOf(creatorAddress);
                                const creatorTokenBalance = await CONTRACT.getCreatorTokenBalance(creatorAddress);

                                const tokensCollected = CONTRACTTokenBalance.sub(newCONTRACTBalance);
                                const tokensToWallet = newCreatorWalletBalance.sub(creatorWalletBalance);

                                let collectedAmount = '0';
                                let status = 'Success';

                                if (tokensToWallet.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(tokensToWallet);
                                    console.log(`✅ ${collectedAmount} ${tokenSymbol} transferred to wallet`);
                                } else if (creatorTokenBalance.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(creatorTokenBalance);
                                    console.log(`✅ ${collectedAmount} ${tokenSymbol} collected`);
                                } else if (tokensCollected.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(tokensCollected);
                                    console.log(`✅ ${collectedAmount} ${tokenSymbol} rewards collected`);
                                } else {
                                    status = 'No token rewards found';
                                    console.log(`ℹ️ LP fees collected for ${tokenSymbol}, but no token rewards found`);
                                }

                                collectionResults.push({
                                    symbol: tokenSymbol,
                                    collected: collectedAmount,
                                    status: status
                                });

                                if (parseFloat(collectedAmount) > 0) {
                                    totalCollected += parseFloat(collectedAmount);
                                    successfulCollections++;
                                }

                            } catch (collectError) {
                                console.log(`❌ Collect LP fees failed for ${tokenSymbol}:`, collectError.message);
                                collectionResults.push({
                                    symbol: tokenSymbol,
                                    collected: '0',
                                    status: 'Collection failed: ' + collectError.message
                                });
                                // Continue with other tokens instead of stopping
                                continue;
                            }

                        } catch (tokenError) {
                            console.log(`❌ Error processing token ${i + 1}:`, tokenError.message);
                            collectionResults.push({
                                symbol: `Token ${i + 1}`,
                                collected: '0',
                                status: 'Processing error: ' + tokenError.message
                            });
                            continue;
                        }
                    }

                    // Step 2: Display comprehensive results
                    console.log('\n� Collection Summary:');
                    console.log(`✅ Successfully processed: ${successfulCollections}/${selectedTokens.length} selected tokens`);
                    console.log(`💰 Total value collected: ${totalCollected} tokens`);

                    let resultMessage = `Collection completed for ${selectedTokens.length} selected project(s):\n`;
                    collectionResults.forEach((result, index) => {
                        if (parseFloat(result.collected) > 0) {
                            resultMessage += `✅ ${result.symbol}: ${result.collected} tokens collected\n`;
                        } else {
                            resultMessage += `ℹ️ ${result.symbol}: ${result.status}\n`;
                        }
                    });

                    if (successfulCollections > 0) {
                        showStatus(`Success! Collected LP rewards from ${successfulCollections} selected project(s). Your wallet should now contain the collected tokens and you can now claim your ETH.`, 'success');
                        console.log(resultMessage);
                    } else if (collectionResults.length > 0) {
                        showStatus(`ℹ️ Processed ${selectedTokens.length} selected project(s) but no LP rewards were available to collect.`, 'info');
                    } else {
                        showStatus('No projects found to process.', 'error');
                    }

                    // Refresh displays to show updated balances
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Creator token collection error:', error);
                    showStatus('❌ Collection failed: ' + error.message, 'error');
                }
            }

            // Admin function to collect all platform fees and distribute them
            async function collectAllPlatformFees() {
                console.log('🔥 Admin: Collecting ALL platform fees!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    // First check if user is platform admin
                    const platformAdmin = await CONTRACT.platformAdmin();
                    console.log('👑 Platform admin address:', platformAdmin);
                    console.log('👤 Current user address:', userAddress);

                    if (userAddress.toLowerCase() !== platformAdmin.toLowerCase()) {
                        showStatus('❌ Only platform admin can collect all fees', 'error');
                        return;
                    }

                    console.log('✅ Admin verified, proceeding with platform-wide collection...');
                    showStatus('🔥 Admin: Starting platform-wide fee collection...', 'info');

                    // Get total token count
                    const totalTokens = await CONTRACT.getTokenCount();
                    console.log('📊 Total tokens in platform:', totalTokens.toString());

                    if (totalTokens.eq(0)) {
                        showStatus('No tokens in platform to collect fees from', 'info');
                        return;
                    }

                    // Step 1: Use collectAllTokens function to collect from all LP positions
                    showStatus('Step 1: Collecting fees from all LP positions...', 'info');
                    try {
                        const collectAllTx = await CONTRACT.collectAllTokens();
                        console.log('⏳ CollectAllTokens transaction sent:', collectAllTx.hash);

                        const collectAllReceipt = await collectAllTx.wait();
                        console.log('✅ CollectAllTokens confirmed:', collectAllReceipt.transactionHash);

                        if (collectAllReceipt.logs && collectAllReceipt.logs.length > 0) {
                            console.log('📋 Collection completed with', collectAllReceipt.logs.length, 'events');
                        }

                    } catch (collectAllError) {
                        console.log('❌ CollectAllTokens failed:', collectAllError.message);
                        showStatus('❌ Failed to collect from all positions: ' + collectAllError.message, 'error');
                        return;
                    }

                    // Step 2: Check what we collected
                    const platformFees = await CONTRACT.getPlatformFees();
                    console.log('🏢 Platform fees after collection:', ethers.utils.formatEther(platformFees), 'ETH');

                    showStatus('Step 2: Checking collected fees and token balances...', 'info');

                    // Step 3: For each token, try to convert any stuck tokens to ETH
                    showStatus('Step 3: Converting any stuck tokens to ETH...', 'info');

                    const tokenAddresses = [];

                    // Get all token addresses for rescue operation
                    for (let i = 0; i < Math.min(totalTokens.toNumber(), 50); i++) { // Limit to 50 for gas reasons
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            tokenAddresses.push(tokenInfo.tokenAddress);
                        } catch (error) {
                            console.log(`❌ Failed to get token ${i}:`, error.message);
                        }
                    }

                    console.log('🎯 Found', tokenAddresses.length, 'token addresses for rescue');

                    if (tokenAddresses.length > 0) {
                        try {
                            const rescueTx = await CONTRACT.rescueAndSellStuckTokens(tokenAddresses);
                            console.log('⏳ Rescue transaction sent:', rescueTx.hash);

                            const rescueReceipt = await rescueTx.wait();
                            console.log('✅ Rescue confirmed:', rescueReceipt.transactionHash);

                        } catch (rescueError) {
                            console.log('❌ Rescue failed (may be no stuck tokens):', rescueError.message);
                        }
                    }

                    // Step 4: Final fee check and summary
                    const finalPlatformFees = await CONTRACT.getPlatformFees();
                    console.log('💰 Final platform fees:', ethers.utils.formatEther(finalPlatformFees), 'ETH');

                    const totalCollected = finalPlatformFees.sub(platformFees);

                    if (totalCollected.gt(0)) {
                        showStatus(`✅ Success! Collected ${ethers.utils.formatEther(totalCollected)} ETH from all positions. Ready to withdraw platform fees.`, 'success');
                    } else {
                        showStatus('✅ Fee collection completed. No new fees were available across all positions.', 'success');
                    }

                    // Refresh displays
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Admin fee collection error:', error);
                    showStatus('❌ Admin collection failed: ' + error.message, 'error');
                }
            }

            // Function to collect fees for a specific token
            async function collectFeesForToken(tokenName) {
                console.log(`💰 COLLECTING FEES FOR ${tokenName}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("❌ Provider or CONTRACT not available");
                        showStatus('Please connect your wallet first', 'error');
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("👤 User address:", userAddress);

                    // Get all tokens to find the specific one
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    let targetToken = null;

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            if (tokenInfo.name && tokenInfo.name.includes(tokenName)) {
                                targetToken = tokenInfo;
                                console.log(`✅ Found ${tokenName}:`, tokenInfo);
                                break;
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    if (!targetToken) {
                        console.log(`❌ ${tokenName} not found!`);
                        showStatus(`❌ ${tokenName} not found in contract`, 'error');
                        return;
                    }

                    console.log(`🎯 Collecting fees for ${tokenName} (${targetToken.tokenAddress})`);
                    showStatus(`🔄 Collecting fees from ${tokenName}'s liquidity pool...`, 'info');

                    // Call the contract to collect fees for this token
                    const tx = await CONTRACT.collectTokenFees(targetToken.tokenAddress);
                    console.log("📝 Transaction sent:", tx.hash);
                    showStatus(`⏳ Collecting ${tokenName} fees... Transaction: ${tx.hash.substring(0, 10)}...`, 'info');

                    // Wait for confirmation
                    const receipt = await tx.wait();
                    console.log("✅ Transaction confirmed:", receipt);

                    showStatus(`✅ ${tokenName} fees collected successfully!`, 'success');

                    // Refresh fee displays
                    setTimeout(() => {
                        checkPlatformFees();
                        loadUserTokens();
                    }, 2000);

                } catch (error) {
                    console.error(`❌ Error collecting ${tokenName} fees:`, error);
                    showStatus(`❌ Failed to collect ${tokenName} fees: ${error.message}`, 'error');
                }
            }

            // Debug function to check all user tokens
            async function debugUserTokens() {
                console.log(`🔍 DEBUGGING ALL USER TOKENS`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("❌ Provider or CONTRACT not available");
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("👤 User address:", userAddress);
                    console.log("🏭 Contract address:", CONTRACT.address);

                    // Get all tokens
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    console.log("📊 Total tokens in contract:", totalTokenCount.toString());

                    let userTokens = [];
                    let totalUserFees = ethers.BigNumber.from("0");

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            console.log(`Token ${i}:`, tokenInfo);

                            // Check if user is the creator
                            if (tokenInfo.creator && tokenInfo.creator.toLowerCase() === userAddress.toLowerCase()) {
                                const tokenFees = ethers.BigNumber.from(tokenInfo.totalFeesETH || "0");
                                const creatorPortion = tokenFees.mul(50).div(100);

                                userTokens.push({
                                    index: i,
                                    name: tokenInfo.name,
                                    address: tokenInfo.tokenAddress,
                                    totalFees: ethers.utils.formatEther(tokenFees),
                                    creatorShare: ethers.utils.formatEther(creatorPortion)
                                });

                                totalUserFees = totalUserFees.add(creatorPortion);
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    console.log("🎯 USER'S TOKENS:");
                    userTokens.forEach((token, idx) => {
                        console.log(`  ${idx + 1}. ${token.name}`);
                        console.log(`     Address: ${token.address}`);
                        console.log(`     Total Fees: ${token.totalFees} ETH`);
                        console.log(`     Creator Share: ${token.creatorShare} ETH`);
                    });

                    console.log(`💰 Total lifetime earnings: ${ethers.utils.formatEther(totalUserFees)} ETH`);

                    // Check current withdrawable fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log("💸 Current withdrawable creator fees:", ethers.utils.formatEther(creatorFees), "ETH");

                    if (userTokens.length === 0) {
                        console.log("❌ No tokens found for current user in this contract!");
                        console.log("This could mean:");
                        console.log("1. You haven't created any tokens with this contract");
                        console.log("2. Your tokens were created with a previous contract version");
                        console.log("3. There's a mismatch in wallet address");
                    }

                } catch (error) {
                    console.error(`❌ Error debugging user tokens:`, error);
                }
            }

            // Enhanced debug function for specific token with detailed fee tracking
            async function debugTokenFees(tokenName) {
                console.log(`🔍 DEBUGGING FEES FOR ${tokenName}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("❌ Provider or CONTRACT not available");
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("👤 User address:", userAddress);
                    console.log("🏭 Contract address:", CONTRACT.address);

                    // Get all tokens
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    console.log("📊 Total tokens in contract:", totalTokenCount.toString());

                    // Find the specific token
                    let foundToken = null;
                    let tokenIndex = -1;

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            console.log(`Token ${i}:`, tokenInfo);

                            if (tokenInfo.name && tokenInfo.name.includes(tokenName)) {
                                foundToken = tokenInfo;
                                tokenIndex = i;
                                console.log(`✅ Found ${tokenName} at index ${i}:`, tokenInfo);
                                break;
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    if (!foundToken) {
                        console.log(`❌ ${tokenName} not found in current contract!`);
                        return;
                    }

                    console.log(`🎯 ${tokenName} DETAILED ANALYSIS:`);
                    console.log("  - Token Address:", foundToken.tokenAddress);
                    console.log("  - Creator:", foundToken.creator);
                    console.log("  - Total Fees (stored):", ethers.utils.formatEther(foundToken.totalFeesETH || "0"), "ETH");
                    console.log("  - Created by current user:", foundToken.creator.toLowerCase() === userAddress.toLowerCase());
                    console.log("  - Token raw data:", foundToken);

                    // Check if user is the creator
                    if (foundToken.creator.toLowerCase() === userAddress.toLowerCase()) {
                        const creatorPortion = ethers.BigNumber.from(foundToken.totalFeesETH || "0").mul(50).div(100);
                        console.log("💰 Creator's share:", ethers.utils.formatEther(creatorPortion), "ETH");
                    } else {
                        console.log("ℹ️ User is not the creator of this token");
                    }

                    // Check current withdrawable fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log("💸 Current withdrawable creator fees:", ethers.utils.formatEther(creatorFees), "ETH");

                    // Additional debugging - check if token has any Uniswap activity
                    console.log("🔍 CHECKING UNISWAP ACTIVITY...");
                    try {
                        const tokenContract = new ethers.Contract(foundToken.tokenAddress, [
                            "function balanceOf(address) view returns (uint256)",
                            "function totalSupply() view returns (uint256)",
                            "function name() view returns (string)",
                            "function symbol() view returns (string)"
                        ], provider);

                        const tokenSupply = await tokenContract.totalSupply();
                        console.log("📊 Token total supply:", ethers.utils.formatEther(tokenSupply));

                        // Check token balance in Uniswap V3 Position Manager (this is where LP tokens are held)
                        const POSITION_MANAGER = "0x03a520b32C04BF3bEEf7BF5d24FC2e9de0e4a1e7";
                        const lpBalance = await tokenContract.balanceOf(POSITION_MANAGER);
                        console.log("💧 Tokens in Uniswap LP:", ethers.utils.formatEther(lpBalance));

                        if (lpBalance.gt(0)) {
                            console.log("✅ Token has liquidity in Uniswap - trades should generate fees");
                            console.log("🔍 Fee generation requires actual trades/swaps on Uniswap");
                            console.log("💡 Try making a small swap on the token to generate fees");
                        } else {
                            console.log("⚠️ No tokens found in Uniswap LP - fees can only generate from trades");
                        }

                    } catch (tokenError) {
                        console.log("⚠️ Could not check token contract details:", tokenError.message);
                    }

                    console.log("🎯 DEBUGGING SUMMARY:");
                    console.log(`   Token exists in contract: YES`);
                    console.log(`   Creator matches user: ${foundToken.creator.toLowerCase() === userAddress.toLowerCase() ? 'YES' : 'NO'}`);
                    console.log(`   Fees stored in contract: ${ethers.utils.formatEther(foundToken.totalFeesETH || "0")} ETH`);
                    console.log(`   To generate fees: Make trades on Uniswap for this token`);

                } catch (error) {
                    console.error(`❌ Error debugging ${tokenName}:`, error);
                }
            }

            // Function to manually collect fees for a specific token
            async function manualCollectTokenFees(tokenAddress) {
                console.log(`🔄 MANUALLY COLLECTING FEES FOR TOKEN: ${tokenAddress}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("❌ Provider or CONTRACT not available");
                        return;
                    }

                    console.log("📞 Calling collectTokenFees...");
                    const tx = await CONTRACT.collectTokenFees(tokenAddress);
                    console.log("📋 Transaction sent:", tx.hash);

                    showStatus(`🔄 Collecting fees for token... TX: ${tx.hash}`, 'info');

                    const receipt = await tx.wait();
                    console.log("✅ Transaction confirmed:", receipt);

                    // Check fees again after collection
                    setTimeout(() => {
                        checkPlatformFees();
                    }, 3000);

                    showStatus(`✅ Fees collected successfully!`, 'success');

                } catch (error) {
                    console.error(`❌ Error collecting fees:`, error);
                    showStatus(`❌ Error collecting fees: ${error.message}`, 'error');
                }
            }

            // Debug function to understand withdrawal issues
            async function debugWithdrawCreatorFees() {
                console.log('🔍 DEBUGGING WITHDRAW CREATOR FEES');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    showStatus('🔍 Debugging withdrawal issue...', 'info');

                    // Check multiple calls to see if state is changing
                    console.log('📞 Making multiple getCreatorFees calls...');

                    const fees1 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('🔍 Call 1 - Creator fees:', ethers.utils.formatEther(fees1), 'ETH', '(' + fees1.toString() + ' wei)');

                    const fees2 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('🔍 Call 2 - Creator fees:', ethers.utils.formatEther(fees2), 'ETH', '(' + fees2.toString() + ' wei)');

                    const fees3 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('🔍 Call 3 - Creator fees:', ethers.utils.formatEther(fees3), 'ETH', '(' + fees3.toString() + ' wei)');

                    // Check CONTRACT ETH balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);
                    console.log('🏦 CONTRACT ETH balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH', '(' + CONTRACTBalance.toString() + ' wei)');

                    if (CONTRACTBalance.lt(fees1)) {
                        console.log('❌ CONTRACT BALANCE TOO LOW! CONTRACT has', ethers.utils.formatEther(CONTRACTBalance), 'but needs', ethers.utils.formatEther(fees1));
                        showStatus('Insufficient balance available for withdrawal', 'error');
                        return;
                    } else {
                        console.log('✅ CONTRACT has sufficient balance for withdrawal');
                    }

                    if (fees1.eq(fees2) && fees2.eq(fees3)) {
                        console.log('✅ Fees are consistent across calls');
                    } else {
                        console.log('❌ WARNING: Fees are changing between calls!');
                    }

                    // Check if amount is greater than 0
                    if (fees1.gt(0)) {
                        console.log('✅ Amount is greater than 0, should be withdrawable');

                        // Try to estimate gas for the withdrawal
                        try {
                            console.log('🔍 Trying to estimate gas for withdrawal...');
                            const gasEstimate = await CONTRACT.estimateGas.withdrawCreatorFees();
                            console.log('✅ Gas estimate successful:', gasEstimate.toString());

                            showStatus('✅ Gas estimation passed - trying actual withdrawal...', 'info');

                            // If gas estimation works, try the actual call
                            const tx = await CONTRACT.withdrawCreatorFees();
                            console.log('✅ Transaction submitted:', tx.hash);
                            showStatus('⏳ Waiting for confirmation...', 'info');

                            const receipt = await tx.wait();
                            console.log('✅ Transaction confirmed:', receipt.transactionHash);
                            showStatus('Withdrawal successful!', 'success');

                        } catch (gasError) {
                            console.log('❌ Gas estimation failed:', gasError.message);
                            console.log('❌ Full gas error:', gasError);

                            // Try to understand why gas estimation fails
                            if (gasError.message.includes('execution reverted')) {
                                console.log('💡 The CONTRACT is reverting - checking why...');

                                // Double-check the amount right before the call
                                const lastCheck = await CONTRACT.getCreatorFees(userAddress);
                                console.log('🔍 Final amount check:', ethers.utils.formatEther(lastCheck), 'ETH');

                                if (lastCheck.eq(0)) {
                                    showStatus('❌ Amount became 0 just before withdrawal - possible race condition', 'error');
                                } else {
                                    console.log('❌ CONTRACT is reverting even though amount > 0 - trying manual gas approach...');

                                    // Try with optimized gas limit
                                    try {
                                        console.log('🔧 Attempting withdrawal with optimized gas limit...');

                                        // Smart gas estimation for withdrawal
                                        let gasLimit;
                                        try {
                                            const estimatedGas = await CONTRACT.estimateGas.withdrawCreatorFees();
                                            gasLimit = Math.floor(estimatedGas.toNumber() * 1.2); // 20% buffer
                                            console.log(`💡 Withdrawal gas optimized: ${gasLimit}`);
                                        } catch (estError) {
                                            gasLimit = 80000; // Lower conservative limit
                                        }

                                        const tx = await CONTRACT.withdrawCreatorFees({
                                            gasLimit: gasLimit  // Optimized gas limit
                                        });
                                        console.log('✅ Optimized gas transaction submitted:', tx.hash);
                                        showStatus('⏳ Optimized withdrawal submitted...', 'info');

                                        const receipt = await tx.wait();
                                        console.log('✅ Manual gas withdrawal confirmed:', receipt.transactionHash);
                                        showStatus('✅ Manual gas withdrawal successful!', 'success');

                                    } catch (manualGasError) {
                                        console.log('❌ Manual gas also failed:', manualGasError.message);

                                        // Check if there's a minimum threshold issue
                                        if (lastCheck.lt(ethers.utils.parseEther('0.0001'))) {
                                            console.log('⚠️ Amount might be below minimum threshold');
                                            showStatus('❌ Amount too small - CONTRACT may have minimum withdrawal threshold', 'error');
                                        } else {
                                            showStatus('❌ CONTRACT bug confirmed - withdrawal impossible even with manual gas', 'error');
                                        }
                                    }
                                }
                            } else {
                                showStatus('❌ Gas estimation error: ' + gasError.message, 'error');
                            }
                        }

                    } else {
                        console.log('❌ Amount is 0, cannot withdraw');
                        showStatus('No fees available for withdrawal', 'error');
                    }

                } catch (error) {
                    console.error('❌ Debug error:', error);
                    showStatus('❌ Debug failed: ' + error.message, 'error');
                }
            }

            // Admin panel balance check with on-page results
            async function adminCheckBalance() {
                console.log('🔍 ADMIN: Checking CONTRACT balance vs expected fees');

                const resultDiv = document.getElementById('balanceCheckResult');
                const CONTRACTAddress = CONTRACT?.address || TOKEN_FACTORY_ADDRESS || "0xaB4FE16F395921081bD9895359cf173a2Eaa7125";

                if (!CONTRACT || !userAddress) {
                    resultDiv.innerHTML = '<div style="background:#fee2e2; color:#dc2626; padding:8px; border-radius:4px;">❌ Please connect your wallet first</div>';
                    resultDiv.style.display = 'block';
                    return;
                }

                try {
                    resultDiv.innerHTML = '<div style="background:#e0f2fe; color:#0369a1; padding:8px; border-radius:4px;">🔍 Checking CONTRACT balance...</div>';
                    resultDiv.style.display = 'block';

                    // Get expected fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalExpectedFees = creatorFees.add(platformFees);

                    // Get actual CONTRACT balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);

                    // Log to console for debugging
                    console.log('💰 Expected creator fees:', ethers.utils.formatEther(creatorFees), 'ETH');
                    console.log('🏢 Expected platform fees:', ethers.utils.formatEther(platformFees), 'ETH');
                    console.log('📊 Total expected fees:', ethers.utils.formatEther(totalExpectedFees), 'ETH');
                    console.log('🏦 Actual CONTRACT balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH');

                    let resultHTML = '';

                    if (CONTRACTBalance.eq(0)) {
                        console.log('❌ CONTRACT IS EMPTY! All ETH was drained.');
                        console.log('🔧 TO FIX: Send exactly', ethers.utils.formatEther(totalExpectedFees), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('🎯 EXACT AMOUNT IN WEI:', totalExpectedFees.toString());

                        resultHTML = `
                        <div style="background:#fee2e2; color:#dc2626; padding:12px; border-radius:6px; border-left:4px solid #dc2626;">
                            <div style="font-weight:600; margin-bottom:8px;">INSUFFICIENT BALANCE!</div>
                            <div style="margin-bottom:4px;">Expected rewards: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Current balance: <strong>0.000000 ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">TO RESOLVE:</div>
                                <div style="margin-bottom:4px;">Please contact support regarding the balance shortage</div>
                                <div style="font-weight:600; margin-bottom:2px;">Required amount:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-size:0.75rem; margin-bottom:4px;">${ethers.utils.formatEther(totalExpectedFees)} ETH</div>
                                <div style="margin-top:6px; font-size:0.7rem; color:rgba(0,0,0,0.7);">Exact wei: ${totalExpectedFees.toString()}</div>
                            </div>
                        </div>
                    `;
                    } else if (CONTRACTBalance.lt(totalExpectedFees)) {
                        const shortfall = totalExpectedFees.sub(CONTRACTBalance);
                        console.log('⚠️ CONTRACT UNDERFUNDED! Has', ethers.utils.formatEther(CONTRACTBalance), 'but owes', ethers.utils.formatEther(totalExpectedFees));
                        console.log('💸 SHORTFALL:', ethers.utils.formatEther(shortfall), 'ETH');
                        console.log('🔧 TO FIX: Send exactly', ethers.utils.formatEther(shortfall), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('🎯 EXACT SHORTFALL IN WEI:', shortfall.toString());

                        resultHTML = `
                        <div style="background:#fef3c7; color:#d97706; padding:12px; border-radius:6px; border-left:4px solid #d97706;">
                            <div style="font-weight:600; margin-bottom:8px;">CONTRACT UNDERFUNDED!</div>
                            <div style="margin-bottom:4px;">Expected fees: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Actual balance: <strong>${ethers.utils.formatEther(CONTRACTBalance)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Shortfall: <strong>${ethers.utils.formatEther(shortfall)} ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">TO FIX:</div>
                                <div style="margin-bottom:4px;">Send exactly <strong>${ethers.utils.formatEther(shortfall)} ETH</strong></div>
                                <div style="font-weight:600; margin-bottom:2px;">Send to this CONTRACT address:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-size:0.75rem; margin-bottom:4px; word-break:break-all;">${CONTRACTAddress}</div>
                                <div style="margin-top:6px; font-size:0.7rem; color:rgba(0,0,0,0.7);">Exact wei: ${shortfall.toString()}</div>
                            </div>
                        </div>
                    `;
                    } else {
                        const excess = CONTRACTBalance.sub(totalExpectedFees);
                        console.log('✅ CONTRACT has sufficient balance');
                        console.log('💰 EXCESS ETH (safe to rescue):', ethers.utils.formatEther(excess), 'ETH');
                        console.log('🎯 EXCESS IN WEI:', excess.toString());

                        resultHTML = `
                        <div style="background:#d1fae5; color:#065f46; padding:12px; border-radius:6px; border-left:4px solid #10b981;">
                            <div style="font-weight:600; margin-bottom:8px;">CONTRACT BALANCE OK!</div>
                            <div style="margin-bottom:4px;">Expected fees: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Actual balance: <strong>${ethers.utils.formatEther(CONTRACTBalance)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Excess (safe to rescue): <strong>${ethers.utils.formatEther(excess)} ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">CONTRACT Address:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-size:0.75rem; margin-bottom:4px; word-break:break-all;">${CONTRACTAddress}</div>
                            </div>
                        </div>
                    `;
                    }

                    resultDiv.innerHTML = resultHTML;

                } catch (error) {
                    console.error('❌ Balance check error:', error);
                    resultDiv.innerHTML = `
                    <div style="background:#fee2e2; color:#dc2626; padding:12px; border-radius:6px;">
                        <div style="font-weight:600; margin-bottom:4px;">❌ Balance Check Failed</div>
                        <div style="font-size:0.8rem;">${error.message}</div>
                    </div>
                `;
                }
            }

            // Helper function to adjust button group layout when buttons are hidden
            function adjustButtonGroupLayout() {
                const switchBtn = document.getElementById('switchNetworkBtn');
                const buttonGroup = switchBtn?.parentElement;

                if (buttonGroup && buttonGroup.classList.contains('btn-group-2')) {
                    if (switchBtn.style.display === 'none') {
                        buttonGroup.classList.remove('btn-group-2');
                        buttonGroup.classList.add('btn-group-full');
                    } else {
                        buttonGroup.classList.remove('btn-group-full');
                        buttonGroup.classList.add('btn-group-2');
                    }
                }
            }

            // Simple function to check CONTRACT ETH balance vs expected fees
            async function checkCONTRACTBalance() {
                console.log('🔍 CHECKING CONTRACT BALANCE VS EXPECTED FEES');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    showStatus('🔍 Checking CONTRACT balance...', 'info');

                    // Get expected fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalExpectedFees = creatorFees.add(platformFees);

                    // Get actual CONTRACT balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);

                    console.log('💰 Expected creator fees:', ethers.utils.formatEther(creatorFees), 'ETH');
                    console.log('🏢 Expected platform fees:', ethers.utils.formatEther(platformFees), 'ETH');
                    console.log('📊 Total expected fees:', ethers.utils.formatEther(totalExpectedFees), 'ETH');
                    console.log('🏦 Actual CONTRACT balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH');

                    if (CONTRACTBalance.eq(0)) {
                        console.log('❌ CONTRACT IS EMPTY! All ETH was drained.');
                        console.log('🔧 TO FIX: Send exactly', ethers.utils.formatEther(totalExpectedFees), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('🎯 EXACT AMOUNT IN WEI:', totalExpectedFees.toString());
                        showStatus('❌ CONTRACT has 0 ETH - fees were drained by rescue function!', 'error');
                    } else if (CONTRACTBalance.lt(totalExpectedFees)) {
                        const shortfall = totalExpectedFees.sub(CONTRACTBalance);
                        console.log('⚠️ CONTRACT UNDERFUNDED! Has', ethers.utils.formatEther(CONTRACTBalance), 'but owes', ethers.utils.formatEther(totalExpectedFees));
                        console.log('💸 SHORTFALL:', ethers.utils.formatEther(shortfall), 'ETH');
                        console.log('🔧 TO FIX: Send exactly', ethers.utils.formatEther(shortfall), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('🎯 EXACT SHORTFALL IN WEI:', shortfall.toString());
                        showStatus('⚠️ CONTRACT underfunded - rescue function drained some fees', 'error');
                    } else {
                        const excess = CONTRACTBalance.sub(totalExpectedFees);
                        console.log('✅ CONTRACT has sufficient balance');
                        console.log('💰 EXCESS ETH (safe to rescue):', ethers.utils.formatEther(excess), 'ETH');
                        console.log('🎯 EXCESS IN WEI:', excess.toString());
                        showStatus('✅ CONTRACT balance OK - withdrawal should work', 'success');
                    }

                } catch (error) {
                    console.error('❌ Balance check error:', error);
                    showStatus('❌ Balance check failed: ' + error.message, 'error');
                }
            }

            // Comprehensive rescue function for stuck tokens
            async function rescueStuckTokensComprehensive() {
                console.log('🚀 Comprehensive rescue function called!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    console.log('🔄 Starting comprehensive token rescue...');

                    // Get user's tokens
                    const userTokens = await getUserTokens(userAddress);
                    console.log('📋 User tokens found:', userTokens.length);

                    if (userTokens.length === 0) {
                        showStatus('No tokens found to rescue', 'error');
                        return;
                    }

                    const tokenAddress = userTokens[0][0]; // First token address
                    const tokenId = userTokens[0][4]; // Token ID
                    console.log('🎯 Rescuing token:', tokenAddress, 'with ID:', tokenId.toString());

                    // Check CONTRACT token balance
                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function symbol() view returns (string)"
                    ];

                    const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                    const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                    const tokenSymbol = await tokenCONTRACT.symbol();

                    console.log('🏦 CONTRACT balance of', tokenSymbol + ':', ethers.utils.formatEther(CONTRACTTokenBalance));

                    if (CONTRACTTokenBalance.eq(0)) {
                        showStatus('No tokens stuck in CONTRACT to rescue', 'info');
                        return;
                    }

                    // Method 1: collectFees with tokenId
                    showStatus('Method 1: Collecting LP fees for token...', 'info');
                    try {
                        const collectTx = await CONTRACT.collectFees(tokenId);
                        console.log('⏳ CollectFees transaction sent:', collectTx.hash);

                        const collectReceipt = await collectTx.wait();
                        console.log('✅ CollectFees confirmed:', collectReceipt.transactionHash);

                        showStatus('✅ LP fees collected successfully! Check your balances.', 'success');
                        await checkPlatformFees();
                        return;

                    } catch (collectError) {
                        console.log('❌ collectFees failed:', collectError.message);
                    }

                    // Method 2: rescueAndSellStuckTokens
                    showStatus('Method 2: Using rescue function...', 'info');
                    try {
                        const rescueTx = await CONTRACT.rescueAndSellStuckTokens([tokenAddress]);
                        console.log('⏳ Rescue transaction sent:', rescueTx.hash);

                        const rescueReceipt = await rescueTx.wait();
                        console.log('✅ Rescue confirmed:', rescueReceipt.transactionHash);

                        showStatus('✅ Tokens rescued and converted to ETH!', 'success');
                        await checkPlatformFees();
                        return;

                    } catch (rescueError) {
                        console.log('❌ rescueAndSellStuckTokens failed:', rescueError.message);
                    }

                    showStatus('❌ All rescue methods failed. Tokens may need manual intervention.', 'error');

                } catch (error) {
                    console.error('Comprehensive rescue error:', error);
                    showStatus('❌ Rescue failed: ' + error.message, 'error');
                }
            }

            // Check if token is in dev buy window (removed - function doesn't exist in deployed CONTRACT)
            async function checkDevBuyWindow(tokenAddress) {
                try {
                    // These functions are not available in the deployed CONTRACT
                    console.log('Anti-sniper functions not available in deployed CONTRACT');
                    return { inWindow: false, remainingTime: 0 };
                } catch (error) {
                    console.error('Dev buy window check error:', error.message);
                    return { inWindow: false, remainingTime: 0 };
                }
            }

            // Helper function to format small ETH amounts properly
            function formatSmallETHAmount(ethAmount) {
                const num = parseFloat(ethAmount);
                const usdAmount = num * currentETHPrice;

                let ethDisplay = "";
                if (num === 0) {
                    ethDisplay = "0.0000 ETH";
                } else if (num > 0 && num < 0.000001) {
                    ethDisplay = num.toExponential(6) + " ETH";
                } else if (num > 0 && num < 0.0001) {
                    ethDisplay = num.toFixed(12) + " ETH";
                } else {
                    ethDisplay = num.toFixed(6) + " ETH";
                }

                // Add USD amount
                if (num === 0) {
                    return ethDisplay + " ($0.00)";
                } else if (usdAmount < 0.01) {
                    return ethDisplay + " (<$0.01)";
                } else {
                    return ethDisplay + " ($" + usdAmount.toFixed(2) + ")";
                }
            }

            // Helper function to check claimable token amounts
            async function checkClaimableTokenAmounts() {
                if (!CONTRACT || !userAddress) return;

                try {
                    const tokenAmountsList = document.getElementById('tokenAmountsList');
                    const claimableSection = document.getElementById('claimableTokenAmounts');

                    if (!tokenAmountsList || !claimableSection) return;

                    // Get user's created tokens
                    const tokens = [];
                    let tokenIndex = 0;
                    let maxAttempts = 50;

                    while (tokenIndex < maxAttempts) {
                        try {
                            const tokenInfo = await CONTRACT.createdTokens(userAddress, tokenIndex);
                            if (tokenInfo[0] && tokenInfo[0] !== '0x0000000000000000000000000000000000000000') {
                                tokens.push({
                                    address: tokenInfo[0],
                                    name: tokenInfo[2] || 'Unknown Token',
                                    tokenId: tokenInfo[4]
                                });
                                tokenIndex++;
                            } else {
                                break;
                            }
                        } catch (e) {
                            break;
                        }
                    }

                    if (tokens.length === 0) {
                        claimableSection.style.display = 'none';
                        return;
                    }

                    // Check each token for claimable amounts
                    let hasClaimableTokens = false;
                    let tokenAmountsHTML = '';

                    for (const token of tokens) {
                        try {
                            // Try to simulate batchSwapTokenFees to see if there are claimable amounts
                            const canClaim = await CONTRACT.callStatic.batchSwapTokenFees(userAddress, token.address)
                                .then(() => true)
                                .catch(() => false);

                            if (canClaim) {
                                tokenAmountsHTML += `
                                <div style="margin-bottom: 4px; padding: 4px 8px; background: #e6fffa; border-radius: 4px; border: 1px solid #81e6d9;">
                                    <span style="font-weight: 600;">${token.name}</span>
                                    <span style="color: #2c7a7b; font-size: 0.65rem; margin-left: 4px;">• Has claimable tokens</span>
                                </div>
                            `;
                                hasClaimableTokens = true;
                            }
                        } catch (e) {
                            // Ignore errors for individual tokens
                        }
                    }

                    if (hasClaimableTokens) {
                        tokenAmountsList.innerHTML = tokenAmountsHTML;
                        claimableSection.style.display = 'block';
                    } else {
                        claimableSection.style.display = 'none';
                    }

                } catch (error) {
                    console.log('Error checking claimable token amounts:', error.message);
                    document.getElementById('claimableTokenAmounts').style.display = 'none';
                }
            }

            // Helper function to update all fee displays
            function updateAllFeeDisplays(creatorFeesETH, platformFeesETH, totalLifetimeETH = "0", userLifetimeETH = "0") {
                console.log("🔄 Updating all fee displays...");

                // Update creator fees main display with lifetime total in parentheses
                const creatorFeesElement = document.getElementById('creatorFees');
                if (creatorFeesElement) {
                    const formattedCreator = formatSmallETHAmount(creatorFeesETH);
                    const formattedLifetime = formatSmallETHAmount(userLifetimeETH);

                    // Show withdrawable + lifetime total
                    if (parseFloat(userLifetimeETH) > 0) {
                        creatorFeesElement.innerHTML = `${formattedCreator}<br><small style="color:#666;">Lifetime: ${formattedLifetime}</small>`;
                    } else {
                        creatorFeesElement.textContent = formattedCreator;
                    }
                    console.log("✅ Updated creatorFees:", formattedCreator, "| Lifetime:", formattedLifetime);
                }

                // Update withdrawable creator fees
                const withdrawableElement = document.getElementById('withdrawableCreatorFees');
                if (withdrawableElement) {
                    const formattedWithdrawable = formatSmallETHAmount(creatorFeesETH);
                    withdrawableElement.textContent = formattedWithdrawable; // Show full amount with USD
                    console.log("✅ Updated withdrawableCreatorFees:", formattedWithdrawable);
                }

                // Update Creator Dashboard card title - keep it simple
                const dashboardTitle = document.getElementById('creatorDashboardTitle');
                if (dashboardTitle) {
                    dashboardTitle.textContent = 'Creator Dashboard';
                }

                // Update platform fees with lifetime total
                const platformFeesElement = document.getElementById('platformFeesAmount');
                if (platformFeesElement) {
                    const formattedPlatform = formatSmallETHAmount(platformFeesETH);
                    const formattedTotalLifetime = formatSmallETHAmount(totalLifetimeETH);

                    // Show withdrawable + lifetime total for platform
                    if (parseFloat(totalLifetimeETH) > 0) {
                        const platformLifetime = (parseFloat(totalLifetimeETH) * 0.5).toFixed(12); // Platform gets 50%
                        const formattedPlatformLifetime = formatSmallETHAmount(platformLifetime.toString());
                        platformFeesElement.innerHTML = `${formattedPlatform}<br><small style="color:#666;">Lifetime: ${formattedPlatformLifetime}</small>`;
                    } else {
                        platformFeesElement.textContent = formattedPlatform;
                    }
                    console.log("✅ Updated platformFeesAmount:", formattedPlatform, "| Total lifetime:", formattedTotalLifetime);
                }

                // Check for claimable token amounts
                checkClaimableTokenAmounts().catch(e => console.log('Error checking tokens:', e.message));
            }



            // Function to withdraw all accumulated creator fees
            async function withdrawCreatorFees() {
                console.log('💰 Withdrawing all creator fees...');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    showStatus('Preparing ETH withdrawal...', 'info');

                    // First check how much the creator can withdraw
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log('💰 Creator fees to withdraw:', ethers.utils.formatEther(creatorFees), 'ETH');

                    if (creatorFees.eq(0)) {
                        showStatus('No ETH fees available for withdrawal', 'info');
                        return;
                    }

                    // Call the CONTRACT function to withdraw creator fees
                    const tx = await CONTRACT.withdrawCreatorFees();
                    console.log('⏳ Withdraw transaction sent:', tx.hash);
                    showStatus(`Processing withdrawal of ${ethers.utils.formatEther(creatorFees)} ETH...`, 'info');

                    const receipt = await tx.wait();
                    console.log('✅ Withdraw confirmed:', receipt.transactionHash);

                    // Parse the receipt for events
                    if (receipt.logs && receipt.logs.length > 0) {
                        console.log('📋 Withdrawal completed with', receipt.logs.length, 'events');

                        // Look for CreatorWithdraw event
                        const withdrawnAmount = ethers.utils.formatEther(creatorFees);
                        showStatus(`Successfully withdrew ${withdrawnAmount} ETH to your wallet!`, 'success');
                    } else {
                        showStatus('Withdrawal completed successfully!', 'success');
                    }

                    // Refresh fee displays after withdrawal
                    await checkPlatformFees();

                } catch (error) {
                    console.error('❌ Withdraw error:', error);
                    if (error.message.includes('insufficient')) {
                        showStatus('Insufficient balance to complete withdrawal', 'error');
                    } else if (error.message.includes('denied')) {
                        showStatus('Transaction cancelled by user', 'error');
                    } else if (error.message.includes('gas')) {
                        showStatus('Transaction failed due to network issues', 'error');
                    } else {
                        showStatus('Withdrawal failed: ' + error.message, 'error');
                    }
                }
            }

            async function checkPlatformFees() {
                console.log("🔄 checkPlatformFees() called");
                try {
                    if (!provider || !CONTRACT) {
                        console.error("❌ Provider or CONTRACT not available");
                        alert("Please connect your wallet first!");
                        return null;
                    }

                    console.log("📞 Calling CONTRACT functions...");
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalTokenCount = await CONTRACT.getTokenCount();

                    // Get all tokens by iterating through the allTokens array
                    const allTokens = [];
                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            allTokens.push(tokenInfo);
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break; // Stop if we hit an error
                        }
                    }
                    let totalLifetimeFees = ethers.BigNumber.from("0");
                    let userLifetimeFees = ethers.BigNumber.from("0");

                    if (allTokens && allTokens.length > 0) {
                        const currentUser = await signer.getAddress();

                        for (const token of allTokens) {
                            const tokenTotalFees = ethers.BigNumber.from(token.totalFeesETH || "0");
                            totalLifetimeFees = totalLifetimeFees.add(tokenTotalFees);

                            // If this user created this token, add to their lifetime total
                            if (token.creator && token.creator.toLowerCase() === currentUser.toLowerCase()) {
                                // Creator gets 50% of total fees (PLATFORM_SHARE = 50%)
                                const creatorPortion = tokenTotalFees.mul(50).div(100);
                                userLifetimeFees = userLifetimeFees.add(creatorPortion);
                            }
                        }
                    }

                    // Also get current withdrawable creator fees
                    let creatorFees;
                    try {
                        const userAddress = await signer.getAddress();
                        creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    } catch (e) {
                        console.log("⚠️ Could not get creator fees:", e.message);
                        creatorFees = ethers.utils.parseEther("0");
                    }

                    console.log("📊 Raw platform fees (withdrawable):", platformFees.toString());
                    console.log("📊 Raw creator fees (withdrawable):", creatorFees.toString());
                    console.log("📊 Total lifetime fees collected:", ethers.utils.formatEther(totalLifetimeFees));
                    console.log("📊 User lifetime fees earned:", ethers.utils.formatEther(userLifetimeFees));
                    console.log("📊 Token count:", totalTokenCount.toString());

                    // Format fees using ethers
                    const platformFeesFormatted = ethers.utils.formatEther(platformFees);
                    const creatorFeesFormatted = ethers.utils.formatEther(creatorFees);
                    const totalLifetimeFormatted = ethers.utils.formatEther(totalLifetimeFees);
                    const userLifetimeFormatted = ethers.utils.formatEther(userLifetimeFees);

                    console.log("� Formatted platform fees:", platformFeesFormatted);
                    console.log("📊 Formatted creator fees:", creatorFeesFormatted);

                    // Update all fee displays with proper formatting
                    updateAllFeeDisplays(creatorFeesFormatted, platformFeesFormatted, totalLifetimeFormatted, userLifetimeFormatted);

                    // Status messages
                    if (platformFees.eq(0) && creatorFees.eq(0)) {
                        if (totalLifetimeFees.gt(0)) {
                            console.log("✅ Lifetime fees were collected and withdrawn!");
                            console.log("   Total fees ever collected:", formatSmallETHAmount(totalLifetimeFormatted));
                            console.log("   Platform lifetime earnings:", formatSmallETHAmount((parseFloat(totalLifetimeFormatted) * 0.5).toFixed(12)));
                            console.log("   Your lifetime earnings:", formatSmallETHAmount(userLifetimeFormatted));
                            console.log("   Current withdrawable: 0 ETH (already withdrawn)");

                            // Remove distracting lifetime fee notifications
                            // showStatus(`✅ Lifetime fees collected: ${formatSmallETHAmount(totalLifetimeFormatted)} | Your share: ${formatSmallETHAmount(userLifetimeFormatted)}`, 'success');
                        } else {
                            console.log("💡 No fees collected yet. This means:");
                            console.log("   - No one has traded your tokens yet");
                            console.log("   - Or you need to call collectFees() first");
                            console.log("   - Try the 'Collect All Fees' button");
                            // showStatus('No fees collected yet - tokens may not have been traded or fees need collection', 'info');
                        }
                    } else {
                        console.log("✅ Fees available!");
                        console.log("   Platform fees:", formatSmallETHAmount(platformFeesFormatted));
                        console.log("   Creator fees:", formatSmallETHAmount(creatorFeesFormatted));
                        console.log("💡 Click withdraw buttons to claim them!");

                        // Remove distracting platform fee notifications
                        // if (parseFloat(platformFeesFormatted) > 0) {
                        //     showStatus(`✅ Platform fees ready for withdrawal: ${formatSmallETHAmount(platformFeesFormatted)}`, 'success');
                        // }
                    }

                    return {
                        platformFees: formatSmallETHAmount(platformFeesFormatted),
                        creatorFees: formatSmallETHAmount(creatorFeesFormatted),
                        tokenCount: totalTokenCount.toString()
                    };

                } catch (error) {
                    console.error("❌ Error checking platform fees:", error);
                    alert("Error checking fees: " + error.message);
                    return null;
                }
            }

            async function collectAllTokenFees() {
                console.log("🔄 collectAllTokenFees() called");
                try {
                    if (!signer) {
                        console.error("❌ No signer available");
                        alert("Please connect your wallet first!");
                        return;
                    }

                    console.log("� Starting fee collection process...");

                    // Use getUserTokens helper instead of getCreatedTokens to avoid ABI issues
                    const userAddress = await signer.getAddress();
                    console.log("👤 User address:", userAddress);

                    console.log("📞 Calling getUserTokens()...");
                    const userTokens = await getUserTokens(userAddress);

                    console.log("📊 Found", userTokens.length, "tokens created by you");

                    if (userTokens.length === 0) {
                        alert("No tokens found for your address");
                        return;
                    }

                    let successCount = 0;
                    let errorCount = 0;
                    let totalCollected = ethers.utils.parseEther("0");

                    for (let i = 0; i < userTokens.length; i++) {
                        try {
                            const tokenInfo = userTokens[i];
                            const tokenId = tokenInfo.tokenId;

                            console.log(`📊 Token ${i}: ${tokenInfo.name} (${tokenInfo.symbol})`);
                            console.log(`🎯 Attempting to collect fees for tokenId: ${tokenId.toString()}`);

                            // Check platform fees before collection
                            const platformFeesBefore = await CONTRACT.getPlatformFees();
                            console.log("💰 Platform fees before:", ethers.utils.formatEther(platformFeesBefore));

                            console.log("🚀 Calling CONTRACTWithSigner.collectFees()...");
                            const tx = await CONTRACTWithSigner.collectFees(tokenId);
                            console.log("✅ Transaction sent:", tx.hash);

                            console.log("⏳ Waiting for confirmation...");
                            const receipt = await tx.wait();
                            console.log("✅ Transaction confirmed in block:", receipt.blockNumber);

                            // Check platform fees after collection
                            const platformFeesAfter = await CONTRACT.getPlatformFees();
                            console.log("💰 Platform fees after:", ethers.utils.formatEther(platformFeesAfter));

                            const collected = platformFeesAfter.sub(platformFeesBefore);

                            if (collected.gt(0)) {
                                const collectedFormatted = ethers.utils.formatEther(collected);
                                console.log(`✅ Collected ${collectedFormatted} ETH in fees for token ${i}`);
                                totalCollected = totalCollected.add(collected);
                                successCount++;
                            } else {
                                console.log(`📭 No fees available for token ${i} yet`);
                            }

                        } catch (error) {
                            console.log(`⚠️ Could not collect fees for token ${i}:`, error.message);
                            errorCount++;

                            if (error.message.includes("No fees") || error.message.includes("amount is 0")) {
                                console.log("💡 No fees available for this token yet");
                            } else if (error.message.includes("execution reverted")) {
                                console.log("💡 Transaction reverted - likely no fees to collect");
                            }
                        }
                    }

                    // Show results
                    if (successCount > 0) {
                        const totalFormatted = ethers.utils.formatEther(totalCollected);
                        const message = `✅ Successfully collected ${totalFormatted} ETH in platform fees from ${successCount} token(s)!`;
                        console.log(message);
                        alert(message);
                    } else {
                        const message = `📭 No fees available to collect from ${userTokens.length} token(s). Either no trading has occurred yet or fees are below the minimum threshold.`;
                        console.log(message);
                        alert(message);
                    }

                    // Refresh the display
                    console.log("🔄 Refreshing platform fees display...");
                    await checkPlatformFees();

                } catch (error) {
                    console.error("❌ Error collecting fees:", error);
                    alert("Error collecting fees: " + error.message);
                }
            }

            async function withdrawPlatformFees() {
                try {
                    if (!signer) {
                        throw new Error("Please connect your wallet first");
                    }

                    console.log("Withdrawing platform fees...");
                    const tx = await CONTRACTWithSigner.withdrawPlatformFees();
                    await tx.wait();

                    console.log("✅ Platform fees withdrawn!");
                    alert("Platform fees withdrawn successfully!");

                    // Refresh the display
                    await checkPlatformFees();

                } catch (error) {
                    console.error("Error withdrawing platform fees:", error);
                    alert("Error withdrawing platform fees: " + error.message);
                }
            }

            // Enhanced loadUserTokens with anti-sniper status
            async function loadUserTokensEnhanced(loadMore = false) {
                const list = document.getElementById('myTokensList');
                if (!list) return;
                if (!userAddress) {
                    list.textContent = 'Connect wallet to load your tokens...';
                    return;
                }

                if (!loadMore) userTokensPage = 0;

                try {
                    if (!loadMore) list.textContent = 'Loading your tokens...';
                    console.log('[Dashboard] Loading user tokens with anti-sniper info for', userAddress, 'page', userTokensPage);
                    const allTokens = await getUserTokens(userAddress);
                    console.log('[Dashboard] Total tokens:', allTokens.length);

                    let fees = null;
                    if (capability.creatorFees) {
                        try {
                            console.log('💰 Fetching creator fees for:', userAddress);
                            fees = await CONTRACT.getCreatorFees(userAddress);
                            const feeAmount = ethers.utils.formatEther(fees);
                            console.log('💰 Creator fees found:', feeAmount, 'ETH');
                        } catch (e) {
                            if (!capability.suppressedCreatorFeeWarn) {
                                console.warn('[Dashboard] Disabling creator aggregate fee probe after revert.');
                                capability.suppressedCreatorFeeWarn = true;
                            }
                            capability.creatorFees = false;
                            fees = null;
                        }
                    }

                    // Check for accumulated token balances
                    let tokenBalance = null;
                    try {
                        tokenBalance = await CONTRACT.getCreatorTokenBalance(userAddress);
                    } catch (e) {
                        console.log('Could not check token balance:', e.message);
                    }

                    const wd = document.getElementById('withdrawableCreatorFees');
                    if (wd) wd.textContent = fees ? fmt(fees) : '0.000000';
                    const withdrawBtn = document.getElementById('withdrawMyFeesBtn');
                    if (withdrawBtn) withdrawBtn.disabled = !fees || fees.eq(0);
                    const collectBtn = document.getElementById('collectMyFeesBtn');
                    if (collectBtn) collectBtn.disabled = allTokens.length === 0;

                    if (allTokens.length === 0) {
                        list.textContent = 'You have not launched any tokens yet.';
                        return;
                    }

                    // Pagination logic
                    const startIdx = userTokensPage * TOKENS_PER_PAGE;
                    const endIdx = startIdx + TOKENS_PER_PAGE;
                    const tokens = allTokens.slice(startIdx, endIdx);
                    const hasMore = endIdx < allTokens.length;

                    // Generate table rows with anti-sniper status
                    let tableRows = '';
                    for (const t of tokens) {
                        let raw = undefined;
                        if (t.totalFeesETH !== undefined) raw = t.totalFeesETH;
                        if (!raw && Array.isArray(t)) {
                            if (t.length > 9) raw = t[9];
                            else if (t.length > 7) raw = t[7];
                        }
                        const feeETH = fees ? sanitizeFee(raw, fees) : '0.000000';
                        const feeETHNum = parseFloat(feeETH.replace(/ ETH.*$/, ''));
                        const feeUSD = feeETHNum * currentETHPrice;
                        const fee = feeETHNum.toFixed(6) + ' ETH ($' + feeUSD.toFixed(2) + ')';
                        const name = t.name || t[2];
                        const tokenId = t.tokenId || t[4];
                        const tokenAddress = t.tokenAddress || t[0];

                        // Check anti-sniper status
                        let antiSniperStatus = 'Checking...';
                        try {
                            const devStatus = await checkDevBuyWindow(tokenAddress);
                            if (devStatus.inWindow) {
                                const minutes = Math.floor(devStatus.remainingTime / 60);
                                const seconds = devStatus.remainingTime % 60;
                                antiSniperStatus = `<span style="color:orange;">🛡️ Dev Window: ${minutes}:${seconds.toString().padStart(2, '0')}</span>`;
                            } else {
                                antiSniperStatus = '<span style="color:green;">🌍 Public Trading</span>';
                            }
                        } catch {
                            antiSniperStatus = '<span style="color:gray;">❓ Unknown</span>';
                        }

                        // Check LP NFT status
                        let lpStatus = 'Checking...';
                        try {
                            const nfpm = new ethers.Contract(POSITION_MANAGER_ADDRESS, ["function ownerOf(uint256) view returns (address)"], provider);
                            const ownerAddr = await nfpm.ownerOf(tokenId);
                            const factoryAddr = TOKEN_FACTORY_ADDRESS.toLowerCase();

                            if (ownerAddr.toLowerCase() === factoryAddr) {
                                lpStatus = '<span style="color:green;">🔒 Locked</span>';
                            } else if (ownerAddr.toLowerCase() === userAddress.toLowerCase()) {
                                lpStatus = '<span style="color:red;">⚠️ In Wallet</span>';
                            } else {
                                lpStatus = '<span style="color:orange;">👤 Other</span>';
                            }
                        } catch {
                            lpStatus = '<span style="color:gray;">❓ Unknown</span>';
                        }

                        tableRows += `<tr><td>${name}</td><td><a href="https://basescan.org/token/${tokenAddress}" target="_blank" style="color:#667eea;text-decoration:none;">${tokenAddress.slice(0, 10)}...${tokenAddress.slice(-8)}</a></td><td style="text-align:right;font-weight:600;">${fee}</td><td style="text-align:center;">${antiSniperStatus}</td><td style="text-align:center;">${lpStatus}</td></tr>`;
                    }

                    if (!loadMore) {
                        // Initial load - create full table
                        let html = '<div class="table-container"><table>';
                        html += '<thead><tr><th>Name</th><th>Token Address</th><th>Fees (ETH)</th><th>Trading Status</th><th>LP Status</th></tr></thead>';
                        html += '<tbody>' + tableRows + '</tbody>';
                        html += '</table></div>';

                        // Add token balance info if any
                        if (tokenBalance && tokenBalance.gt(0)) {
                            html += `<div style="margin-top:12px;padding:8px;background:#e3f2fd;border-radius:6px;font-size:0.8rem;">
                            💰 Accumulated Token Fees: ${ethers.utils.formatEther(tokenBalance)} tokens
                            <button onclick="batchSwapTokens()" style="margin-left:8px;padding:2px 6px;font-size:0.7rem;background:#2196f3;color:white;border:none;border-radius:3px;cursor:pointer;">Swap to ETH</button>
                        </div>`;
                        }

                        if (hasMore) {
                            html += `<div style="display:flex;justify-content:center;margin-top:12px;"><button onclick="loadMoreUserTokens()" class="btn btn-secondary">Load More (${allTokens.length - endIdx} remaining)</button></div>`;
                        }

                        list.innerHTML = html;
                    } else {
                        // Load more - append rows to existing table
                        const tbody = list.querySelector('table tbody');
                        if (tbody) {
                            tbody.insertAdjacentHTML('beforeend', tableRows);
                        }

                        // Update load more button
                        const loadMoreBtn = list.querySelector('button');
                        if (loadMoreBtn) {
                            if (hasMore) {
                                loadMoreBtn.textContent = `Load More (${allTokens.length - endIdx} remaining)`;
                            } else {
                                loadMoreBtn.remove();
                            }
                        }
                    }

                    if (!loadMore) {
                        userTokensPage = 1; // Set to 1 after first load
                    } else {
                        userTokensPage++; // Increment only for load more
                    }
                } catch (err) {
                    list.textContent = 'Failed to load';
                    console.error(err);
                }
            }

            // Override the original loadUserTokens with the enhanced version
            loadUserTokens = loadUserTokensEnhanced;
        </script>


        <!--======= HERO SECTION ===========
        ====================================
        =================================-->

        <section class="utility-hero">
            <div class="utility-hero__bg" aria-hidden="true"></div>
            <div class="utility-hero-content">
              <h1>BASE TOKEN LAUNCHER</h1>
              <p>Create ERC20 tokens with locked liquidity</p>
            </div>
          </section>


        <!-- JavaScript for Parallax effect-->

        <script>
            (function () {
                const bg = document.querySelector('.utility-hero__bg');
                if (!bg) return;

                const speed = 0.6; // lower = subtler effect
                const reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

                if (reduce) return; // skip for reduced motion users

                let ticking = false;

                function onScroll() {
                    if (!ticking) {
                        requestAnimationFrame(() => {
                            const y = window.scrollY * speed;
                            bg.style.transform = `translateY(${y}px)`;
                            ticking = false;
                        });
                        ticking = true;
                    }
                }

                window.addEventListener('scroll', onScroll, { passive: true });
                onScroll();
            })();
        </script>


        <div class="page-wrapper">
            <div id="riskBanner"
                style="display:none;margin:0 0 18px 0;padding:12px 18px;border-radius:10px;font-size:0.75rem;font-weight:600;line-height:1.35;background:linear-gradient(135deg,#7b1f21,#b11b1e);color:#fff;border:1px solid #ffcccc;box-shadow:0 2px 6px -1px rgba(0,0,0,0.25);">
                <span id="riskBannerText">Legacy factory detected – LP NFT may reside in creator wallet. Redeploy secure
                    factory or update address.</span>
            </div>
            <div class="container">
                <!--
                <div class="header">
                    <h1>BASE TOKEN LAUNCHER</h1>
                    <p style="text-align: center;">Create ERC20 tokens with locked liquidity</p>
                </div>
                -->

                <div class="main-content">
                    <!-- Connection Status -->
                    <div class="card">
                        <div class="card-title">Wallet Connection</div>
                        <div id="connectionStatus" class="status status-info">
                            Click "Connect Wallet" to get started!
                        </div>
                        <div class="btn-group btn-group-2">
                            <button id="connectBtn" class="btn btn-primary">Connect Wallet</button>
                            <button id="switchNetworkBtn" class="btn btn-secondary" style="display: none;">Switch to
                                BASE</button>
                            <!-- Removed manual price update button; price updates automatically every 5 minutes -->
                        </div>
                        <div id="priceStatus"
                            style="margin-top: 12px; font-size: 0.9rem; color: var(--violet-muted); display: none;">
                            Current ETH Price: $<span id="currentPrice">4400.00</span>
                        </div>
                        <div id="factoryMode" style="margin-top:8px;font-size:0.75rem;color:#555;display:none;">Mode: —
                        </div>
                        <div id="lpVaultStatus" style="margin-top:4px;font-size:0.7rem;color:#666;display:none;">LP
                            Vault: —</div>
                    </div>


                    <div class="grid-2" id="mainContent" style="display: none;">

                        <!-- Token Creation Form -->
                        <div class="card" id="tokenCreationCard">
                            <div class="card-title">Create New Token</div>
                            <form id="tokenForm">
                                <div class="form-group">
                                    <label class="form-label" for="tokenName">Token Name</label>
                                    <input type="text" id="tokenName" class="form-input"
                                        placeholder="e.g., My Awesome Token" maxlength="32" required>
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="tokenSymbol">Token Symbol</label>
                                    <input type="text" id="tokenSymbol" class="form-input" placeholder="e.g., MAT"
                                        maxlength="10" required>
                                </div>
                                <div class="form-group">
                                    <div class="balance-display">
                                        <div class="balance-label">Available Balance</div>
                                        <div class="balance-amount" id="walletBalance">0.0000 ETH ($0.00)</div>
                                    </div>
                                </div>
                                <div class="btn-group btn-group-full" style="display:flex;justify-content:center;">
                                    <button type="submit" class="btn btn-primary" id="createTokenBtn">Create Token &
                                        LP</button>
                                </div>
                            </form>
                        </div>

                        <!-- Fee Management -->
                        <div class="card" id="feeManagementCard">
                            <div class="card-title">Fee Management</div>
                            <div class="balance-display">
                                <div class="balance-amount" id="creatorFees">0.0000 ETH ($0.00)</div>
                                <div class="balance-label">Your Withdrawable Creator Fees</div>
                            </div>

                            <!-- Platform Fees Dashboard -->
                            <div class="balance-display" style="margin-top: 15px;">
                                <div class="balance-amount" id="platformFeesAmount">Loading...</div>
                                <div class="balance-label">Platform Fees Available</div>
                            </div>
                            <div class="btn-group btn-group-3" id="platform-fees" style="margin-top: 10px;">
                                <button onclick="console.log('Refresh button clicked!'); checkPlatformFees()"
                                    class="btn btn-secondary">Refresh Fees</button>
                                <button onclick="console.log('Collect button clicked!'); collectAllTokenFees()"
                                    class="btn btn-secondary">🔄 Collect LP Fees → Creator Dashboard</button>
                                <button onclick="console.log('Withdraw button clicked!'); withdrawPlatformFees()"
                                    class="btn btn-primary">Withdraw Platform Fees</button>
                            </div>
                            <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                                <p style="text-align: center;">Very small fees are shown in scientific notation (e.g.,
                                    5.000000e-8 ETH (<$0.01))< /p>
                            </div>

                            <div class="btn-group btn-group-2">
                                <button id="collectFeesBtn" class="btn btn-secondary">Claim Token Fees and Gather
                                    ETH</button>
                                <button id="withdrawFeesBtn" class="btn btn-primary">Withdraw Available ETH</button>
                            </div>
                            <div class="btn-group btn-group-2" style="margin-top: 8px;">
                                <button id="scanAllFeesBtn" class="btn btn-outline"
                                    onclick="scanAndCollectAllAvailableFees(false)">Scan All Fees</button>
                                <button id="scanAndCollectBtn" class="btn btn-secondary"
                                    onclick="scanAndCollectAllAvailableFees(true)">Scan & Collect</button>
                            </div>
                            <div class="btn-group btn-group-1" style="margin-top: 8px;">
                                <button id="refreshTokenCardsBtn" class="btn btn-outline"
                                    onclick="refreshAllTokenCardFees()"
                                    title="Refresh all token card fee displays with updated format">🔄 Refresh Token
                                    Card Fees</button>
                            </div>
                        </div>
                    </div>

                    <!-- Token Management Section -->
                    <div class="grid-2" id="tokenManagementSection" style="margin-top: 32px; display: none;">
                        <!-- User Tokens Dashboard -->
                        <div class="card" id="myTokensCard">
                            <div class="card-title" id="creatorDashboardTitle">Creator Dashboard</div>
                            <div class="card-content">
                                <div id="myTokensList" style="font-size:0.75rem;">Connect wallet to load your tokens...
                                </div>
                            </div>

                            <!-- Clean Fee Display Section -->
                            <div style="margin-top: 20px; 
                           background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
                           border: 2px solid rgba(102, 126, 234, 0.3);
                           border-radius: 16px;
                           padding: 24px;
                           text-align: center;
                           box-shadow: 0 4px 20px rgba(0,0,0,0.2);">

                                <!-- Header -->
                                <div style="margin-bottom: 20px;">
                                    <div
                                        style="color: #6c8cff; font-weight: 700; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 0.5px;">
                                        💰 Available to Claim
                                    </div>
                                </div>

                                <!-- ETH Fees Section -->
                                <div style="background: rgba(72, 187, 120, 0.15);
                               border: 1px solid rgba(72, 187, 120, 0.3);
                               border-radius: 12px;
                               padding: 20px;
                               margin-bottom: 16px;">

                                    <div
                                        style="color: #48bb78; font-weight: 600; font-size: 0.9rem; margin-bottom: 8px;">
                                        ETH Fees
                                    </div>
                                    <div
                                        style="font-size: 1.8rem; font-weight: 800; color: #ffffff; margin-bottom: 4px;">
                                        <span id="withdrawableCreatorFees">0.000000 ETH ($0.00)</span>
                                    </div>
                                </div>

                                <!-- Token Amounts Section -->
                                <div id="claimableTokenAmounts" style="display:none;">
                                    <div style="background: rgba(102, 126, 234, 0.15);
                                   border: 1px solid rgba(102, 126, 234, 0.3);
                                   border-radius: 12px;
                                   padding: 16px;
                                   margin-bottom: 16px;">

                                        <div
                                            style="color: #667eea; font-weight: 600; font-size: 0.9rem; margin-bottom: 8px;">
                                            Claimable Tokens
                                        </div>
                                        <div id="tokenAmountsList" style="font-size: 0.8rem; color: #e2e8f0;">
                                            <!-- Token amounts will be populated here -->
                                        </div>
                                    </div>
                                </div>

                                <!-- Instructions -->
                                <div style="color: #a0aec0;
                               font-size: 0.8rem;
                               font-style: italic;
                               padding: 12px;
                               background: rgba(160, 174, 192, 0.1);
                               border-radius: 8px;
                               border: 1px solid rgba(160, 174, 192, 0.2);
                               margin-bottom: 20px;">
                                    <strong style="color: #e2e8f0;">How it works:</strong><br>
                                    1️⃣ <strong>"Claim Token Fees"</strong> - Sends TOKEN rewards directly to your
                                    wallet + prepares ETH for withdrawal<br>
                                    2️⃣ <strong>"Withdraw ETH"</strong> - Claims the prepared ETH rewards to your wallet
                                </div>

                                <!-- Action Buttons -->
                                <div class="btn-group btn-group-2">
                                    <button onclick="transferTokensToCreator();" class="btn btn-secondary">Claim Token
                                        Fees</button>
                                    <button onclick="withdrawCreatorFees();" class="btn btn-primary">Withdraw
                                        ETH</button>
                                </div>
                            </div>
                        </div>

                        <!-- Admin Dashboard -->
                        <div class="card" id="adminCard" style="display:none;">
                            <div class="card-title">Admin Dashboard</div>
                            <div class="card-content">
                                <!-- Search Bar -->
                                <div style="margin-bottom: 12px;">
                                    <input type="text" id="adminTokenSearch"
                                        placeholder="Search by token name, symbol, or address..."
                                        style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.9rem;"
                                        onkeyup="handleAdminSearch()">
                                </div>
                                <div id="allTokensList" style="font-size:0.75rem;">—</div>
                            </div>
                            <div class="btn-group btn-group-2" style="margin-top:14px;">
                                <button id="collectAllFeesBtn" class="btn btn-secondary" disabled>Claim Token Fees and
                                    Gather ETH</button>
                                <button id="withdrawPlatformBtn" class="btn btn-primary" disabled>Withdraw Available
                                    ETH</button>
                            </div>
                            <div class="btn-group btn-group-2" style="margin-top:8px;">
                                <button onclick="collectAllPlatformFees();" class="btn"
                                    style="background: linear-gradient(135deg, #0070f3, #0051cc, #003d99); background-size: 300% 300%;">Collect
                                    ALL Fees</button>
                                <button id="rescueEthBtn" class="btn"
                                    style="background: linear-gradient(135deg, #1e40af, #1e3a8a, #1d4ed8); background-size: 300% 300%;"
                                    disabled>Rescue Trapped ETH</button>
                            </div>
                            <div class="btn-group btn-group-full" style="margin-top:8px;">
                                <button onclick="adminCheckBalance();" class="btn"
                                    style="background: linear-gradient(135deg, #0070f3, #0051cc, #003d99); background-size: 300% 300%;">CONTRACT
                                    ETH BALANCE INFO</button>
                            </div>
                            <div id="balanceCheckResult"
                                style="display:none; margin-top:12px; padding:12px; border-radius:8px; font-size:0.8rem;">
                            </div>
                            <div style="font-size:0.7rem;margin-top:10px;color:#4a5568">
                                <div>Platform Withdrawable: <span id="platformFeesValue">0.000000 ETH ($0.00)</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Status Messages -->
                    <div id="statusContainer"
                        style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 9999; max-width: 400px; width: 90%;">
                    </div>

                    <!-- Success Details -->
                    <div id="successDetails" style="display: none;"></div>

                    <!-- Uniswap Widget Modal -->
                    <div id="uniswapModal"
                        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center;">
                        <div
                            style="background: white; border-radius: 16px; padding: 24px; max-width: 600px; width: 90%; max-height: 90%; overflow-y: auto; position: relative;">
                            <button id="closeUniswapModal"
                                style="position: absolute; top: 12px; right: 12px; background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">&times;</button>

                            <h3 style="margin: 0 0 16px 0; color: #1a202c; text-align: center;">Token Created
                                Successfully!</h3>

                            <div
                                style="background: linear-gradient(135deg, #fff3cd, #ffeaa7); border: 2px solid #f0ad4e; border-radius: 12px; padding: 18px; margin-bottom: 20px; box-shadow: 0 4px 12px rgba(240, 173, 78, 0.3);">
                                <p
                                    style="margin: 0 0 12px 0; font-weight: 700; color: #d44a11; font-size: 1.2rem; text-align: center;">
                                    ⏰ 5-Minute Exclusive Window!</p>
                                <div id="countdownTimer"
                                    style="text-align: center; font-size: 1.8rem; font-weight: 700; color: #d44a11; margin-bottom: 12px; animation: pulse 2s infinite;">
                                    Loading...
                                </div>
                                <p
                                    style="margin: 0; font-size: 0.95rem; color: #8b4513; text-align: center; line-height: 1.4;">
                                    You have this exclusive window to make your initial buy before public trading
                                    becomes activated.
                                    <strong>Secure your position first!</strong>
                                </p>
                            </div>

                            <div id="tokenDetailsContainer"
                                style="background: #f8fafc; border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                                <!-- Token details will be populated here -->
                            </div>

                            <div id="uniswapWidgetContainer" style="margin: 20px 0;"></div>

                            <div style="display: flex; gap: 12px; margin-top: 20px; flex-wrap: wrap;">
                                <button id="skipBuyBtn" class="btn btn-secondary"
                                    style="flex: 1; min-width: 140px;">Skip - Share Token</button>
                                <button id="makeInitialBuyBtn" class="btn btn-primary"
                                    style="flex: 1; min-width: 140px;">Make Initial Buy</button>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- End main-content -->

            </div>
            <!-- End container -->
        </div>
        <!-- End page wrapper -->

        <!--========== FOOTER ==============
        ====================================
        =================================-->

        <div class="footer-section">
            <p class="wild-west-footer">WILDWEST LAUNCHPAD</p>
            <div class="footer-socials">
                <a href="https://t.me/wildwestlaunchpad" target="_blank" rel="noopener">
                    <img src="../images/icons/icons8-telegram-app-240_WHITE.png" alt="Telegram" class="nav-icon">
                </a>
                <a href="https://x.com/WILDWESTLP?t=wmcDfvCKnkAaLCtJbmAxgA" target="_blank" rel="noopener">
                    <img src="../images/icons/icons8-twitterx-240_WHITE.png" alt="Twitter/X" class="nav-icon">
                </a>
                <a href="https://dexscreener.com/base/0x8129609e5303910464fce3022a809fa44455fe9a" target="_blank"
                    rel="noopener">
                    <img src="../images/icons/661375b92a7e161501f4b5e5_dexscreener.322a5a2d_WHITE.png" alt="DEXScreener"
                        class="nav-icon">
                </a>
            </div>
            <p class="footer-wildw">$WILDW TOKEN (BASE)</p>
            <span class="footer-address" id="contract-address">0x8129609E5303910464FCe3022a809fA44455Fe9A</span>



            <p class="footer-url">&copy; 2025 Wild West Launchpad. All rights reserved.</p>
        </div>
    </div>
    </footer>

    <!--Click to copy JS-->
  <script>
    const addressSpan = document.getElementById("contract-address");

    addressSpan.addEventListener("click", (e) => {
      const text = addressSpan.textContent.trim();

      navigator.clipboard.writeText(text).then(() => {
        const tooltip = document.createElement("div");
        tooltip.className = "copy-tooltip";
        tooltip.textContent = "Copied!";

        // Use viewport coords for fixed elements
        let x = e.clientX + 10;   // small offset to the right
        let y = e.clientY - 10;   // small offset above

        // Clamp so it stays inside the viewport
        const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        x = Math.min(Math.max(10, x), vw - 10);
        y = Math.min(Math.max(10, y), vh - 10);

        tooltip.style.left = x + "px";
        tooltip.style.top = y + "px";

        document.body.appendChild(tooltip);

        // Show then fade away
        requestAnimationFrame(() => tooltip.classList.add("show"));
        setTimeout(() => {
          tooltip.classList.remove("show");
          setTimeout(() => tooltip.remove(), 300); // match CSS transition
        }, 1200);
      });
    });
  </script>


    <script>
        // CONTRACT Configuration
        const TOKEN_FACTORY_ADDRESS = "0xaB4FE16F395921081bD9895359cf173a2Eaa7125"; // SALT-BASED: Ensures all tokens have address > WETH for 100% LP success
        const BASE_CHAIN_ID = 8453;
        const BASE_RPC_URL = "https://mainnet.base.org";
        const EXPLORER_URL = "https://basescan.org";
        const POSITION_MANAGER_ADDRESS = "0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1"; // Uniswap V3 NonfungiblePositionManager (matches CONTRACT)

        // QuickNode endpoint for ETH price
        const QUICKNODE_ENDPOINT = "https://responsive-omniscient-model.base-mainnet.quiknode.pro/aa86b92100862c55985ff1d322a9ff07d9ab236f/";

        // Fallback ETH price in case QuickNode fails
        const FALLBACK_ETH_PRICE = 4400; // $4400 per ETH

        // AllTokensToLPFactoryFixed ABI (enhanced with anti-sniper and automatic token fee conversion)
        const TOKEN_FACTORY_ABI = [
            {
                "inputs": [],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "totalTokens",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "finalBalance",
                        "type": "uint256"
                    }
                ],
                "name": "AllTokensDeposited",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "creator",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "ethAmount",
                        "type": "uint256"
                    }
                ],
                "name": "CreatorWithdraw",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "creator",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    }
                ],
                "name": "ExcessFundsSent",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "ethAmount",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "tokenAmount",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "swappedETH",
                        "type": "uint256"
                    }
                ],
                "name": "FeesCollected",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "ethAmount",
                        "type": "uint256"
                    }
                ],
                "name": "PlatformWithdraw",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "creator",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "name",
                        "type": "string"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "symbol",
                        "type": "string"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "address",
                        "name": "pool",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "int24",
                        "name": "tickLower",
                        "type": "int24"
                    },
                    {
                        "indexed": false,
                        "internalType": "int24",
                        "name": "tickUpper",
                        "type": "int24"
                    }
                ],
                "name": "TokenCreated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "creator",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "TokenFeesWithdrawn",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "creator",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "TokensDirectToCreator",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "allTokens",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "creator",
                        "type": "address"
                    },
                    {
                        "internalType": "string",
                        "name": "name",
                        "type": "string"
                    },
                    {
                        "internalType": "string",
                        "name": "symbol",
                        "type": "string"
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "createdAt",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "pool",
                        "type": "address"
                    },
                    {
                        "internalType": "int24",
                        "name": "tickLower",
                        "type": "int24"
                    },
                    {
                        "internalType": "int24",
                        "name": "tickUpper",
                        "type": "int24"
                    },
                    {
                        "internalType": "uint256",
                        "name": "totalFeesETH",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "creator",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    }
                ],
                "name": "batchSwapTokenFees",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "collectAllTokens",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "collectFees",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "string",
                        "name": "name",
                        "type": "string"
                    },
                    {
                        "internalType": "string",
                        "name": "symbol",
                        "type": "string"
                    }
                ],
                "name": "createToken",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "createdTokens",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "creator",
                        "type": "address"
                    },
                    {
                        "internalType": "string",
                        "name": "name",
                        "type": "string"
                    },
                    {
                        "internalType": "string",
                        "name": "symbol",
                        "type": "string"
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "createdAt",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "pool",
                        "type": "address"
                    },
                    {
                        "internalType": "int24",
                        "name": "tickLower",
                        "type": "int24"
                    },
                    {
                        "internalType": "int24",
                        "name": "tickUpper",
                        "type": "int24"
                    },
                    {
                        "internalType": "uint256",
                        "name": "totalFeesETH",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "creatorFeesETH",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "creatorTokenBalances",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "creator",
                        "type": "address"
                    }
                ],
                "name": "getCreatorFees",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "creator",
                        "type": "address"
                    }
                ],
                "name": "getCreatorTokenBalance",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getPlatformFees",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getTokenCount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "platformAdmin",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "platformFeesETH",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address[]",
                        "name": "tokenAddresses",
                        "type": "address[]"
                    }
                ],
                "name": "rescueAndSellStuckTokens",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "tokenCreators",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "withdrawCreatorFees",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "withdrawPlatformFees",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "stateMutability": "payable",
                "type": "receive"
            }
        ];

        // Global variables
        let provider;
        let signer;
        let CONTRACT;
        let userAddress;
        let currentETHPrice = FALLBACK_ETH_PRICE;
        let isAllInclusiveFactory = false; // true only if creation fee probe succeeds

        // Pagination variables
        let userTokensPage = 0;
        let adminTokensPage = 0;
        const TOKENS_PER_PAGE = 10;
        const ADMIN_TOKENS_PER_PAGE = 5; // Show fewer tokens for admin panel

        // Store all tokens for search functionality
        let allAdminTokens = [];
        let filteredAdminTokens = [];

        const capability = {
            creationFee: false,
            gasReserve: false,
            creatorFees: false,
            probed: false,
            suppressedCreatorFeeWarn: false,
            downgraded: false
        };

        // ETH Price fetching functions
        async function fetchETHPriceFromQuickNode() {
            try {
                // Use the hardcoded QuickNode endpoint
                const response = await fetch(QUICKNODE_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'eth_call',
                        params: [
                            {
                                to: '0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70', // Base ETH/USD price feed (example)
                                data: '0x50d25bcd' // latestAnswer() function selector
                            },
                            'latest'
                        ]
                    })
                });

                const data = await response.json();
                if (data.result && data.result !== '0x') {
                    // Convert hex result to price (adjust decimals based on the oracle)
                    const priceHex = data.result;
                    const price = parseInt(priceHex, 16) / 100000000; // Chainlink typically uses 8 decimals

                    if (price > 1000 && price < 10000) { // Sanity check for reasonable ETH price
                        console.log('ETH price from QuickNode:', price);
                        return price;
                    }
                }

                throw new Error('Invalid price data from QuickNode');

            } catch (error) {
                console.warn('Failed to fetch ETH price from QuickNode:', error);
                return null;
            }
        }

        async function fetchETHPriceFromAPI() {
            try {
                // Fallback to public API
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
                const data = await response.json();

                if (data.ethereum && data.ethereum.usd) {
                    console.log('ETH price from CoinGecko:', data.ethereum.usd);
                    return data.ethereum.usd;
                }

                throw new Error('Invalid price data from API');

            } catch (error) {
                console.warn('Failed to fetch ETH price from API:', error);
                return FALLBACK_ETH_PRICE;
            }
        }

        async function updateETHPrice() {
            try {
                let ethPrice = await fetchETHPriceFromQuickNode();
                if (!ethPrice) ethPrice = await fetchETHPriceFromAPI();
                currentETHPrice = ethPrice;
                const priceEl = document.getElementById('currentPrice');
                if (priceEl) priceEl.textContent = ethPrice.toFixed(2);
                // Launch cost display removed - not needed for tiny amounts
                // On-chain price sync intentionally disabled (automatic local display only)
                return ethPrice;
            } catch (error) {
                console.error('ETH price update failed:', error);
                return FALLBACK_ETH_PRICE;
            }
        }

        function calculateCreationFeeETH(ethPriceUSD) {
            // $0.99 / ETH price = ETH amount needed
            return (0.99 / ethPriceUSD).toFixed(8);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async function () {
            initializeEventListeners();

            // Update ETH price on load
            await updateETHPrice();

            if (typeof window.ethereum !== 'undefined') {
                await checkConnection();
            } else {
                // Mobile-aware wallet messaging
                showStatus(getMobileAwareWalletMessage(), 'error');
            }

            // Update ETH price every 5 minutes
            setInterval(updateETHPrice, 5 * 60 * 1000);
        });

        function initializeEventListeners() {
            // Use our new wallet modal system instead of old connectWallet
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) {
                connectBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🔗 Base Launch: Connect button clicked - smart handler');
                    handleConnectButtonClick();
                });
            }
            document.getElementById('switchNetworkBtn').addEventListener('click', switchToBase);
            document.getElementById('tokenForm').addEventListener('submit', handleCreateToken);
            document.getElementById('collectFeesBtn').addEventListener('click', collectAllFees);
            document.getElementById('withdrawFeesBtn').addEventListener('click', withdrawFees);
            // Removed updatePriceBtn listener (button deleted)
            const cmf = document.getElementById('collectMyFeesBtn');
            if (cmf) cmf.addEventListener('click', handleCollectMyFees);
            const wmf = document.getElementById('withdrawMyFeesBtn');
            if (wmf) wmf.addEventListener('click', handleWithdrawMyFees);
            const caf = document.getElementById('collectAllFeesBtn');
            if (caf) caf.addEventListener('click', handleAdminCollectAllFees);
            const wpf = document.getElementById('withdrawPlatformBtn');
            if (wpf) wpf.addEventListener('click', handleWithdrawPlatformFees);
            const rescueBtn = document.getElementById('rescueEthBtn');
            if (rescueBtn) rescueBtn.addEventListener('click', handleRescueTrappedEth);
            const symInput = document.getElementById('tokenSymbol');
            if (symInput) symInput.addEventListener('input', () => { symInput.value = symInput.value.toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 10); });
        }

        async function isAdmin(addr) {
            try { const a = await CONTRACT.platformAdmin(); return a.toLowerCase() === addr.toLowerCase(); } catch { return false; }
        }

        function fmt(v) {
            try {
                return formatSmallETHAmount(ethers.utils.formatEther(v));
            } catch (e) {
                return '0.000000 ETH ($0.00)';
            }
        }
        function sanitizeFee(rawBN, aggregateBN) {
            try {
                if (!rawBN) return '0.000000';
                // If raw > 100 ETH before any realistic accrual, likely struct mismatch -> treat as zero
                if (rawBN.gt(ethers.utils.parseEther('100'))) return '0.000000';
                // Always show the actual per-token fees regardless of aggregate status
                return fmt(rawBN);
            } catch { return '0.000000'; }
        }

        async function refreshDashboards() {
            if (!CONTRACT || !userAddress) return;

            // Start automatic fee scanning on first dashboard load (only once)
            if (typeof startAutomaticFeeScanning === 'function' && !feesScanInterval) {
                startAutomaticFeeScanning();
            }

            await Promise.all([loadUserTokens(), loadAdminTokens()]);
            await checkPlatformFees(); // Check platform fees on load
        }

        async function loadUserTokens(loadMore = false) {
            const list = document.getElementById('myTokensList');
            if (!list) return;
            if (!userAddress) { list.textContent = 'Connect wallet to load your tokens...'; return; }

            if (!loadMore) userTokensPage = 0;

            try {
                if (!loadMore) list.textContent = 'Loading your tokens...';
                console.log('[Dashboard] Loading user tokens for', userAddress, 'page', userTokensPage);

                // Use createdTokens mapping to get tokens created by this user
                // Since we don't have getCreatedTokens function, we need to iterate through createdTokens mapping
                const allTokens = [];
                let tokenIndex = 0;
                let maxAttempts = 100; // Prevent infinite loops

                try {
                    while (tokenIndex < maxAttempts) {
                        try {
                            const tokenInfo = await CONTRACT.createdTokens(userAddress, tokenIndex);
                            // Check if we got a valid token (tokenAddress != 0x0)
                            if (tokenInfo[0] && tokenInfo[0] !== '0x0000000000000000000000000000000000000000') {
                                allTokens.push(tokenInfo);
                                tokenIndex++;
                            } else {
                                break; // No more tokens
                            }
                        } catch (e) {
                            break; // No more tokens or error occurred
                        }
                    }
                } catch (err) {
                    console.log('Error loading user tokens:', err.message);
                }

                console.log('[Dashboard] Total tokens:', allTokens.length);

                let fees = null;
                if (capability.creatorFees) {
                    try {
                        console.log('💰 Fetching creator fees for:', userAddress);
                        fees = await CONTRACT.getCreatorFees(userAddress);
                        const feeAmount = ethers.utils.formatEther(fees);
                        console.log('💰 Creator fees found:', feeAmount, 'ETH');

                        if (parseFloat(feeAmount) > 0) {
                            console.log('🎉 Fees detected! Amount:', feeAmount, 'ETH');
                        } else {
                            console.log('📭 No fees yet. This could mean:');
                            console.log('- Tokens haven\'t had enough trading volume');
                            console.log('- Trading hasn\'t reached fee threshold');
                            console.log('- Fees are still processing');
                        }
                    } catch (e) {
                        if (!capability.suppressedCreatorFeeWarn) {
                            console.warn('[Dashboard] Disabling creator aggregate fee probe after revert.');
                            capability.suppressedCreatorFeeWarn = true;
                        }
                        capability.creatorFees = false;
                        fees = null;
                    }
                }

                const wd = document.getElementById('withdrawableCreatorFees');
                if (wd) wd.textContent = fees ? fmt(fees) : '0.000000 ETH ($0.00)';
                const withdrawBtn = document.getElementById('withdrawMyFeesBtn');
                if (withdrawBtn) withdrawBtn.disabled = !fees || fees.eq(0);
                const collectBtn = document.getElementById('collectMyFeesBtn');
                if (collectBtn) collectBtn.disabled = allTokens.length === 0;

                if (allTokens.length === 0) {
                    list.textContent = 'You have not launched any tokens yet.';
                    return;
                }

                // Pagination logic
                const startIdx = userTokensPage * TOKENS_PER_PAGE;
                const endIdx = startIdx + TOKENS_PER_PAGE;
                const tokens = allTokens.slice(startIdx, endIdx);
                const hasMore = endIdx < allTokens.length;

                // Generate token cards instead of table rows
                let tokenCards = '';
                for (const t of tokens) {
                    const name = t[2] || 'Unknown Token';
                    const tokenAddress = t[0];
                    let symbol = 'UNKNOWN';

                    // Get the actual symbol from the token contract
                    try {
                        const tokenContract = new ethers.Contract(tokenAddress, ["function symbol() view returns (string)"], provider);
                        symbol = await tokenContract.symbol();
                    } catch (err) {
                        console.log('Could not get symbol for token:', tokenAddress);
                        symbol = t[1] || 'UNKNOWN'; // Fallback to stored data
                    }

                    const tokenId = t[4];

                    // Check LP NFT status
                    let lpStatus = 'Checking...';
                    let lpStatusColor = 'gray';
                    try {
                        const nfpm = new ethers.Contract(POSITION_MANAGER_ADDRESS, ["function ownerOf(uint256) view returns (address)"], provider);
                        const ownerAddr = await nfpm.ownerOf(tokenId);
                        const factoryAddr = TOKEN_FACTORY_ADDRESS.toLowerCase();
                        const creatorAddr = userAddress.toLowerCase();

                        if (ownerAddr.toLowerCase() === factoryAddr) {
                            lpStatus = 'Locked';
                            lpStatusColor = 'green';
                        } else if (ownerAddr.toLowerCase() === creatorAddr) {
                            lpStatus = 'In Wallet';
                            lpStatusColor = 'red';
                        } else {
                            lpStatus = 'External';
                            lpStatusColor = 'orange';
                        }
                    } catch {
                        lpStatus = 'Unknown';
                        lpStatusColor = 'gray';
                    }

                    tokenCards += `
                        <div class="token-card" style="background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); 
                                   border: 2px solid #e2e8f0; 
                                   border-radius: 20px; 
                                   padding: 28px; 
                                   margin-bottom: 24px; 
                                   box-shadow: 0 8px 25px rgba(0,0,0,0.08), 0 4px 8px rgba(0,0,0,0.12);
                                   cursor: pointer;
                                   position: relative;
                                   overflow: hidden;
                                   transition: all 0.3s ease;
                                   border-image: linear-gradient(135deg, #667eea, #764ba2, #f093fb) 1;"
                            onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 12px 40px rgba(0,0,0,0.15), 0 6px 12px rgba(0,0,0,0.18)'"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 8px 25px rgba(0,0,0,0.08), 0 4px 8px rgba(0,0,0,0.12)'">
                            
                            <!-- Decorative gradient border -->
                            <div style="position: absolute; top: 0; left: 0; right: 0; height: 4px; 
                                        background: linear-gradient(90deg, #667eea, #764ba2, #f093fb); 
                                        border-radius: 20px 20px 0 0;"></div>
                            
                            <!-- Header with token name and status -->
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                                <div>
                                    <div style="font-weight: 800; font-size: 1.35rem; color: #1a202c; margin-bottom: 6px; letter-spacing: -0.025em; text-shadow: 0 1px 2px rgba(0,0,0,0.1);">${name}</div>
                                    <div style="font-size: 0.85rem; color: #718096; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">$${symbol}</div>
                                </div>
                                <div class="status-badge" style="background: ${lpStatusColor === 'green' ? 'linear-gradient(135deg, #48bb78 0%, #38a169 100%)' :
                            lpStatusColor === 'red' ? 'linear-gradient(135deg, #f56565 0%, #e53e3e 100%)' :
                                lpStatusColor === 'orange' ? 'linear-gradient(135deg, #ed8936 0%, #dd6b20 100%)' :
                                    'linear-gradient(135deg, #a0aec0 0%, #718096 100%)'}; 
                                           color: white; 
                                           padding: 10px 18px; 
                                           border-radius: 30px; 
                                           font-size: 0.8rem; 
                                           font-weight: 700;
                                           text-transform: uppercase;
                                           letter-spacing: 0.8px;
                                           box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                                           border: 2px solid rgba(255,255,255,0.3);">
                                    ${lpStatus}
                                </div>
                            </div>
                            
                            <!-- Contract Address Section -->
                            <div style="background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%); 
                                        border: 3px solid transparent; 
                                        background-clip: padding-box;
                                        border-radius: 16px; 
                                        padding: 20px; 
                                        margin-bottom: 20px;
                                        position: relative;
                                        overflow: hidden;
                                        box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);">
                                <!-- Gradient border effect -->
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; 
                                           background: linear-gradient(135deg, #667eea, #764ba2); 
                                           border-radius: 16px; z-index: -1; 
                                           transform: scale(1.02);"></div>
                                           
                                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                    <div style="width: 28px; height: 28px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">
                                        <span style="font-size: 14px; color: white;">📄</span>
                                    </div>
                                    <span style="font-weight: 800; font-size: 0.9rem; color: #2d3748; text-transform: uppercase; letter-spacing: 0.5px;">Contract Address</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                                    <div class="contract-address"; 
                                                 font-size: 0.85rem; 
                                                 color: #2d3748; 
                                                 background: #ffffff; 
                                                 padding: 12px 16px; 
                                                 border-radius: 12px; 
                                                 border: 2px solid #e2e8f0;
                                                 font-weight: 600;
                                                 flex: 1;
                                                 min-width: 300px;
                                                 word-break: break-all;
                                                 box-shadow: inset 0 1px 3px rgba(0,0,0,0.08);
                                                 transition: all 0.2s ease;"
                                         onmouseover="this.style.background='#f7fafc'; this.style.borderColor='#667eea'"
                                         onmouseout="this.style.background='#ffffff'; this.style.borderColor='#e2e8f0'">
                                        ${tokenAddress}
                                    </div>
                                    <a href="https://basescan.org/token/${tokenAddress}" 
                                       target="_blank" 
                                       style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                                              color: white; 
                                              padding: 12px 20px; 
                                              border-radius: 12px; 
                                              text-decoration: none; 
                                              font-size: 0.85rem; 
                                              font-weight: 700;
                                              transition: all 0.3s ease;
                                              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
                                              text-transform: uppercase;
                                              letter-spacing: 0.8px;
                                              border: 2px solid rgba(255,255,255,0.2);"
                                       onmouseover="this.style.transform='translateY(-2px) scale(1.05)'; this.style.boxShadow='0 8px 20px rgba(102, 126, 234, 0.5)'"
                                       onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'">
                                        🔍 Explore
                                    </a>
                                </div>
                            </div>
                            
                            <!-- LP Information Section -->
                            <div class="info-grid">
                                <div style="background: linear-gradient(135deg, #f0fff4 0%, #e6fffa 100%); 
                                           border: 3px solid #9ae6b4; 
                                           border-radius: 16px; 
                                           padding: 20px;
                                           position: relative;
                                           box-shadow: 0 4px 12px rgba(154, 230, 180, 0.3);
                                           transition: all 0.2s ease;"
                                     onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 6px 16px rgba(154, 230, 180, 0.4)'"
                                     onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(154, 230, 180, 0.3)'">
                                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                        <div style="width: 24px; height: 24px; background: linear-gradient(135deg, #38a169, #48bb78); border-radius: 6px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(56, 161, 105, 0.3);">
                                            <span style="font-size: 12px; color: white; font-weight: bold;">🆔</span>
                                        </div>
                                        <span style="font-weight: 800; font-size: 0.85rem; color: #22543d; text-transform: uppercase; letter-spacing: 0.5px;">LP Token ID</span>
                                    </div>
                                    <div style=" 
                                                font-size: 1.1rem; 
                                                color: #1a202c; 
                                                font-weight: 800;
                                                background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(247,250,252,0.9));
                                                padding: 8px 12px;
                                                border-radius: 8px;
                                                display: inline-block;
                                                border: 2px solid rgba(154, 230, 180, 0.3);
                                                text-align: center;
                                                min-width: 60px;">
                                        ${tokenId || 'N/A'}
                                    </div>
                                </div>
                                
                                <div style="background: linear-gradient(135deg, #fffaf0 0%, #fef5e7 100%); 
                                           border: 3px solid #f6ad55; 
                                           border-radius: 16px; 
                                           padding: 20px;
                                           position: relative;
                                           box-shadow: 0 4px 12px rgba(246, 173, 85, 0.3);
                                           transition: all 0.2s ease;"
                                     onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 6px 16px rgba(246, 173, 85, 0.4)'"
                                     onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(246, 173, 85, 0.3)'">
                                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                        <div style="width: 24px; height: 24px; background: linear-gradient(135deg, #ed8936, #f6ad55); border-radius: 6px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(237, 137, 54, 0.3);">
                                            <span style="font-size: 12px; color: white; font-weight: bold;">📊</span>
                                        </div>
                                        <span style="font-weight: 800; font-size: 0.85rem; color: #7b341e; text-transform: uppercase; letter-spacing: 0.5px;">Pool Status</span>
                                    </div>
                                    <div style="font-size: 1rem; 
                                                color: #1a202c; 
                                                font-weight: 800;
                                                background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(254,245,231,0.9));
                                                padding: 8px 12px;
                                                border-radius: 8px;
                                                display: inline-block;
                                                border: 2px solid rgba(246, 173, 85, 0.3);
                                                text-align: center;
                                                min-width: 80px;">
                                        ${tokenId && tokenId !== '0' ? '✅ Active' : '❌ No LP'}
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Uncollected Fees Section -->
                            <div id="fees-section-${tokenId}" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); 
                                       border: 3px solid #38bdf8; 
                                       border-radius: 16px; 
                                       padding: 24px;
                                       margin-top: 20px;
                                       position: relative;
                                       box-shadow: 0 6px 16px rgba(56, 189, 248, 0.3);
                                       transition: all 0.3s ease;"
                                 onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 24px rgba(56, 189, 248, 0.4)'"
                                 onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 6px 16px rgba(56, 189, 248, 0.3)'">
                                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                                    <div style="width: 32px; height: 32px; background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%); border-radius: 10px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(14, 165, 233, 0.4);">
                                        <span style="font-size: 16px; color: white; font-weight: bold;">💰</span>
                                    </div>
                                    <span style="font-weight: 800; font-size: 1rem; color: #0c4a6e; text-transform: uppercase; letter-spacing: 0.8px;">Uncollected Fees</span>
                                </div>
                                <div id="fee-amount-${tokenId}" style="font-size: 1.25rem; 
                                            color: #1a202c; 
                                            font-weight: 800;
                                            margin-bottom: 12px;
                                            background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(224,242,254,0.9));
                                            padding: 12px 16px;
                                            border-radius: 12px;
                                            border: 2px solid rgba(56, 189, 248, 0.3);
                                            text-align: center;">
                                    <span class="loading-spinner" style="display: inline-block; width: 20px; height: 20px; border: 3px solid #e2e8f0; border-top: 3px solid #0ea5e9; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 8px;"></span>
                                    Checking fees...
                                </div>
                                <div style="font-size: 0.8rem; color: #64748b; font-weight: 600; text-align: center; text-transform: uppercase; letter-spacing: 0.5px;">
                                    Fees from trading activity on your token's LP pool
                                </div>
                            </div>
                        </div>
                    `;
                }

                if (!loadMore) {
                    // Initial load - create cards container
                    let html = `<div style="margin-bottom: 16px;">`;
                    html += tokenCards;
                    html += `</div>`;

                    if (hasMore) {
                        html += `<div style="display:flex;justify-content:center;margin-top:12px;"><button onclick="loadMoreUserTokens()" class="btn btn-secondary">Load More (${allTokens.length - endIdx} remaining)</button></div>`;
                    }

                    list.innerHTML = html;

                    // After cards are loaded, check fees for each token
                    setTimeout(() => {
                        checkFeesForAllTokenCards(tokens);
                        // Removed automatic refresh - only refresh on user demand or page load
                    }, 500);
                } else {
                    // Load more - append cards to existing container
                    const container = list.querySelector('div');
                    if (container) {
                        container.insertAdjacentHTML('beforeend', tokenCards);
                    }

                    // Check fees for the newly loaded tokens
                    setTimeout(() => {
                        checkFeesForAllTokenCards(tokens.slice(startIdx, endIdx));
                        // Removed automatic refresh for load more - only manual refresh needed
                    }, 500);

                    // Update load more button
                    const loadMoreBtn = list.querySelector('button');
                    if (loadMoreBtn) {
                        if (hasMore) {
                            loadMoreBtn.textContent = `Load More (${allTokens.length - endIdx} remaining)`;
                        } else {
                            loadMoreBtn.remove();
                        }
                    }
                }

                if (!loadMore) {
                    userTokensPage = 1; // Set to 1 after first load
                    // Check for claimable token amounts on initial load
                    checkClaimableTokenAmounts().catch(e => console.log('Error checking tokens:', e.message));
                } else {
                    userTokensPage++; // Increment only for load more
                }
            } catch (err) {
                list.textContent = 'Failed to load';
                console.error(err);
            }
        }

        async function loadMoreUserTokens() {
            await loadUserTokens(true);
        }

        async function loadAdminTokens(loadMore = false) {
            const card = document.getElementById('adminCard');
            if (!card || !userAddress) return;
            if (!await isAdmin(userAddress)) { card.style.display = 'none'; return; }
            card.style.display = 'block';

            const list = document.getElementById('allTokensList');

            // Only load data on initial load, not when loading more pages
            if (!loadMore) {
                try {
                    list.textContent = 'Loading all tokens...';
                    console.log('[Admin] Loading all tokens');

                    // Get all tokens by iterating through the allTokens array
                    const tokenCount = await CONTRACT.getTokenCount();
                    allAdminTokens = [];
                    for (let i = 0; i < tokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            allAdminTokens.push(tokenInfo);
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break; // Stop if we hit an error
                        }
                    }

                    console.log('[Admin] Total tokens:', allAdminTokens.length);

                    if (allAdminTokens.length === 0) {
                        list.textContent = 'No tokens have been launched yet.';
                        return;
                    }

                    // Initialize filtered tokens (no search initially)
                    filteredAdminTokens = [...allAdminTokens];
                    adminTokensPage = 0;

                } catch (err) {
                    list.textContent = 'Failed to load';
                    console.error(err);
                    return;
                }
            }

            await renderAdminTokens(loadMore);
        }

        async function renderAdminTokens(loadMore = false) {
            const list = document.getElementById('allTokensList');

            if (filteredAdminTokens.length === 0) {
                const searchTerm = document.getElementById('adminTokenSearch').value;
                list.textContent = searchTerm ? 'No tokens match your search.' : 'No tokens have been launched yet.';
                return;
            }

            try {
                // Pagination logic using smaller page size for admin
                const startIdx = adminTokensPage * ADMIN_TOKENS_PER_PAGE;
                const endIdx = startIdx + ADMIN_TOKENS_PER_PAGE;
                const tokens = filteredAdminTokens.slice(startIdx, endIdx);
                const hasMore = endIdx < filteredAdminTokens.length;

                // Determine if any platform fees exist yet
                let platformFeesWei = ethers.BigNumber.from(0);
                try { platformFeesWei = await CONTRACT.getPlatformFees(); } catch { }

                // Generate table rows
                let tableRows = '';
                for (const t of tokens) {
                    const raw = (t.totalFeesETH || (Array.isArray(t) && t.length > 9 ? t[9] : t[7]));
                    // Show platform's 50% share of the total fees
                    const totalFee = sanitizeFee(raw, platformFeesWei);
                    const platformShareETH = (parseFloat(totalFee.replace(/ ETH.*$/, '')) * 0.5);
                    const platformShareUSD = platformShareETH * currentETHPrice;
                    const fee = platformShareETH.toFixed(9) + ' ETH ($' + platformShareUSD.toFixed(2) + ')';
                    const id = t.tokenId || t[4];
                    const name = t.name || t[2];
                    const sym = t.symbol || t[3];
                    const tokenAddress = t.tokenAddress || t[0];
                    const creator = (t.creator || t[1]).slice(0, 6) + '...' + (t.creator || t[1]).slice(-4);

                    // Check LP NFT status
                    let lpStatus = 'Checking...';
                    try {
                        const nfpm = new ethers.Contract(POSITION_MANAGER_ADDRESS, ["function ownerOf(uint256) view returns (address)"], provider);
                        const ownerAddr = await nfpm.ownerOf(id);
                        const factoryAddr = TOKEN_FACTORY_ADDRESS.toLowerCase();
                        const creatorAddr = (t.creator || t[1]).toLowerCase();

                        if (ownerAddr.toLowerCase() === factoryAddr) {
                            lpStatus = '<span style="color:green;">Locked</span>';
                        } else if (ownerAddr.toLowerCase() === creatorAddr) {
                            lpStatus = '<span style="color:red;">Creator</span>';
                        } else {
                            lpStatus = '<span style="color:orange;">External</span>';
                        }
                    } catch {
                        lpStatus = '<span style="color:gray;">Unknown</span>';
                    }

                    tableRows += `<tr><td style="text-align:center;vertical-align:middle;padding:8px;">${name}</td><td style="text-align:center;vertical-align:middle;padding:8px;">${sym}</td><td style="text-align:center;vertical-align:middle;padding:8px;"><a href="https://basescan.org/token/${tokenAddress}" target="_blank" style="color:#667eea;text-decoration:none;">${tokenAddress.slice(0, 8)}...${tokenAddress.slice(-6)}</a></td><td style="text-align:center;vertical-align:middle;padding:8px;">${id}</td><td style="text-align:center;vertical-align:middle;padding:8px;">${creator}</td><td style="text-align:center;vertical-align:middle;padding:8px;font-weight:600;">${fee}</td><td style='text-align:center;vertical-align:middle;padding:8px;'>${lpStatus}</td></tr>`;
                }

                if (!loadMore) {
                    // Initial load or search results - create full table
                    let html = '<div class="table-container"><table style="width:100%;border-collapse:collapse;">';
                    html += '<thead><tr><th style="text-align:center;vertical-align:middle;padding:10px;border-bottom:2px solid #e2e8f0;">Name</th><th style="text-align:center;vertical-align:middle;padding:10px;border-bottom:2px solid #e2e8f0;">Symbol</th><th style="text-align:center;vertical-align:middle;padding:10px;border-bottom:2px solid #e2e8f0;">Token Address</th><th style="text-align:center;vertical-align:middle;padding:10px;border-bottom:2px solid #e2e8f0;">ID</th><th style="text-align:center;vertical-align:middle;padding:10px;border-bottom:2px solid #e2e8f0;">Creator</th><th style="text-align:center;vertical-align:middle;padding:10px;border-bottom:2px solid #e2e8f0;">All-Time Fees ETH</th><th style="text-align:center;vertical-align:middle;padding:10px;border-bottom:2px solid #e2e8f0;">LP Status</th></tr></thead>';
                    html += '<tbody>' + tableRows + '</tbody>';
                    html += '</table></div>';

                    // Show results info
                    const totalResults = filteredAdminTokens.length;
                    const showing = Math.min(endIdx, totalResults);
                    html += `<div style="margin-top:8px;font-size:0.8rem;color:#666;text-align:center;">Showing ${showing} of ${totalResults} tokens</div>`;

                    if (hasMore) {
                        html += `<div style="display:flex;justify-content:center;margin-top:12px;"><button onclick="loadMoreAdminTokens()" class="btn btn-secondary">Load More (${totalResults - endIdx} remaining)</button></div>`;
                    }

                    list.innerHTML = html;
                } else {
                    // Load more - append rows to existing table
                    const tbody = list.querySelector('table tbody');
                    if (tbody) {
                        tbody.insertAdjacentHTML('beforeend', tableRows);
                    }

                    // Update results info
                    const infoDiv = list.querySelector('div[style*="Showing"]');
                    if (infoDiv) {
                        const totalResults = filteredAdminTokens.length;
                        const showing = Math.min(endIdx, totalResults);
                        infoDiv.textContent = `Showing ${showing} of ${totalResults} tokens`;
                    }

                    // Update load more button
                    const loadMoreBtn = list.querySelector('button');
                    if (loadMoreBtn) {
                        if (hasMore) {
                            loadMoreBtn.textContent = `Load More (${filteredAdminTokens.length - endIdx} remaining)`;
                        } else {
                            loadMoreBtn.remove();
                        }
                    }
                }

                // Update platform fees and buttons (only on initial load)
                if (!loadMore) {
                    try {
                        const pf = await CONTRACT.getPlatformFees();
                        const platformElement = document.getElementById('platformFeesValue');
                        if (platformElement) {
                            const feeAmount = fmt(pf);
                            platformElement.textContent = feeAmount;
                        }
                    } catch { }
                    document.getElementById('collectAllFeesBtn').disabled = allAdminTokens.length === 0;
                    document.getElementById('withdrawPlatformBtn').disabled = false;

                    // Enable rescue button for admin
                    const rescueBtn = document.getElementById('rescueEthBtn');
                    if (rescueBtn) rescueBtn.disabled = false;
                }

                if (!loadMore) {
                    adminTokensPage = 1; // Set to 1 after first render
                } else {
                    adminTokensPage++; // Increment for load more
                }

            } catch (err) {
                list.textContent = 'Failed to render tokens';
                console.error(err);
            }
        }

        async function loadMoreAdminTokens() {
            await loadAdminTokens(true);
        }

        // Search functionality for admin panel
        function handleAdminSearch() {
            const searchTerm = document.getElementById('adminTokenSearch').value.toLowerCase();

            if (!searchTerm) {
                // No search term, show all tokens
                filteredAdminTokens = [...allAdminTokens];
            } else {
                // Filter tokens based on search term
                filteredAdminTokens = allAdminTokens.filter(token => {
                    const name = (token.name || token[2]).toLowerCase();
                    const symbol = (token.symbol || token[3]).toLowerCase();
                    const address = (token.tokenAddress || token[0]).toLowerCase();
                    const creator = (token.creator || token[1]).toLowerCase();

                    return name.includes(searchTerm) ||
                        symbol.includes(searchTerm) ||
                        address.includes(searchTerm) ||
                        creator.includes(searchTerm);
                });
            }

            // Reset pagination and render results
            adminTokensPage = 0;
            renderAdminTokens(false);
        }

        async function handleCollectMyFees() {
            const btn = document.getElementById('collectMyFeesBtn');
            btn.disabled = true;
            btn.textContent = 'Collecting...';

            try {
                console.log('🔄 Starting fee collection...');
                showStatus('🔍 Collecting fees from your tokens...', 'info');

                if (!CONTRACT || !userAddress) {
                    throw new Error('Wallet not connected or CONTRACT not available');
                }

                // Get user's created tokens
                const userTokens = await getUserTokens(userAddress);
                console.log('📊 Found', userTokens.length, 'user tokens');

                if (userTokens.length === 0) {
                    showStatus('📭 No tokens found to collect fees from', 'info');
                    return;
                }

                let successCount = 0;
                let errorCount = 0;

                // Try to collect fees from each token
                for (const token of userTokens) {
                    const tokenId = token.tokenId || token[4];
                    const tokenName = token.symbol || token[3] || 'Unknown';

                    try {
                        console.log(`🔄 Collecting fees for ${tokenName} (ID: ${tokenId})...`);
                        const tx = await CONTRACT.collectFees(tokenId);
                        await tx.wait();
                        console.log(`✅ Collected fees for ${tokenName}`);
                        successCount++;
                    } catch (e) {
                        console.log(`❌ Failed to collect fees for ${tokenName}:`, e.message);
                        errorCount++;
                        // Continue with next token
                    }
                }

                if (successCount > 0) {
                    showStatus(`✅ Successfully collected fees from ${successCount} token(s)`, 'success');
                } else if (errorCount > 0) {
                    showStatus('⚠️ No fees were collected - tokens may not have fees yet', 'warning');
                } else {
                    showStatus('📭 No fees to collect', 'info');
                }

            } catch (e) {
                console.error('Fee collection error:', e);
                showStatus('❌ Fee collection failed: ' + e.message, 'error');
            } finally {
                btn.textContent = 'Collect My Fees';
                btn.disabled = false;

                // Refresh the fee displays
                try {
                    await checkPlatformFees();
                } catch (e) {
                    console.log('Failed to refresh fee displays:', e);
                }
            }
        }

        // Add this new function to detect minimum withdrawal amounts
        async function detectMinimumWithdrawal() {
            console.log('🔍 DETECTING MINIMUM WITHDRAWAL THRESHOLDS');

            if (!CONTRACT || !userAddress) {
                console.log('❌ No CONTRACT or user address available');
                return;
            }

            // Test common minimum thresholds
            const testAmounts = [
                { name: '1 wei', amount: '1' },
                { name: '1 gwei', amount: ethers.utils.parseUnits('1', 'gwei').toString() },
                { name: '0.00001 ETH', amount: ethers.utils.parseEther('0.00001').toString() },
                { name: '0.0001 ETH', amount: ethers.utils.parseEther('0.0001').toString() },
                { name: '0.001 ETH', amount: ethers.utils.parseEther('0.001').toString() },
                { name: '0.01 ETH', amount: ethers.utils.parseEther('0.01').toString() }
            ];

            console.log('🧪 Testing creator fee withdrawal thresholds...');

            for (const test of testAmounts) {
                try {
                    // Create a test CONTRACT call to see if this amount would work
                    const testCONTRACT = new ethers.Contract(
                        CONTRACT.address,
                        ['function withdrawCreatorFees() external'],
                        provider
                    );

                    // We can't actually test withdrawal amounts directly, but we can check
                    // against current balance vs common thresholds
                    const currentBalance = await CONTRACT.getCreatorFees(userAddress);
                    const testAmount = ethers.BigNumber.from(test.amount);

                    const meetsThreshold = currentBalance.gte(testAmount);
                    console.log(`  ${test.name} (${test.amount} wei): ${meetsThreshold ? '✅ BALANCE MEETS' : '❌ BALANCE TOO LOW'}`);

                } catch (e) {
                    console.log(`  ${test.name}: Error testing - ${e.message}`);
                }
            }

            console.log('📊 Current balances:');
            try {
                const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                const platformFees = await CONTRACT.getPlatformFees();

                console.log(`  Creator fees: ${creatorFees.toString()} wei (${ethers.utils.formatEther(creatorFees)} ETH)`);
                console.log(`  Platform fees: ${platformFees.toString()} wei (${ethers.utils.formatEther(platformFees)} ETH)`);

                // Check against common minimums
                const common001ETH = ethers.utils.parseEther('0.001');
                const common0001ETH = ethers.utils.parseEther('0.0001');

                console.log('💡 Analysis:');
                if (creatorFees.lt(common0001ETH)) {
                    console.log('  ❌ Creator fees likely below 0.0001 ETH minimum threshold');
                    console.log(`  📈 Need ${ethers.utils.formatEther(common0001ETH.sub(creatorFees))} more ETH to reach 0.0001 ETH`);
                }

                if (creatorFees.lt(common001ETH)) {
                    console.log('  ❌ Creator fees likely below 0.001 ETH minimum threshold');
                    console.log(`  📈 Need ${ethers.utils.formatEther(common001ETH.sub(creatorFees))} more ETH to reach 0.001 ETH`);
                }

            } catch (e) {
                console.log('❌ Error checking balances:', e.message);
            }

            console.log('🔍 MINIMUM WITHDRAWAL DETECTION COMPLETE');
        }

        async function handleWithdrawMyFees() {
            const btn = document.getElementById('withdrawMyFeesBtn');
            btn.disabled = true;
            btn.textContent = 'Withdrawing...';

            try {
                console.log('🔄 Starting creator fee withdrawal...');

                if (!CONTRACT || !userAddress) {
                    throw new Error('Wallet not connected or CONTRACT not available');
                }

                // Check current balance before withdrawing
                const balanceBefore = await CONTRACT.getCreatorFees(userAddress);
                const balanceETH = ethers.utils.formatEther(balanceBefore);

                console.log('💰 Creator fees before withdrawal:', balanceETH, 'ETH');
                console.log('💰 Creator fees in wei:', balanceBefore.toString());

                if (balanceBefore.eq(0)) {
                    throw new Error('No creator fees available to withdraw');
                }

                console.log('🚀 Calling withdrawCreatorFees()...');
                const tx = await CONTRACT.withdrawCreatorFees();
                console.log('⏳ Transaction sent, waiting for confirmation...');

                const receipt = await tx.wait();
                console.log('✅ Transaction confirmed:', receipt.transactionHash);

                // Check balance after
                const balanceAfter = await CONTRACT.getCreatorFees(userAddress);
                const withdrawn = ethers.utils.formatEther(balanceBefore.sub(balanceAfter));

                showStatus(`✅ Successfully withdrew ${withdrawn} ETH creator fees`, 'success');

            } catch (e) {
                console.error('❌ Creator fee withdrawal failed:', e);
                let errorMsg = e.message;

                // Simplify error messages
                if (errorMsg.includes('execution reverted') || errorMsg.includes('CALL_EXCEPTION') || errorMsg.includes('UNPREDICTABLE_GAS_LIMIT')) {
                    errorMsg = 'CONTRACT rejected withdrawal - may be below minimum threshold or other restrictions';
                } else if (errorMsg.includes('insufficient funds')) {
                    errorMsg = 'Insufficient ETH for gas fees';
                } else if (errorMsg.includes('user rejected')) {
                    errorMsg = 'Transaction rejected by user';
                }

                showStatus(errorMsg, 'error');
            }

            btn.textContent = 'Withdraw Creator Fees';
            btn.disabled = false;

            // Refresh the displays
            try {
                await checkPlatformFees();
            } catch (e) {
                console.log('Failed to refresh displays:', e);
            }
        }

        async function handleAdminCollectAllFees() {
            const btn = document.getElementById('collectAllFeesBtn');
            btn.disabled = true;
            btn.textContent = 'Collecting...';

            try {
                console.log('🔄 Starting admin LP fee collection...');

                if (!CONTRACT || !userAddress) {
                    throw new Error('Wallet not connected or CONTRACT not available');
                }

                // First, check what fees are available before collection
                console.log('📊 Checking fees before collection:');
                try {
                    const platformFeesBefore = await CONTRACT.getPlatformFees();
                    const creatorFeesBefore = await CONTRACT.getCreatorFees(userAddress);
                    console.log('  Platform fees before:', ethers.utils.formatEther(platformFeesBefore), 'ETH');
                    console.log('  Creator fees before:', ethers.utils.formatEther(creatorFeesBefore), 'ETH');
                } catch (e) {
                    console.log('  Could not check fees before collection:', e.message);
                }

                // Check what functions are available
                console.log('🔍 Checking available admin collect functions:');
                console.log('  collectAllTokens:', typeof CONTRACT.collectAllTokens);
                console.log('  collectAllFees:', typeof CONTRACT.collectAllFees);

                // Also check if we can get all tokens to see what might have fees
                console.log('🔍 Checking all tokens for potential fees...');
                try {
                    const totalTokens = await CONTRACT.getTokenCount();
                    console.log('  Total tokens in CONTRACT:', totalTokens.toString());

                    // Check a few tokens to see if they have LP positions with fees
                    for (let i = 0; i < Math.min(totalTokens.toNumber(), 3); i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            const tokenId = tokenInfo[4]; // LP NFT ID
                            console.log(`  Token ${i}: LP NFT ID ${tokenId}`);

                            // Try to check this LP position for fees
                            const nfpm = new ethers.Contract(POSITION_MANAGER_ADDRESS, [
                                "function positions(uint256) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)"
                            ], provider);

                            const position = await nfpm.positions(tokenId);
                            const fees0 = ethers.utils.formatEther(position.tokensOwed0);
                            const fees1 = ethers.utils.formatEther(position.tokensOwed1);
                            console.log(`    Uncollected fees: ${fees0} token0, ${fees1} token1`);

                        } catch (e) {
                            console.log(`  Could not check token ${i} fees:`, e.message);
                        }
                    }
                } catch (e) {
                    console.log('  Could not check token details:', e.message);
                }

                let tx;
                if (typeof CONTRACT.collectAllTokens === 'function') {
                    console.log('🚀 Calling collectAllTokens()...');
                    tx = await CONTRACT.collectAllTokens();
                } else if (typeof CONTRACT.collectAllFees === 'function') {
                    console.log('🚀 Calling collectAllFees()...');
                    tx = await CONTRACT.collectAllFees();
                } else {
                    throw new Error('No admin collect function available in CONTRACT');
                }

                console.log('⏳ Transaction sent:', tx.hash);
                console.log('⏳ Waiting for confirmation...');

                const receipt = await tx.wait();
                console.log('✅ Transaction confirmed:', receipt.transactionHash);
                console.log('📊 Gas used:', receipt.gasUsed.toString());

                // Check if any events were emitted
                if (receipt.logs && receipt.logs.length > 0) {
                    console.log('📋 Transaction logs:', receipt.logs.length, 'events emitted');
                    // Try to decode some common events
                    for (const log of receipt.logs) {
                        console.log('    Event data:', log.data);
                        console.log('    Event topics:', log.topics);
                    }
                } else {
                    console.log('📋 No events emitted - may indicate no fees were collected');
                }

                // Check fees after collection to see if anything changed
                console.log('📊 Checking fees after collection:');
                try {
                    const platformFeesAfter = await CONTRACT.getPlatformFees();
                    const creatorFeesAfter = await CONTRACT.getCreatorFees(userAddress);
                    console.log('  Platform fees after:', ethers.utils.formatEther(platformFeesAfter), 'ETH');
                    console.log('  Creator fees after:', ethers.utils.formatEther(creatorFeesAfter), 'ETH');
                } catch (e) {
                    console.log('  Could not check fees after collection:', e.message);
                }

                showStatus('✅ Admin LP fee collection completed', 'success');

            } catch (e) {
                console.error('❌ Admin collect failed:', e);
                let errorMsg = 'Admin collect failed: ' + e.message;

                if (e.message.includes('execution reverted')) {
                    errorMsg = 'CONTRACT rejected collection - may be no fees to collect or insufficient permissions';
                } else if (e.message.includes('user rejected')) {
                    errorMsg = 'Transaction rejected by user';
                } else if (e.message.includes('insufficient funds')) {
                    errorMsg = 'Insufficient ETH for gas fees';
                } else if (e.message.includes('No admin collect function')) {
                    errorMsg = 'CONTRACT does not support admin fee collection';
                }

                showStatus(errorMsg, 'error');
            }

            btn.textContent = 'Claim Token Fees and Gather ETH';
            btn.disabled = false;

            // Refresh the displays
            try {
                await checkPlatformFees();
            } catch (e) {
                console.log('Failed to refresh displays:', e);
            }
        }

        async function handleWithdrawPlatformFees() {
            const btn = document.getElementById('withdrawPlatformBtn');
            btn.disabled = true;
            btn.textContent = 'Withdrawing...';

            try {
                console.log('🔄 Starting platform fee withdrawal...');

                if (!CONTRACT || !userAddress) {
                    throw new Error('Wallet not connected or CONTRACT not available');
                }

                // Check current balance before withdrawing
                const balanceBefore = await CONTRACT.getPlatformFees();
                console.log('💰 Platform fees before withdrawal:', ethers.utils.formatEther(balanceBefore), 'ETH');

                if (balanceBefore.eq(0)) {
                    throw new Error('No platform fees available to withdraw');
                }

                console.log('🚀 Calling withdrawPlatformFees()...');
                const tx = await CONTRACT.withdrawPlatformFees();
                console.log('⏳ Transaction sent, waiting for confirmation...');

                const receipt = await tx.wait();
                console.log('✅ Transaction confirmed:', receipt.transactionHash);

                // Check balance after
                const balanceAfter = await CONTRACT.getPlatformFees();
                const withdrawn = ethers.utils.formatEther(balanceBefore.sub(balanceAfter));

                showStatus(`✅ Successfully withdrew ${withdrawn} ETH platform fees`, 'success');

            } catch (e) {
                console.error('❌ Platform fee withdrawal failed:', e);
                let errorMsg = 'Platform withdraw failed: ' + e.message;

                // Check for common error causes
                if (e.message.includes('insufficient funds')) {
                    errorMsg = 'Insufficient ETH for gas fees';
                } else if (e.message.includes('user rejected')) {
                    errorMsg = 'Transaction rejected by user';
                } else if (e.message.includes('No platform fees')) {
                    errorMsg = 'No fees available to withdraw';
                } else if (e.message.includes('Ownable: caller is not the owner')) {
                    errorMsg = 'Only CONTRACT owner can withdraw platform fees';
                }

                showStatus(errorMsg, 'error');
            }

            btn.textContent = 'Withdraw Available ETH';
            btn.disabled = false;

            // Refresh the displays
            try {
                await checkPlatformFees();
            } catch (e) {
                console.log('Failed to refresh displays:', e);
            }
        }

        async function handleRescueTrappedEth() {
            const btn = document.getElementById('rescueEthBtn');
            const originalText = btn.textContent;

            // Confirm this dangerous operation
            const confirmed = confirm(
                '🚨 EMERGENCY ETH RESCUE OPERATION\n\n' +
                'This will attempt to rescue any trapped ETH from the CONTRACT.\n' +
                'Are you sure you want to proceed?\n\n' +
                'This action is irreversible and should only be used if ETH is truly trapped.'
            );

            if (!confirmed) return;

            btn.disabled = true;
            btn.textContent = '🚨 Rescuing ETH...';

            try {
                // First check the CONTRACT's ETH balance
                const CONTRACTBalance = await provider.getBalance(TOKEN_FACTORY_ADDRESS);
                console.log('💰 CONTRACT ETH balance:', ethers.utils.formatEther(CONTRACTBalance));

                if (CONTRACTBalance.eq(0)) {
                    showStatus('No ETH found in CONTRACT to rescue', 'info');
                    return;
                }

                showStatus(`Found ${ethers.utils.formatEther(CONTRACTBalance)} ETH in CONTRACT. Attempting rescue...`, 'info');

                // Use the rescueAndSellStuckTokens function with WETH address to rescue ETH
                const WETH = "0x4200000000000000000000000000000000000006";
                console.log('🔧 Calling rescueAndSellStuckTokens with WETH to rescue ETH...');

                const tx = await CONTRACT.rescueAndSellStuckTokens([WETH]);
                console.log('📡 Transaction sent:', tx.hash);

                showStatus(`ETH rescue transaction sent: ${tx.hash}. Waiting for confirmation...`, 'info');

                const receipt = await tx.wait();
                console.log('✅ Transaction confirmed:', receipt);

                // Check new balance
                const newBalance = await provider.getBalance(TOKEN_FACTORY_ADDRESS);
                const rescued = CONTRACTBalance.sub(newBalance);

                if (rescued.gt(0)) {
                    showStatus(`🎉 Successfully rescued ${ethers.utils.formatEther(rescued)} ETH from CONTRACT!`, 'success');
                    console.log(`✅ Rescued ${ethers.utils.formatEther(rescued)} ETH`);
                } else {
                    showStatus('⚠️ Rescue transaction completed but no ETH was moved. Check transaction details.', 'warning');
                }

                await refreshDashboards();

            } catch (error) {
                console.error('❌ ETH rescue failed:', error);
                showStatus(`ETH rescue failed: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        // 🔄 COMPREHENSIVE FEE SCANNING SYSTEM 🔄
        async function scanAndCollectAllAvailableFees(performCollection = false) {
            if (!userAddress || !CONTRACT) {
                console.log('⚠️ Cannot scan fees - wallet not connected');
                return { userFees: '0', platformFees: '0', uncollectedFees: 0 };
            }

            console.log('🔍 COMPREHENSIVE FEE SCAN STARTING');
            console.log('👤 User:', userAddress);
            console.log('🏭 CONTRACT:', TOKEN_FACTORY_ADDRESS);
            console.log('💰 Collection Mode:', performCollection ? 'ENABLED' : 'READ-ONLY');

            const results = {
                userFees: '0',
                platformFees: '0',
                uncollectedFees: 0,
                tokensWithUncollectedFees: [],
                collectionResults: []
            };

            try {
                // 1. Check current withdrawable creator fees
                console.log('\n📊 CHECKING WITHDRAWABLE CREATOR FEES:');
                try {
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    results.userFees = ethers.utils.formatEther(creatorFees);
                    console.log('💰 Current withdrawable creator fees:', results.userFees, 'ETH');
                } catch (e) {
                    console.log('❌ Could not check creator fees:', e.message);
                }

                // 2. Check platform fees (if admin)
                console.log('\n🏢 CHECKING PLATFORM FEES:');
                try {
                    if (await isAdmin(userAddress)) {
                        const platformFees = await CONTRACT.getPlatformFees();
                        results.platformFees = ethers.utils.formatEther(platformFees);
                        console.log('🏢 Platform fees available:', results.platformFees, 'ETH');
                    } else {
                        console.log('👤 User is not admin - skipping platform fee check');
                    }
                } catch (e) {
                    console.log('❌ Could not check platform fees:', e.message);
                }

                // 3. Scan all user tokens for uncollected fees
                console.log('\n🪙 SCANNING ALL USER TOKENS FOR UNCOLLECTED FEES:');
                try {
                    const allTokens = await getUserTokens(userAddress);
                    console.log('📊 Total user tokens to scan:', allTokens.length);

                    for (let i = 0; i < allTokens.length; i++) {
                        const token = allTokens[i];
                        const tokenId = token.tokenId || token[4];
                        const tokenName = token.name || token[2] || 'Unknown';
                        const tokenSymbol = token.symbol || token[3] || 'UNK';

                        try {
                            // Check if there are uncollected fees in the position
                            const positionManager = new ethers.Contract(
                                '0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1',
                                [
                                    'function positions(uint256 tokenId) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)'
                                ],
                                provider
                            );

                            const position = await positionManager.positions(tokenId);
                            const tokensOwed0 = position.tokensOwed0;
                            const tokensOwed1 = position.tokensOwed1;

                            if (!tokensOwed0.isZero() || !tokensOwed1.isZero()) {
                                results.uncollectedFees++;
                                results.tokensWithUncollectedFees.push({
                                    tokenId,
                                    name: tokenName,
                                    symbol: tokenSymbol,
                                    tokensOwed0: ethers.utils.formatUnits(tokensOwed0, 18),
                                    tokensOwed1: ethers.utils.formatUnits(tokensOwed1, 18)
                                });

                                console.log(`  🎯 Token ${i + 1}: ${tokenName} (${tokenSymbol}) - ID: ${tokenId}`);
                                console.log(`     💰 Uncollected fees: ${ethers.utils.formatUnits(tokensOwed0, 18)} | ${ethers.utils.formatUnits(tokensOwed1, 18)}`);

                                // Perform collection if requested
                                if (performCollection) {
                                    console.log(`     🚀 Collecting fees for ${tokenName}...`);
                                    try {
                                        const tx = await CONTRACT.collectFees(tokenId);
                                        const receipt = await tx.wait();

                                        console.log(`     ✅ Collection successful - TX: ${tx.hash}`);
                                        results.collectionResults.push({
                                            tokenId,
                                            name: tokenName,
                                            success: true,
                                            txHash: tx.hash,
                                            blockNumber: receipt.blockNumber
                                        });
                                    } catch (e) {
                                        console.log(`     ❌ Collection failed:`, e.message);
                                        results.collectionResults.push({
                                            tokenId,
                                            name: tokenName,
                                            success: false,
                                            error: e.message
                                        });
                                    }
                                }
                            } else {
                                // Only log every 10th token to avoid spam
                                if (i % 10 === 0 || i === allTokens.length - 1) {
                                    console.log(`  📭 Tokens ${Math.max(0, i - 9)} - ${i + 1}: No uncollected fees`);
                                }
                            }
                        } catch (e) {
                            console.log(`  ⚠️ Could not check token ${tokenId}:`, e.message);
                        }
                    }
                } catch (e) {
                    console.log('❌ Could not scan user tokens:', e.message);
                }

                // 4. Final summary
                console.log('\n📊 FEE SCAN SUMMARY:');
                console.log('💰 Withdrawable creator fees:', results.userFees, 'ETH');
                console.log('🏢 Platform fees:', results.platformFees, 'ETH');
                console.log('🪙 Tokens with uncollected fees:', results.uncollectedFees);

                if (performCollection) {
                    const successful = results.collectionResults.filter(r => r.success).length;
                    const failed = results.collectionResults.filter(r => !r.success).length;
                    console.log('✅ Successful collections:', successful);
                    console.log('❌ Failed collections:', failed);
                }

                // 5. Check final state after collection
                if (performCollection && results.collectionResults.length > 0) {
                    console.log('\n🔄 CHECKING UPDATED FEE BALANCES:');
                    try {
                        const updatedCreatorFees = await CONTRACT.getCreatorFees(userAddress);
                        const updatedAmount = ethers.utils.formatEther(updatedCreatorFees);
                        console.log('💰 Updated withdrawable creator fees:', updatedAmount, 'ETH');
                        results.userFees = updatedAmount;
                    } catch (e) {
                        console.log('❌ Could not check updated fees:', e.message);
                    }
                }

            } catch (e) {
                console.error('❌ Fee scan failed:', e);
            }

            console.log('🔍 COMPREHENSIVE FEE SCAN COMPLETE\n');
            return results;
        }

        // Auto-scan fees periodically
        let feesScanInterval;
        function startAutomaticFeeScanning() {
            // Clear any existing interval
            if (feesScanInterval) {
                console.log('⏰ Automatic fee scanning already running');
                return;
            }

            // Update status
            const statusEl = document.getElementById('feesScanStatus');
            if (statusEl) statusEl.textContent = 'Automatic scanning: Active (every 2min)';

            // Initial scan after 10 seconds
            setTimeout(async () => {
                if (userAddress && CONTRACT) {
                    console.log('🔍 INITIAL FEE SCAN');
                    await scanAndCollectAllAvailableFees(false);
                }
            }, 10000);

            // Scan every 2 minutes
            feesScanInterval = setInterval(async () => {
                if (userAddress && CONTRACT) {
                    console.log('⏰ PERIODIC FEE SCAN');
                    const results = await scanAndCollectAllAvailableFees(false);

                    // Update UI with results (remove distracting notifications)
                    if (parseFloat(results.userFees) > 0) {
                        console.log('🎉 FEES DETECTED! Consider withdrawing:', results.userFees, 'ETH');
                        // showStatus(`💰 Fees Available: ${results.userFees} ETH`, 'info');
                    }

                    if (results.uncollectedFees > 0) {
                        console.log('⚡ UNCOLLECTED FEES FOUND!', results.uncollectedFees, 'tokens need collection');
                        // showStatus(`⚡ ${results.uncollectedFees} tokens have uncollected fees - click "Collect My Fees"`, 'warning');
                    }

                    // Update displays directly without refreshing dashboards (to avoid recursion)
                    await Promise.all([loadUserTokens(), loadAdminTokens()]);
                }
            }, 120000); // 2 minutes

            console.log('⏰ Started automatic fee scanning (every 2 minutes)');
        }

        function stopAutomaticFeeScanning() {
            if (feesScanInterval) {
                clearInterval(feesScanInterval);
                feesScanInterval = null;

                // Update status
                const statusEl = document.getElementById('feesScanStatus');
                if (statusEl) statusEl.textContent = 'Automatic scanning: Stopped';

                console.log('⏰ Stopped automatic fee scanning');
            }
        }

        // Cleanup function for wallet disconnection
        function cleanupFeeScanning() {
            stopAutomaticFeeScanning();
            console.log('🧹 Fee scanning cleanup complete');
        }

        // Enhanced wallet disconnect handling
        function handleWalletDisconnect() {
            userAddress = null;
            CONTRACT = null;
            provider = null;
            cleanupFeeScanning();

            // Hide main content when wallet is disconnected
            const mainContent = document.getElementById('mainContent');
            const priceStatus = document.getElementById('priceStatus');
            const tokenManagement = document.getElementById('tokenManagementSection');
            if (mainContent) mainContent.style.display = 'none';
            if (priceStatus) priceStatus.style.display = 'none';
            if (tokenManagement) tokenManagement.style.display = 'none';

            // Show the connection prompt when wallet is disconnected
            const connectionStatus = document.getElementById('connectionStatus');
            if (connectionStatus) {
                connectionStatus.style.display = 'block';
            }

            // Reset UI
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) {
                connectBtn.textContent = 'CONNECT WALLET';
                connectBtn.style.background = '';
                connectBtn.style.cursor = 'pointer';
                connectBtn.disabled = false;
            }

            // Clear displays
            document.querySelectorAll('.balance-amount').forEach(el => {
                el.textContent = '0.0000 ETH';
            });

            console.log('🔌 Wallet disconnected and cleaned up');
        }

        // handleUpdatePrice removed (automatic updates only)

        async function connectWallet() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    // Mobile-aware error messaging
                    throw new Error(getMobileAwareWalletMessage());
                }

                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                userAddress = accounts[0];

                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();

                const network = await provider.getNetwork();

                if (network.chainId !== BASE_CHAIN_ID) {
                    document.getElementById('switchNetworkBtn').style.display = 'inline-block';
                    adjustButtonGroupLayout();
                    showStatus(`Connected to wrong network. Please switch to BASE Network (Chain ID: ${BASE_CHAIN_ID})`, 'error');
                    return;
                }

                CONTRACT = new ethers.Contract(TOKEN_FACTORY_ADDRESS, TOKEN_FACTORY_ABI, signer);
                await detectFactoryType();
                const legacy = !capability.creationFee;
                const modeEl = document.getElementById('factoryMode');
                if (modeEl) modeEl.textContent = 'Mode: ' + (legacy ? 'Token Factory' : 'Enhanced (Dynamic All-Inclusive)');
                // Fetch LP vault address if available
                try {
                    if (CONTRACT.functions.lpVault) {
                        const v = await CONTRACT.lpVault();
                        const el = document.getElementById('lpVaultStatus');
                        if (el) el.textContent = 'LP Vault: ' + (v && v !== '0x0000000000000000000000000000000000000000' ? v.slice(0, 10) + '...' + v.slice(-6) : 'Not Set');
                    } else {
                        // For AllTokensToLPFactory, LP NFTs are locked in factory
                        const el = document.getElementById('lpVaultStatus');
                        if (el) el.textContent = 'LP Custody: Factory Locked 🔒';
                    }
                } catch { }
                if (legacy) {
                    // Hide advanced sections entirely
                    const upBtn = document.getElementById('updatePriceBtn');
                    if (upBtn) upBtn.style.display = 'none';
                    const feeDisplay = document.getElementById('feeDisplay');
                    if (feeDisplay) feeDisplay.style.display = 'none';
                    const feeMgmt = document.getElementById('feeManagementCard');
                    if (feeMgmt) feeMgmt.style.display = 'none';
                    // Launch cost display removed - not needed for tiny amounts
                }

                const shortAddr = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                showStatus(`Wallet Connected Successfully! Address: ${shortAddr}`, 'success');
                document.getElementById('connectBtn').textContent = `Connected: ${shortAddr}`;
                document.getElementById('connectBtn').disabled = false; // Keep clickable for disconnect
                document.getElementById('connectBtn').style.cursor = 'pointer';
                document.getElementById('switchNetworkBtn').style.display = 'none';
                adjustButtonGroupLayout();

                // Show main content sections when wallet is connected
                updateBaseLaunchUI(userAddress);

                await updateDisplays();
                await refreshDashboards().catch(() => { });

            } catch (error) {
                console.error('Connection error:', error);
                showStatus(`Connection failed: ${error.message}`, 'error');
            }
        }

        async function switchToBase() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: `0x${BASE_CHAIN_ID.toString(16)}` }],
                });

                // Wait a bit for the switch to complete
                setTimeout(connectWallet, 1000);

            } catch (switchError) {
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: `0x${BASE_CHAIN_ID.toString(16)}`,
                                chainName: 'Base',
                                nativeCurrency: {
                                    name: 'Ethereum',
                                    symbol: 'ETH',
                                    decimals: 18
                                },
                                rpcUrls: [BASE_RPC_URL],
                                blockExplorerUrls: [EXPLORER_URL]
                            }],
                        });
                        setTimeout(connectWallet, 1000);
                    } catch (addError) {
                        showStatus('Failed to add BASE Network to MetaMask', 'error');
                    }
                } else {
                    showStatus('Failed to switch to BASE Network', 'error');
                }
            }
        }

        async function checkConnection() {
            try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length > 0) {
                    await connectWallet();
                    await refreshDashboards().catch(() => { });
                }
            } catch (error) {
                console.error('Check connection error:', error);
            }
        }

        async function updateDisplays() {
            try {
                if (!userAddress || !provider) {
                    console.log('User not connected, skipping display updates');
                    return;
                }

                // Update balance
                const balance = await provider.getBalance(userAddress);
                const ethAmount = parseFloat(ethers.utils.formatEther(balance));
                const usdAmount = ethAmount * currentETHPrice;
                document.getElementById('walletBalance').textContent = `${ethAmount.toFixed(4)} ETH ($${usdAmount.toFixed(2)})`;

                if (CONTRACT && capability.creationFee) {
                    try {
                        const feeRaw = await CONTRACT.getCreationFeeETH();
                        // Launch cost display removed - not needed for tiny amounts
                        window.totalRequiredETH = feeRaw;
                        window.creationFeeETH = feeRaw;
                    } catch (feeError) {
                        if (!capability.downgraded) {
                            console.warn('[Probe] getCreationFeeETH reverted post-connect. Downgrading to legacy mode.');
                            capability.downgraded = true;
                        }
                        capability.creationFee = false;
                        isAllInclusiveFactory = false;
                    }
                }
                if (!capability.creationFee) {
                    // Legacy factory fallback (no fee functions) using fixed 0.00005 ETH cost
                    const fixedFee = ethers.utils.parseEther('0.00005');
                    // Launch cost display removed - not needed for tiny amounts
                    window.totalRequiredETH = fixedFee;
                    window.creationFeeETH = fixedFee;
                }

                // Creator fees (optional, only if element exists)
                const creatorFeesEl = document.getElementById('creatorFees');
                if (creatorFeesEl && CONTRACT && userAddress) {
                    if (capability.creatorFees) {
                        try {
                            const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                            const creatorFeesFormatted = ethers.utils.formatEther(creatorFees);
                            creatorFeesEl.textContent = formatSmallETHAmount(creatorFeesFormatted);
                        } catch { creatorFeesEl.textContent = '0.000000 ETH'; capability.creatorFees = false; }
                    } else {
                        // Legacy: no aggregate mapping; show zero
                        creatorFeesEl.textContent = '0.000000 ETH';
                    }
                }

            } catch (error) {
                console.error('Update displays error:', error);
                // Fallback values if everything fails
                // Fee display removed; no fallback UI update needed here
                const cf = document.getElementById('creatorFees');
                if (cf) cf.textContent = '0.000000 ETH';
            }
        }

        async function handleCreateToken(event) {
            event.preventDefault();

            if (!CONTRACT || !signer) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            const name = document.getElementById('tokenName').value.trim();
            const symbol = document.getElementById('tokenSymbol').value.trim();

            if (!name || !symbol) {
                showStatus('Please enter both name and symbol', 'error');
                return;
            }

            const btn = document.getElementById('createTokenBtn');
            const originalText = btn.innerHTML;
            let totalRequired; // Define outside try block for error handling

            try {
                btn.innerHTML = '<span class="loading"></span> Diagnosing System...';
                btn.disabled = true;

                // 🔧 DIAGNOSTIC PHASE
                console.log('🔍 Running pre-creation diagnostics...');
                showStatus('🔍 Running system diagnostics...', 'info');

                // Check contract connectivity
                try {
                    const contractCode = await provider.getCode(TOKEN_FACTORY_ADDRESS);
                    if (contractCode === '0x') {
                        throw new Error('Contract not found at address');
                    }
                    console.log('✅ Contract exists and has code');
                } catch (error) {
                    throw new Error(`Contract connectivity issue: ${error.message}`);
                }

                // Check if contract is paused or has any state issues
                try {
                    const contractBalance = await provider.getBalance(TOKEN_FACTORY_ADDRESS);
                    console.log('✅ Contract balance:', ethers.utils.formatEther(contractBalance), 'ETH');
                } catch (error) {
                    console.warn('⚠️ Could not check contract balance:', error.message);
                }

                // Test a simple read function to ensure contract is responsive
                try {
                    // Try to call a view function if available
                    if (CONTRACT.platformFeePercentage) {
                        const platformFee = await CONTRACT.platformFeePercentage();
                        console.log('✅ Contract responsive, platform fee:', platformFee.toString());
                    }
                } catch (error) {
                    console.warn('⚠️ Contract may not be fully responsive:', error.message);
                }

                btn.innerHTML = '<span class="loading"></span> Calculating Cost...';

                // Check user balance first
                const userBalance = await provider.getBalance(userAddress);
                console.log('User balance:', ethers.utils.formatEther(userBalance), 'ETH');

                if (isAllInclusiveFactory) {
                    try {
                        // For the new CONTRACT, use a fixed fee since it doesn't have getCreationFeeETH
                        totalRequired = ethers.utils.parseEther('0.00005'); // Your CONTRACT's REQUIRED_ETH
                        console.log('Using new CONTRACT fixed fee: 0.00005 ETH');
                    } catch (e) {
                        console.warn('Failed to get fee, using manual calculation', e);
                        // Manual fee calculation: $0.99 / ETH_price_in_dollars
                        const ethPriceUSD = window.ethPriceUSD || 4500; // fallback to ~$4500
                        const feeUSD = 0.99;
                        const feeETH = feeUSD / ethPriceUSD;
                        totalRequired = ethers.utils.parseEther(feeETH.toString());
                        console.log('Manual fee calculation:', feeETH, 'ETH at', ethPriceUSD, 'USD/ETH');
                    }
                }
                if (!totalRequired || totalRequired.eq(0)) {
                    totalRequired = ethers.utils.parseEther('0.00005');
                    console.log('Using legacy fixed fee 0.00005 ETH');
                    isAllInclusiveFactory = false;
                }

                // Check if user has enough balance (including small gas buffer for BASE)
                const gasBuffer = ethers.utils.parseEther('0.0001'); // small extra for tx gas beyond fee value
                const totalNeeded = totalRequired.add(gasBuffer);

                if (userBalance.lt(totalNeeded)) {
                    throw new Error(`Insufficient balance. Need ${ethers.utils.formatEther(totalNeeded)} ETH, have ${ethers.utils.formatEther(userBalance)} ETH`);
                }

                showStatus(`Cost: ${parseFloat(ethers.utils.formatEther(totalRequired)).toFixed(6)} ETH (${isAllInclusiveFactory ? 'all-inclusive' : 'legacy'})`, 'info');

                btn.innerHTML = '<span class="loading"></span> Creating Token...';

                showStatus('Please confirm the transaction in MetaMask...', 'info');

                // Debug transaction parameters
                console.log('Creating token with params:', {
                    name,
                    symbol,
                    value: ethers.utils.formatEther(totalRequired) + ' ETH',
                    userAddress,
                    CONTRACTAddress: CONTRACT.address
                });

                // 🔧 PRE-TRANSACTION TEST: Try to estimate gas first
                try {
                    const gasEstimate = await CONTRACT.estimateGas.createToken(name, symbol, { value: totalRequired });
                    console.log('✅ Gas estimate successful:', gasEstimate.toString());
                    showStatus(`Gas estimate: ${gasEstimate.toString()} - proceeding with transaction...`, 'info');
                } catch (gasError) {
                    console.error('❌ Gas estimation failed:', gasError);

                    // Try to extract the revert reason
                    let revertReason = 'Unknown error';
                    if (gasError.reason) {
                        revertReason = gasError.reason;
                    } else if (gasError.message.includes('execution reverted')) {
                        const match = gasError.message.match(/execution reverted: (.+?)["']?$/);
                        revertReason = match ? match[1] : gasError.message;
                    } else if (gasError.data && gasError.data.message) {
                        revertReason = gasError.data.message;
                    } else if (gasError.error && gasError.error.message) {
                        revertReason = gasError.error.message;
                    } else if (gasError.body) {
                        try {
                            const parsed = JSON.parse(gasError.body);
                            revertReason = parsed.error?.message || revertReason;
                        } catch (e) { }
                    }

                    throw new Error(`Transaction would fail: ${revertReason}`);
                }

                // 🛠️ OPTIMIZED GAS STRATEGY: Smart gas estimation with efficiency
                try {
                    console.log('🚀 Attempting to send createToken transaction with optimized gas...');

                    // Get current nonce explicitly to avoid MetaMask queue issues
                    const currentNonce = await provider.getTransactionCount(userAddress, 'pending');
                    console.log('📋 Using nonce:', currentNonce);

                    // Smart gas estimation with 10% buffer for safety
                    let gasLimit;
                    try {
                        const estimatedGas = await CONTRACT.estimateGas.createToken(name, symbol, { value: totalRequired });
                        gasLimit = Math.floor(estimatedGas.toNumber() * 1.1); // 10% buffer
                        console.log('💡 Optimized gas limit:', gasLimit, '(estimated:', estimatedGas.toString(), ')');
                        showStatus(`Optimized gas limit: ${gasLimit} (saved ~${7000000 - gasLimit} gas)`, 'info');
                    } catch (estError) {
                        console.warn('⚠️ Gas estimation failed, using conservative limit');
                        gasLimit = 3500000; // Conservative fallback (50% less than before)
                    }

                    // Get current gas price for Base network optimization
                    const gasPrice = await provider.getGasPrice();
                    console.log('⛽ Current gas price:', ethers.utils.formatUnits(gasPrice, 'gwei'), 'gwei');

                    const txParams = {
                        value: totalRequired,
                        nonce: currentNonce,
                        gasLimit: gasLimit,
                        // Use slightly lower gas price for Base network efficiency
                        gasPrice: gasPrice
                    };

                    console.log('📋 Optimized transaction parameters:', txParams);

                    const tx = await CONTRACT.createToken(name, symbol, txParams);

                    console.log('✅ Transaction sent successfully!');
                    console.log('Transaction hash:', tx.hash);
                    showStatus('Transaction submitted! Waiting for confirmation...', 'info');

                    const receipt = await tx.wait();
                    console.log('✅ Transaction confirmed!', receipt);

                    // Robust success handling: attempt multiple event decodes
                    const decoded = await decodeCreationEvent(receipt, totalRequired);
                    if (decoded) {
                        document.getElementById('tokenForm').reset();
                        await updateDisplays();
                        await refreshDashboards().catch(() => { });
                    } else {
                        showStatus('Token likely created (no event decoded) – verify on explorer.', 'info');
                    }
                } catch (txError) {
                    console.error('❌ Transaction execution error:', txError);
                    console.error('❌ Error code:', txError.code);
                    console.error('❌ Error reason:', txError.reason);
                    console.error('❌ Error message:', txError.message);
                    console.error('❌ Error data:', txError.data);

                    // Check if it's the MetaMask transaction hash error
                    if (txError.message && txError.message.includes('Transaction does not have a transaction hash')) {
                        console.log('🔧 MetaMask transaction queue issue detected');
                        console.log('💡 Solutions:');
                        console.log('1. Go to MetaMask > Settings > Advanced > Reset Account');
                        console.log('2. Or try switching networks and switching back');
                        console.log('3. Or refresh the page and try again');

                        showStatus(`❌ MetaMask Error: Please reset your MetaMask account (Settings > Advanced > Reset Account) and try again`, 'error');

                        // Show user-friendly instructions
                        setTimeout(() => {
                            const resetInstructions = `
                    MetaMask transaction queue is stuck. To fix this:

                    1. Open MetaMask extension
                    2. Go to Settings (gear icon)
                    3. Click "Advanced"
                    4. Click "Reset Account"
                    5. Confirm the reset
                    6. Refresh this page and try again

                    This will clear stuck transactions without affecting your funds.`;

                            if (confirm(resetInstructions + '\n\nClick OK to see detailed instructions, or Cancel to continue.')) {
                                window.open('https://support.metamask.io/hc/en-us/articles/360015488891-How-to-reset-your-MetaMask-wallet', '_blank');
                            }
                        }, 1000);

                        // Re-throw to be handled by outer catch block
                        throw new Error('MetaMask transaction queue error - reset required');
                    }

                    // Log the full error object for debugging
                    console.error('❌ Full error object:', JSON.stringify(txError, null, 2));

                    // Re-throw to be handled by outer catch block
                    throw txError;
                }

            } catch (error) {
                console.error('Create token error:', error);
                console.error('Full error details:', {
                    code: error.code,
                    reason: error.reason,
                    message: error.message,
                    data: error.data,
                    error: error.error,
                    transaction: error.transaction
                });

                let errorMessage = 'Transaction failed';

                if (error.code === 4001 || error.code === 'ACTION_REJECTED') {
                    errorMessage = 'Transaction cancelled by user';
                } else if (error.code === -32603) {
                    // Enhanced -32603 error handling
                    let revertReason = 'Internal JSON-RPC error';

                    // Try multiple ways to extract the revert reason
                    if (error.data && error.data.message) {
                        revertReason = error.data.message;
                    } else if (error.error && error.error.message) {
                        revertReason = error.error.message;
                    } else if (error.reason) {
                        revertReason = error.reason;
                    } else if (error.message.includes('execution reverted')) {
                        const match = error.message.match(/execution reverted:?\s*(.+?)(?:\s*\(|$)/);
                        revertReason = match ? match[1].trim() : 'Contract execution reverted';
                    } else if (error.message.includes('insufficient funds')) {
                        revertReason = 'Insufficient funds for gas or value';
                    } else if (error.body) {
                        try {
                            const parsed = JSON.parse(error.body);
                            revertReason = parsed.error?.message || revertReason;
                        } catch (e) { }
                    }

                    errorMessage = `Contract error: ${revertReason}`;

                } else if (error.message.includes('insufficient funds')) {
                    errorMessage = 'Insufficient ETH balance for transaction + gas';
                } else if (error.message.includes('execution reverted')) {
                    // Try to extract revert reason
                    const match = error.message.match(/execution reverted:?\s*(.+?)(?:\s*\(|$)/);
                    errorMessage = match ? `Contract reverted: ${match[1].trim()}` : 'CONTRACT execution failed';
                } else if (error.message.includes('Transaction would fail')) {
                    errorMessage = error.message; // Use our custom gas estimation error
                } else if (error.reason) {
                    errorMessage = error.reason;
                } else if (error.message.includes('Transaction does not have a transaction hash')) {
                    errorMessage = 'Transaction rejected - check balance and CONTRACT status';
                } else if (error.message) {
                    errorMessage = error.message;
                }

                showStatus(`❌ ${errorMessage}`, 'error');

                // Additional debugging for -32603 errors
                if (error.code === -32603) {
                    console.log('🔍 Enhanced debug info for -32603 error:');
                    console.log('- User address:', userAddress);
                    console.log('- CONTRACT address:', TOKEN_FACTORY_ADDRESS);
                    console.log('- Required ETH:', totalRequired ? ethers.utils.formatEther(totalRequired) : 'undefined');
                    console.log('- User balance:', await provider.getBalance(userAddress).then(b => ethers.utils.formatEther(b)).catch(() => 'unknown'));

                    // Try to get more details about the contract state
                    try {
                        const nonce = await provider.getTransactionCount(userAddress);
                        console.log('- User nonce:', nonce);

                        const gasPrice = await provider.getGasPrice();
                        console.log('- Current gas price:', ethers.utils.formatUnits(gasPrice, 'gwei'), 'gwei');

                        const chainId = await provider.getNetwork().then(n => n.chainId);
                        console.log('- Chain ID:', chainId);

                    } catch (debugError) {
                        console.log('- Debug info error:', debugError.message);
                    }
                }

            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        // Try to decode TokenCreated with multiple possible signatures
        async function decodeCreationEvent(receipt, totalRequired) {
            if (!receipt || !receipt.logs) return false;
            const creationFeeFormatted = (val) => {
                try { return ethers.utils.formatEther(val); } catch { return 'n/a'; }
            };
            const ifaceVariants = [
                new ethers.utils.Interface(["event TokenCreated(address indexed creator,address indexed tokenAddress,string name,string symbol,uint256 tokenId,address pool,uint256 creationFee)"]),
                new ethers.utils.Interface(["event TokenCreated(address indexed creator,address indexed tokenAddress,string name,string symbol,uint256 tokenId,address pool,int24 tickLower,int24 tickUpper)"]),
                new ethers.utils.Interface(["event TokenCreated(address indexed creator,address indexed tokenAddress,string name,string symbol,uint256 tokenId,address pool)"]) // minimal
            ];
            for (const log of receipt.logs) {
                if (log.address.toLowerCase() !== TOKEN_FACTORY_ADDRESS.toLowerCase()) continue;
                for (const iface of ifaceVariants) {
                    try {
                        const parsed = iface.parseLog(log);
                        if (parsed && parsed.name === 'TokenCreated') {
                            let tokenAddress = parsed.args.tokenAddress;
                            let tokenId = parsed.args.tokenId?.toString?.() || '0';
                            let pool = parsed.args.pool || 'unknown';
                            let name = parsed.args.name || '(unknown)';
                            let symbol = parsed.args.symbol || '(unknown)';
                            let creationFee = parsed.args.creationFee ? creationFeeFormatted(parsed.args.creationFee) : (isAllInclusiveFactory ? '0' : 'n/a');
                            showStatus('Token created successfully!', 'success');
                            displaySuccess({
                                tokenAddress,
                                tokenId,
                                name,
                                symbol,
                                pool,
                                creationFee,
                                creator: userAddress,
                                txHash: receipt.transactionHash,
                                actualCost: ethers.utils.formatEther(totalRequired)
                            });

                            // Automatic contract verification
                            setTimeout(() => {
                                verifyTokenContract(tokenAddress, name, symbol, userAddress);
                            }, 3000); // Wait 3 seconds for contract to be fully deployed

                            return true;
                        }
                    } catch (_) { /* try next variant */ }
                }
            }
            return false;
        }

        async function collectAllFees() {
            if (!isAllInclusiveFactory) {
                showStatus('Fee collection not available in legacy factory', 'info');
                return;
            }
            if (!CONTRACT) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            const btn = document.getElementById('collectFeesBtn');
            const originalText = btn.innerHTML;

            try {
                btn.innerHTML = '<span class="loading"></span> Collecting Fees...';
                btn.disabled = true;

                // Get all tokens created by user
                const createdTokens = await getUserTokens(userAddress);

                if (createdTokens.length === 0) {
                    showStatus('No tokens found for your address', 'info');
                    return;
                }

                showStatus(`Found ${createdTokens.length} tokens. Collecting fees...`, 'info');

                let successCount = 0;
                let totalCollected = ethers.BigNumber.from(0);

                // Collect fees from each token with optimized gas
                for (let i = 0; i < createdTokens.length; i++) {
                    try {
                        const tokenId = createdTokens[i].tokenId;

                        // Smart gas estimation for fee collection
                        let gasLimit;
                        try {
                            const estimatedGas = await CONTRACT.estimateGas.collectFees(tokenId);
                            gasLimit = Math.floor(estimatedGas.toNumber() * 1.15); // 15% buffer for safety
                            console.log(`💡 Fee collection gas optimized: ${gasLimit} (estimated: ${estimatedGas})`);
                        } catch (estError) {
                            gasLimit = 200000; // Much lower conservative fallback
                        }

                        const tx = await CONTRACT.collectFees(tokenId, {
                            gasLimit: gasLimit
                        });
                        await tx.wait();
                        successCount++;

                        showStatus(`Collected fees from token ${i + 1}/${createdTokens.length}...`, 'info');
                    } catch (error) {
                        console.warn(`Failed to collect fees for token ${createdTokens[i].tokenId}:`, error);
                    }
                }

                if (successCount > 0) {
                    showStatus(`Successfully collected fees from ${successCount} tokens! 💰`, 'success');
                } else {
                    showStatus('No fees were collected (tokens may not have generated fees yet)', 'info');
                }

                await updateDisplays();
                await refreshDashboards().catch(() => { });

            } catch (error) {
                console.error('Collect fees error:', error);
                showStatus(`Fee collection failed: ${error.reason || error.message}`, 'error');
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        async function withdrawFees() {
            if (!isAllInclusiveFactory) {
                showStatus('Withdraw not available in legacy factory', 'info');
                return;
            }
            if (!CONTRACT) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            const btn = document.getElementById('withdrawFeesBtn');
            const originalText = btn.innerHTML;

            try {
                btn.innerHTML = '<span class="loading"></span> Withdrawing...';
                btn.disabled = true;

                const creatorFees = await CONTRACT.getCreatorFees(userAddress);

                if (creatorFees.eq(0)) {
                    showStatus('No fees available to withdraw', 'info');
                    return;
                }

                showStatus('Please confirm the withdrawal in MetaMask...', 'info');

                const tx = await CONTRACT.withdrawCreatorFees();
                await tx.wait();

                const ethAmount = formatSmallETHAmount(ethers.utils.formatEther(creatorFees));
                showStatus(`Successfully withdrew ${ethAmount}! 💸`, 'success');

                await updateDisplays();

            } catch (error) {
                console.error('Withdraw error:', error);
                showStatus(`Withdrawal failed: ${error.reason || error.message}`, 'error');
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        function showStatus(message, type) {
            const container = document.getElementById('statusContainer');
            const statusDiv = document.createElement('div');

            // Check if mobile
            const isMobile = window.innerWidth <= 768;

            // Professional notification styling with mobile responsiveness
            statusDiv.className = `status status-${type}`;
            statusDiv.style.cssText = `
                margin-bottom: 12px;
                padding: ${isMobile ? '14px 16px' : '16px 20px'};
                border-radius: 12px;
                font-weight: 500;
                font-size: ${isMobile ? '0.85rem' : '0.9rem'};
                line-height: 1.4;
                box-shadow: 0 4px 20px rgba(0,0,0,0.15);
                backdrop-filter: blur(10px);
                transform: ${isMobile ? 'translateY(-100%)' : 'translateX(100%)'};
                transition: all 0.3s ease;
                cursor: pointer;
                position: relative;
                overflow: hidden;
                width: 100%;
                box-sizing: border-box;
            `;

            // Set colors based on type
            if (type === 'success') {
                statusDiv.style.background = 'linear-gradient(135deg, rgba(34, 197, 94, 0.95), rgba(16, 185, 129, 0.95))';
                statusDiv.style.border = '1px solid rgba(34, 197, 94, 0.3)';
                statusDiv.style.color = '#ffffff';
            } else if (type === 'error') {
                statusDiv.style.background = 'linear-gradient(135deg, rgba(239, 68, 68, 0.95), rgba(220, 38, 38, 0.95))';
                statusDiv.style.border = '1px solid rgba(239, 68, 68, 0.3)';
                statusDiv.style.color = '#ffffff';
            } else {
                statusDiv.style.background = 'linear-gradient(135deg, rgba(59, 130, 246, 0.95), rgba(37, 99, 235, 0.95))';
                statusDiv.style.border = '1px solid rgba(59, 130, 246, 0.3)';
                statusDiv.style.color = '#ffffff';
            }

            statusDiv.textContent = message;

            // Add close button
            const closeBtn = document.createElement('span');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.cssText = `
                position: absolute;
                top: 8px;
                right: 12px;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                opacity: 0.7;
                transition: opacity 0.2s ease;
            `;
            closeBtn.onmouseover = () => closeBtn.style.opacity = '1';
            closeBtn.onmouseout = () => closeBtn.style.opacity = '0.7';
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                removeNotification(statusDiv);
            };
            statusDiv.appendChild(closeBtn);

            container.appendChild(statusDiv);

            // Animate in with appropriate direction for mobile/desktop
            setTimeout(() => {
                statusDiv.style.transform = isMobile ? 'translateY(0)' : 'translateX(0)';
            }, 10);

            // Auto-remove after delay
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    removeNotification(statusDiv);
                }, 6000);
            } else {
                setTimeout(() => {
                    removeNotification(statusDiv);
                }, 4000);
            }
        }

        function removeNotification(statusDiv) {
            if (statusDiv && statusDiv.parentNode) {
                const isMobile = window.innerWidth <= 768;
                statusDiv.style.transform = isMobile ? 'translateY(-100%)' : 'translateX(100%)';
                statusDiv.style.opacity = '0';
                setTimeout(() => {
                    if (statusDiv.parentNode) {
                        statusDiv.parentNode.removeChild(statusDiv);
                    }
                }, 300);
            }
        }

        function displaySuccess(details) {
            const container = document.getElementById('successDetails');

            container.innerHTML = `
                <div class="card">
                    <div class="card-title">Token Created Successfully</div>
                    <div class="success-details">
                        <div class="success-item">
                            <span class="success-label">Token Name:</span>
                            <span class="success-value">${details.name}</span>
                        </div>
                        <div class="success-item">
                            <span class="success-label">Symbol:</span>
                            <span class="success-value">${details.symbol}</span>
                        </div>
                        <div class="success-item">
                            <span class="success-label">Token Address:</span>
                            <span class="success-value">
                                <a href="${EXPLORER_URL}/address/${details.tokenAddress}" target="_blank" class="link-button">
                                    ${details.tokenAddress}
                                </a>
                            </span>
                        </div>
                        <div class="success-item">
                            <span class="success-label">LP Token ID:</span>
                            <span class="success-value">${details.tokenId}</span>
                        </div>
                        <div class="success-item">
                            <span class="success-label">LP NFT Owner:</span>
                            <span class="success-value" id="lpOwnerValue">${details.tokenId && details.tokenId !== '0' ? 'Checking...' : 'N/A'}</span>
                        </div>
                        <div class="success-item">
                            <span class="success-label">Lock Status:</span>
                            <span class="success-value" id="lpLockStatus">${details.tokenId && details.tokenId !== '0' ? '—' : 'No LP Position'}</span>
                        </div>
                        <div class="success-item">
                            <span class="success-label">Pool Address:</span>
                            <span class="success-value">
                                <a href="${EXPLORER_URL}/address/${details.pool}" target="_blank" class="link-button">
                                    ${details.pool}
                                </a>
                            </span>
                        </div>
                        <div class="success-item">
                            <span class="success-label">Creation Fee:</span>
                            <span class="success-value" id="creationFeeValue">${details.creationFee} ETH</span>
                        </div>
                        <div class="success-item">
                            <span class="success-label">Transaction:</span>
                            <span class="success-value">
                                <a href="${EXPLORER_URL}/tx/${details.txHash}" target="_blank" class="link-button">
                                    View on BaseScan
                                </a>
                            </span>
                        </div>
                    </div>
                    <div style="margin-top: 16px; padding: 12px; background: #f0fff4; border-radius: 8px; border: 1px solid #9ae6b4; color: #22543d; font-size: 0.9rem;">
                        <strong>Next Steps:</strong><br>
                        Your token is created.
                        <div style="margin-top: 10px; display:flex; gap:12px; flex-wrap:wrap; justify-content:center; align-items:center;">
                            <button onclick="resetForm()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600;">Create Another Token</button>
                            <button onclick="window.open(EXPLORER_URL + '/address/' + details.tokenAddress, '_blank')" style="background: linear-gradient(135deg, #0070f3, #0051cc, #003d99); background-size: 300% 300%; color:#fff; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; font-weight:600; transition: all 0.3s ease;">View Token on Explorer</button>
                            <button id="recheckLpBtn" onclick="manualRecheckLP(${details.tokenId}, '${details.creator || ''}')" style="background:#1d6fa5;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-weight:600;">Re-check LP Owner</button>
                        </div>
                    </div>
                </div>
            `;

            container.style.display = 'block';
            if (details.tokenId && details.tokenId !== '0') {
                // Delay a bit in case position mint finalizes after event
                scheduleLPOwnerRetries(details.tokenId, details.creator, 0);
            }
            // Backfill creation fee if event variant lacked it but CONTRACT supports
            if ((details.creationFee === 'n/a' || details.creationFee === '0' || !details.creationFee) && capability.creationFee && CONTRACT) {
                CONTRACT.getCreationFeeETH().then(f => {
                    const el = document.getElementById('creationFeeValue');
                    if (el) el.textContent = parseFloat(ethers.utils.formatEther(f)).toFixed(6) + ' ETH';
                }).catch(() => { });
            }

            // Show Uniswap modal for initial buy
            setTimeout(() => showUniswapModal(details.tokenAddress, details.name, details.symbol), 1000);
        }

        async function checkLPOwner(tokenId, creatorAddr) {
            if (!provider) return false;
            const ownerEl = document.getElementById('lpOwnerValue');
            const lockEl = document.getElementById('lpLockStatus');
            try {
                const nfpm = new ethers.Contract(POSITION_MANAGER_ADDRESS, ["function ownerOf(uint256) view returns (address)"], provider);
                const ownerAddr = await nfpm.ownerOf(tokenId);
                let vaultAddr = ethers.constants.AddressZero;
                try { if (hasMethod('lpVault')) { vaultAddr = await CONTRACT.lpVault(); } } catch { }
                const factoryAddr = TOKEN_FACTORY_ADDRESS;
                if (ownerEl) ownerEl.textContent = ownerAddr;
                if (lockEl) {
                    let status;
                    if (vaultAddr && vaultAddr !== ethers.constants.AddressZero && ownerAddr.toLowerCase() === vaultAddr.toLowerCase()) {
                        status = 'Locked in Vault ✅';
                    } else if (ownerAddr.toLowerCase() === factoryAddr.toLowerCase()) {
                        // For AllTokensToLPFactory, there's no vault - NFTs are locked in factory
                        status = 'Factory Custody 🔒';
                    } else if (creatorAddr && ownerAddr.toLowerCase() === creatorAddr.toLowerCase()) {
                        status = 'UNSAFE: Creator Holds LP ❌';
                        showRiskBanner('LP NFT currently held by creator. Fees & lock protections not enforced.');
                    } else {
                        status = 'External Holder: ' + ownerAddr.slice(0, 6) + '...' + ownerAddr.slice(-4);
                        showRiskBanner('LP NFT is held by an external address. Verify custody.');
                    }
                    lockEl.textContent = status;
                }
                return true;
            } catch (e) {
                if (ownerEl && ownerEl.textContent === 'Checking...') ownerEl.textContent = 'Unavailable';
                if (lockEl && (lockEl.textContent === '—' || lockEl.textContent === 'No LP Position')) lockEl.textContent = 'Error';
                return false;
            }
        }

        function showRiskBanner(message) {
            try {
                const banner = document.getElementById('riskBanner');
                if (!banner) return;
                const textEl = document.getElementById('riskBannerText');
                if (textEl && message) textEl.textContent = message;
                banner.style.display = 'block';
            } catch { }
        }

        function scheduleLPOwnerRetries(tokenId, creatorAddr, attempt) {
            if (attempt > 6) return; // stop after 7 attempts (~7s total)
            checkLPOwner(tokenId, creatorAddr).then(ok => {
                if (!ok) setTimeout(() => scheduleLPOwnerRetries(tokenId, creatorAddr, attempt + 1), 1000);
            });
        }

        function manualRecheckLP(tokenId, creatorAddr) {
            const ownerEl = document.getElementById('lpOwnerValue');
            const lockEl = document.getElementById('lpLockStatus');
            if (ownerEl) ownerEl.textContent = 'Re-checking...';
            if (lockEl) lockEl.textContent = '…';
            scheduleLPOwnerRetries(tokenId, creatorAddr, 0);
        }

        // Detect if factory supports fee collection by probing getCreatorFees
        async function detectFactoryType() {
            if (!CONTRACT || capability.probed) return;
            capability.probed = true;

            // Try new CONTRACT methods
            if (CONTRACT.functions && CONTRACT.functions.getCreatorFees) {
                try {
                    await CONTRACT.callStatic.getCreatorFees('0x0000000000000000000000000000000000000001');
                    capability.creatorFees = true;
                    isAllInclusiveFactory = true; // New CONTRACT detected
                    console.log('✅ New CONTRACT with fee collection detected');
                } catch {
                    capability.creatorFees = false;
                }
            }

            // Legacy probes for backwards compatibility
            try { await CONTRACT.callStatic.getCreationFeeETH(); capability.creationFee = true; } catch { }
            try { await CONTRACT.callStatic.getGasReserve(); capability.gasReserve = true; } catch { }

            // Set factory type based on any capability
            if (!isAllInclusiveFactory) {
                isAllInclusiveFactory = capability.creationFee; // Legacy detection
            }

            console.log('Factory probe:', JSON.stringify(capability));
        }

        function hasMethod(name) {
            return CONTRACT && CONTRACT.functions && Object.prototype.hasOwnProperty.call(CONTRACT.functions, name);
        }

        function resetForm() {
            // Hide success message
            document.getElementById('successContainer').style.display = 'none';

            // Clear form fields
            document.getElementById('tokenName').value = '';
            document.getElementById('tokenSymbol').value = '';
            document.getElementById('tokenDescription').value = '';
            document.getElementById('websiteUrl').value = '';
            document.getElementById('telegramUrl').value = '';
            document.getElementById('twitterUrl').value = '';

            // Clear status
            document.getElementById('status').style.display = 'none';

            // Show form again
            document.querySelector('.container').scrollIntoView({ behavior: 'smooth' });
        }

        // Uniswap Modal Functions
        function showUniswapModal(tokenAddress, tokenName, tokenSymbol) {
            const modal = document.getElementById('uniswapModal');
            const container = document.getElementById('uniswapWidgetContainer');
            const detailsContainer = document.getElementById('tokenDetailsContainer');

            // Create token details section with all required information
            detailsContainer.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-weight: 700; color: #2d3748; font-size: 1.2rem; margin-bottom: 8px;">${tokenName} (${tokenSymbol})</div>
                    <div style="font-size: 0.85rem; color: #4a5568; margin-bottom: 16px;">Your new token is ready for trading!</div>
                </div>
                
                <div style="display: grid; gap: 12px; margin-bottom: 16px;">
                    <div style="background: white; padding: 12px; border-radius: 8px; border: 1px solid #e2e8f0;">
                        <div style="font-weight: 600; color: #2d3748; margin-bottom: 4px; font-size: 0.9rem;">📄 Contract Address</div>
                        <div style="background: #f7fafc; padding: 8px; border-radius: 4px; color: #2d3748; word-break: break-all; border: 1px solid #e2e8f0;">
                            ${tokenAddress}
                        </div>
                        <button onclick="copyToClipboard('${tokenAddress}')" style="margin-top: 6px; background: #4299e1; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">
                            Copy Address
                        </button>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 16px;">
                    <a href="https://basescan.org/address/${tokenAddress}" target="_blank" style="display: block; background: #667eea; color: white; padding: 10px; border-radius: 8px; text-decoration: none; text-align: center; font-size: 0.85rem; font-weight: 600;">
                        🔍 View on BaseScan
                    </a>
                    <button onclick="openUniswapTrade('${tokenAddress}')" style="background: #ff006a; color: white; border: none; padding: 10px; border-radius: 8px; font-size: 0.85rem; font-weight: 600; cursor: pointer;">
                        🦄 Buy on Uniswap
                    </button>
                </div>
                
                <div style="text-align: center; font-size: 0.8rem; color: #666; margin-top: 12px;">
                    ⚡ Links open in new tabs for easy access
                </div>
            `;

            // Create simplified Uniswap widget info
            container.innerHTML = `
                <div style="background: linear-gradient(135deg, #ff006a, #ff4081); border-radius: 12px; padding: 16px; margin: 16px 0; color: white; text-align: center;">
                    <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 8px;">🚀 Ready to Trade!</div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">
                        Click "Make Initial Buy" to secure your position during the exclusive window
                    </div>
                </div>
            `;

            modal.style.display = 'flex';

            // Start countdown timer (5 minutes = 300 seconds)
            startCountdownTimer(300);

            // Set up button handlers
            document.getElementById('makeInitialBuyBtn').onclick = () => {
                openUniswapTrade(tokenAddress);
            };

            document.getElementById('skipBuyBtn').onclick = () => {
                hideUniswapModal();
                showShareOptions(tokenAddress, tokenName, tokenSymbol);
            };

            document.getElementById('closeUniswapModal').onclick = () => {
                hideUniswapModal();
            };

            // Close on background click
            modal.onclick = (e) => {
                if (e.target === modal) {
                    hideUniswapModal();
                }
            };
        }

        function hideUniswapModal() {
            // Clear countdown timer
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            document.getElementById('uniswapModal').style.display = 'none';
        }

        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    // Show temporary success feedback
                    const event = new CustomEvent('showToast', {
                        detail: { message: 'Address copied to clipboard!', type: 'success' }
                    });
                    document.dispatchEvent(event);
                }).catch(() => {
                    // Fallback for older browsers
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                alert('Address copied to clipboard!');
            } catch (err) {
                alert('Copy failed. Please manually copy: ' + text);
            }
            document.body.removeChild(textArea);
        }

        let countdownInterval;
        function startCountdownTimer(seconds) {
            // Clear any existing timer
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            const countdownElement = document.getElementById('countdownTimer');
            if (!countdownElement) return;

            const updateTimer = () => {
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                const timeString = `${minutes}:${secs.toString().padStart(2, '0')}`;

                if (seconds > 60) {
                    countdownElement.innerHTML = `${timeString} remaining`;
                    countdownElement.style.color = '#d44a11';
                    countdownElement.style.animation = 'pulse 2s infinite';
                } else if (seconds > 30) {
                    countdownElement.innerHTML = `${timeString} remaining`;
                    countdownElement.style.color = '#e53e3e';
                    countdownElement.style.animation = 'pulse 1.5s infinite';
                } else if (seconds > 0) {
                    countdownElement.innerHTML = `⚠️ ${timeString} remaining!`;
                    countdownElement.style.color = '#c53030';
                    countdownElement.style.animation = 'pulse 1s infinite';
                } else {
                    countdownElement.innerHTML = `🔓 Public Trading Activated!`;
                    countdownElement.style.color = '#38a169';
                    countdownElement.style.animation = 'none';
                    clearInterval(countdownInterval);
                    return;
                }

                seconds--;
            };

            updateTimer(); // Initial call
            countdownInterval = setInterval(updateTimer, 1000);
        }

        function openUniswapTrade(tokenAddress) {
            // Open Uniswap interface with the token pre-selected
            const uniswapUrl = `https://app.uniswap.org/swap?chain=base&inputCurrency=ETH&outputCurrency=${tokenAddress}`;
            window.open(uniswapUrl, '_blank');
            hideUniswapModal();
        }

        function showShareOptions(tokenAddress, tokenName, tokenSymbol) {
            const container = document.getElementById('statusContainer');
            container.innerHTML = `
                <div style="background: #f0fff4; border: 1px solid #9ae6b4; border-radius: 8px; padding: 16px; margin: 16px 0;">
                    <h4 style="margin: 0 0 12px 0; color: #22543d; text-align: center;">Share Your Token</h4>
                    <p style="margin: 0 0 16px 0; color: #2f855a;">
                        Your token "${tokenName}" (${tokenSymbol}) is ready! Share it with others so they can make the first trade:
                    </p>
                    <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #c6f6d5; margin-bottom: 12px;">
                        <strong>Token Address:</strong><br>
                        <code style="font-size: 0.9rem; word-break: break-all;">${tokenAddress}</code>
                    </div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button onclick="navigator.clipboard.writeText('${tokenAddress}')" class="btn btn-secondary">Copy Address</button>
                        <button onclick="window.open('https://app.uniswap.org/swap?chain=base&inputCurrency=ETH&outputCurrency=${tokenAddress}', '_blank')" class="btn btn-primary">View on Uniswap</button>
                        <button onclick="window.open('${EXPLORER_URL}/address/${tokenAddress}', '_blank')" class="btn btn-secondary">View on Explorer</button>
                    </div>
                </div>
            `;
        }

        // Check for actual trading activity and fee events
        async function checkTradingActivity() {
            console.log('📈 CHECKING TRADING ACTIVITY AND FEE EVENTS 📈');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            try {
                const userTokens = await getUserTokens(userAddress);
                console.log(`Checking trading activity for first 3 tokens...`);

                for (let i = 0; i < Math.min(userTokens.length, 3); i++) {
                    const tokenData = userTokens[i];
                    const tokenId = Array.isArray(tokenData) ? tokenData[4] : tokenData.tokenId;
                    const tokenName = Array.isArray(tokenData) ? tokenData[2] : tokenData.name;
                    const tokenAddr = Array.isArray(tokenData) ? tokenData[0] : tokenData.tokenAddress;
                    const poolAddr = Array.isArray(tokenData) ? tokenData[6] : tokenData.pool;

                    console.log(`\n🪙 ${tokenName} (${tokenAddr})`);
                    console.log(`  🏊 Pool: ${poolAddr}`);
                    console.log(`  🆔 LP NFT ID: ${tokenId}`);

                    if (!poolAddr || poolAddr === '0x0000000000000000000000000000000000000000') {
                        console.log('  ❌ No pool address - skipping');
                        continue;
                    }

                    try {
                        // Check for recent FeesCollected events from your CONTRACT
                        console.log(`  🔍 Checking CONTRACT FeesCollected events...`);
                        const feeFilter = CONTRACT.filters.FeesCollected(tokenId);
                        const feeEvents = await CONTRACT.queryFilter(feeFilter, -2000); // Last ~2000 blocks

                        console.log(`  📊 FeesCollected events found: ${feeEvents.length}`);
                        for (const event of feeEvents) {
                            const { ethAmount, tokenAmount, swappedETH } = event.args;
                            console.log(`    💰 Event: ${ethers.utils.formatEther(ethAmount)} ETH, ${ethers.utils.formatEther(tokenAmount)} tokens, ${ethers.utils.formatEther(swappedETH)} swapped ETH`);
                            console.log(`    📅 Block: ${event.blockNumber}`);
                        }

                        // Check pool for Swap events (trading activity)
                        console.log(`  🔍 Checking pool for Swap events...`);
                        const poolCONTRACT = new ethers.Contract(poolAddr, [
                            "event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick)"
                        ], provider);

                        const swapFilter = poolCONTRACT.filters.Swap();
                        const swapEvents = await poolCONTRACT.queryFilter(swapFilter, -500); // Last ~500 blocks

                        console.log(`  🔄 Swap events found: ${swapEvents.length}`);

                        if (swapEvents.length > 0) {
                            console.log(`  ✅ Trading activity detected!`);
                            for (let j = 0; j < Math.min(swapEvents.length, 3); j++) {
                                const swap = swapEvents[j];
                                const { amount0, amount1 } = swap.args;
                                console.log(`    🔄 Swap ${j + 1}: ${ethers.utils.formatEther(amount0.abs())} token0, ${ethers.utils.formatEther(amount1.abs())} token1`);
                                console.log(`    📅 Block: ${swap.blockNumber}`);
                            }

                            console.log(`  🤔 WHY NO FEES? Possible reasons:`);
                            console.log(`    - Fees were already collected by someone else`);
                            console.log(`    - Fee tier is wrong (1% is very high)`);
                            console.log(`    - LP position is not earning fees properly`);
                            console.log(`    - Someone else owns the LP NFT`);

                        } else {
                            console.log(`  📭 No recent swap activity in this pool`);
                        }

                        // Check who actually owns the LP NFT right now
                        console.log(`  🎫 Checking current LP NFT ownership...`);
                        const positionManager = new ethers.Contract(POSITION_MANAGER_ADDRESS, [
                            "function ownerOf(uint256) view returns (address)"
                        ], provider);

                        const currentOwner = await positionManager.ownerOf(tokenId);
                        console.log(`  👤 Current NFT owner: ${currentOwner}`);
                        console.log(`  🏭 Expected (factory): ${TOKEN_FACTORY_ADDRESS}`);
                        console.log(`  🤔 Ownership correct: ${currentOwner.toLowerCase() === TOKEN_FACTORY_ADDRESS.toLowerCase()}`);

                        if (currentOwner.toLowerCase() !== TOKEN_FACTORY_ADDRESS.toLowerCase()) {
                            console.log(`  🚨 PROBLEM: LP NFT is not owned by the factory!`);
                            console.log(`  💡 This means fees are going to ${currentOwner} instead of you!`);
                        }

                    } catch (eventError) {
                        console.log(`  ❌ Error checking events: ${eventError.message}`);
                    }
                }

                console.log(`\n💡 TRADING ACTIVITY ANALYSIS COMPLETE`);
                console.log(`Key findings:`);
                console.log(`- If Swap events exist but no fees: LP NFT ownership or fee collection issue`);
                console.log(`- If no Swap events: Trading happened elsewhere or not at all`);
                console.log(`- If FeesCollected events exist: Fees were collected but went somewhere else`);

                alert('Trading activity check complete! Check console for detailed analysis of swaps and fee events.');

            } catch (error) {
                console.error('❌ Trading activity check failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Check what Uniswap actually shows for accumulated fees
        async function checkUniswapFees() {
            console.log('🦄 CHECKING ACTUAL UNISWAP V3 FEES 🦄');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            try {
                const userTokens = await getUserTokens(userAddress);
                console.log(`Checking first 3 tokens for actual Uniswap fees...`);

                const positionManager = new ethers.Contract(POSITION_MANAGER_ADDRESS, [
                    "function positions(uint256) view returns (uint96,address,address,address,uint24,int24,int24,uint128,uint256,uint256,uint128,uint128)",
                    "function collect((uint256,address,uint128,uint128)) external returns (uint256,uint256)"
                ], provider);

                for (let i = 0; i < Math.min(userTokens.length, 3); i++) {
                    const tokenData = userTokens[i];
                    const tokenId = Array.isArray(tokenData) ? tokenData[4] : tokenData.tokenId;
                    const tokenName = Array.isArray(tokenData) ? tokenData[2] : tokenData.name;
                    const tokenAddr = Array.isArray(tokenData) ? tokenData[0] : tokenData.tokenAddress;

                    console.log(`\n🪙 ${tokenName} (ID: ${tokenId})`);

                    try {
                        // Get the full position data from Uniswap
                        const position = await positionManager.positions(tokenId);

                        const nonce = position[0];           // uint96 nonce
                        const operator = position[1];       // address operator  
                        const token0 = position[2];         // address token0
                        const token1 = position[3];         // address token1
                        const fee = position[4];            // uint24 fee
                        const tickLower = position[5];      // int24 tickLower
                        const tickUpper = position[6];      // int24 tickUpper
                        const liquidity = position[7];      // uint128 liquidity
                        const feeGrowthInside0LastX128 = position[8]; // uint256
                        const feeGrowthInside1LastX128 = position[9]; // uint256
                        const tokensOwed0 = position[10];   // uint128 tokensOwed0 (FEES!)
                        const tokensOwed1 = position[11];   // uint128 tokensOwed1 (FEES!)

                        console.log(`  📊 Position Details:`);
                        console.log(`    Token0: ${token0}`);
                        console.log(`    Token1: ${token1}`);
                        console.log(`    Fee Tier: ${fee / 10000}%`);
                        console.log(`    Liquidity: ${liquidity.toString()}`);
                        console.log(`    📈 Tokens Owed 0: ${tokensOwed0.toString()}`);
                        console.log(`    📈 Tokens Owed 1: ${tokensOwed1.toString()}`);

                        // Figure out which token is which
                        const isToken0 = token0.toLowerCase() === tokenAddr.toLowerCase();
                        const isToken1 = token1.toLowerCase() === tokenAddr.toLowerCase();
                        const isWETH0 = token0.toLowerCase() === '0x4200000000000000000000000000000000000006'.toLowerCase();
                        const isWETH1 = token1.toLowerCase() === '0x4200000000000000000000000000000000000006'.toLowerCase();

                        console.log(`    🔍 Token Analysis:`);
                        console.log(`      Your token is token0: ${isToken0}`);
                        console.log(`      Your token is token1: ${isToken1}`);
                        console.log(`      WETH is token0: ${isWETH0}`);
                        console.log(`      WETH is token1: ${isWETH1}`);

                        // Calculate fees in readable format
                        let tokenFees = "0";
                        let ethFees = "0";

                        if (isToken0) {
                            tokenFees = ethers.utils.formatEther(tokensOwed0);
                            ethFees = ethers.utils.formatEther(tokensOwed1);
                        } else if (isToken1) {
                            tokenFees = ethers.utils.formatEther(tokensOwed1);
                            ethFees = ethers.utils.formatEther(tokensOwed0);
                        }

                        console.log(`    💰 Accumulated Fees:`);
                        console.log(`      Your Token Fees: ${tokenFees} tokens`);
                        console.log(`      WETH Fees: ${ethFees} WETH`);

                        // Check if fees meet the minimum threshold
                        const tokenFeesNum = parseFloat(tokenFees);
                        const ethFeesNum = parseFloat(ethFees);

                        if (tokenFeesNum > 0 || ethFeesNum > 0) {
                            console.log(`    🎉 FEES FOUND! But why isn't collectFees() getting them?`);

                            if (tokenFeesNum < 1000) {
                                console.log(`    ⚠️ Token fees (${tokenFeesNum}) below MIN_SWAP_AMOUNT (1000)`);
                                console.log(`    💡 CONTRACT ignores token fees below 1000 tokens`);
                            }

                            if (ethFeesNum > 0) {
                                console.log(`    ✅ ETH fees should be collected directly`);
                            }

                        } else {
                            console.log(`    📭 No accumulated fees in Uniswap position`);
                        }

                    } catch (posError) {
                        console.log(`    ❌ Error getting position data: ${posError.message}`);
                    }
                }

                console.log(`\n💡 UNISWAP FEE ANALYSIS COMPLETE`);
                console.log(`If fees show here but collectFees() doesn't get them:`);
                console.log(`- Token fees might be below 1000 token minimum`);
                console.log(`- There might be a bug in the CONTRACT's collect logic`);
                console.log(`- The position might not be owned by the factory`);

                alert('Uniswap fee check complete! Check console for detailed fee analysis.');

            } catch (error) {
                console.error('❌ Uniswap fee check failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Deep analysis of trading patterns and volume calculations
        async function deepTradingAnalysis() {
            console.log('🔬 DEEP TRADING ANALYSIS STARTED 🔬');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            try {
                const userTokens = await getUserTokens(userAddress);
                console.log(`Performing deep analysis on first 3 tokens...`);

                let totalCalculatedVolume = 0;
                let totalSwapEvents = 0;

                for (let i = 0; i < Math.min(userTokens.length, 3); i++) {
                    const tokenData = userTokens[i];
                    const tokenId = Array.isArray(tokenData) ? tokenData[4] : tokenData.tokenId;
                    const tokenName = Array.isArray(tokenData) ? tokenData[2] : tokenData.name;
                    const tokenAddr = Array.isArray(tokenData) ? tokenData[0] : tokenData.tokenAddress;
                    const poolAddr = Array.isArray(tokenData) ? tokenData[6] : tokenData.pool;

                    console.log(`\n🔬 ANALYZING ${tokenName} (${tokenAddr})`);
                    console.log(`📊 Pool: ${poolAddr}`);

                    if (!poolAddr || poolAddr === '0x0000000000000000000000000000000000000000') {
                        console.log('❌ No pool - skipping');
                        continue;
                    }

                    try {
                        // Get pool info for price calculation
                        const poolCONTRACT = new ethers.Contract(poolAddr, [
                            "function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)",
                            "function token0() external view returns (address)",
                            "function token1() external view returns (address)",
                            "function fee() external view returns (uint24)",
                            "event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick)"
                        ], provider);

                        const [slot0, token0, token1, feeLevel] = await Promise.all([
                            poolCONTRACT.slot0(),
                            poolCONTRACT.token0(),
                            poolCONTRACT.token1(),
                            poolCONTRACT.fee()
                        ]);

                        console.log(`🎯 Token0: ${token0}`);
                        console.log(`🎯 Token1: ${token1}`);
                        console.log(`💰 Fee Level: ${feeLevel / 10000}%`);
                        console.log(`📈 Current Price (sqrtPriceX96): ${slot0.sqrtPriceX96}`);

                        // Calculate actual price from sqrtPriceX96
                        const sqrtPrice = slot0.sqrtPriceX96;
                        const price = (parseFloat(sqrtPrice.toString()) / (2 ** 96)) ** 2;
                        console.log(`💵 Calculated Price: ${price.toExponential(6)}`);

                        // Get historical swap events with wider range
                        console.log(`🔍 Searching for swap events (last 5000 blocks)...`);
                        const swapFilter = poolCONTRACT.filters.Swap();
                        const swapEvents = await poolCONTRACT.queryFilter(swapFilter, -5000);

                        console.log(`📈 Total swap events found: ${swapEvents.length}`);
                        totalSwapEvents += swapEvents.length;

                        if (swapEvents.length > 0) {
                            let tokenVolume = 0;

                            console.log(`\n📊 VOLUME CALCULATION:`);
                            for (let j = 0; j < swapEvents.length; j++) {
                                const swap = swapEvents[j];
                                const { amount0, amount1, sqrtPriceX96: swapPrice } = swap.args;

                                // Calculate volumes - use absolute values
                                const vol0 = Math.abs(parseFloat(ethers.utils.formatEther(amount0)));
                                const vol1 = Math.abs(parseFloat(ethers.utils.formatEther(amount1)));

                                // Use the larger volume as trade size
                                const tradeVolume = Math.max(vol0, vol1);
                                tokenVolume += tradeVolume;

                                if (j < 5) { // Show first 5 for analysis
                                    console.log(`  Swap ${j + 1}: ${vol0.toFixed(6)} token0, ${vol1.toFixed(6)} token1, Trade Size: ${tradeVolume.toFixed(6)}`);
                                    console.log(`    Block: ${swap.blockNumber}, Price: ${swapPrice}`);
                                }
                            }

                            console.log(`\n💰 ${tokenName} VOLUME SUMMARY:`);
                            console.log(`  Total Volume: ${tokenVolume.toFixed(6)} tokens`);
                            console.log(`  Average per swap: ${(tokenVolume / swapEvents.length).toFixed(6)}`);

                            // Estimate USD value (very rough - assumes 1 token ≈ some ETH value)
                            // This is a rough estimation - you'd need actual price data
                            const estimatedUSDVolume = tokenVolume * 0.001; // Very rough estimate
                            console.log(`  Estimated USD Volume: ~$${estimatedUSDVolume.toFixed(2)} (VERY ROUGH ESTIMATE)`);

                            totalCalculatedVolume += estimatedUSDVolume;

                            // Calculate expected fees
                            const feeRate = feeLevel / 1000000; // Convert basis points to decimal
                            const expectedFeesInTokens = tokenVolume * feeRate;
                            console.log(`  Expected fees (${feeRate * 100}%): ${expectedFeesInTokens.toFixed(6)} tokens`);

                            // Check if this matches your claimed volume
                            if (estimatedUSDVolume > 50) {
                                console.log(`  🚨 HIGH VOLUME DETECTED! This token shows significant trading.`);
                                console.log(`  🤔 Yet fees are zero - investigating further...`);

                                // Check historical fee collection events more thoroughly
                                console.log(`  🔎 Checking historical fee collections...`);
                                const feeFilter = CONTRACT.filters.FeesCollected(tokenId);
                                const feeEvents = await CONTRACT.queryFilter(feeFilter, 0); // All time

                                console.log(`  📊 Total FeesCollected events: ${feeEvents.length}`);
                                for (const event of feeEvents) {
                                    const { ethAmount, tokenAmount, swappedETH } = event.args;
                                    console.log(`    💸 Previous collection: ${ethers.utils.formatEther(ethAmount)} ETH, ${ethers.utils.formatEther(tokenAmount)} tokens`);
                                    console.log(`    📅 Block: ${event.blockNumber}`);
                                }
                            }

                        } else {
                            console.log(`📭 No swap events found for ${tokenName}`);
                        }

                    } catch (poolError) {
                        console.log(`❌ Pool analysis error: ${poolError.message}`);
                    }
                }

                console.log(`\n🎯 DEEP ANALYSIS SUMMARY:`);
                console.log(`📊 Total swap events across all tokens: ${totalSwapEvents}`);
                console.log(`💰 Total estimated volume: ~$${totalCalculatedVolume.toFixed(2)}`);
                console.log(`🤔 Your claim: $200 volume`);
                console.log(`📈 Calculated vs Claimed: ${((totalCalculatedVolume / 200) * 100).toFixed(1)}%`);

                if (totalCalculatedVolume < 50) {
                    console.log(`\n🚨 CONCLUSION: Low calculated volume suggests:`);
                    console.log(`  1. Trading happened on different pools/DEXs`);
                    console.log(`  2. Volume calculation method needs adjustment`);
                    console.log(`  3. Most activity was before the analyzed timeframe`);
                    console.log(`  4. Volume might be inflated or on different tokens`);
                } else {
                    console.log(`\n🚨 CONCLUSION: High volume with zero fees suggests:`);
                    console.log(`  1. Someone else collected the fees already`);
                    console.log(`  2. LP NFT ownership issue`);
                    console.log(`  3. Fee collection mechanism problem`);
                    console.log(`  4. Fees stuck in Uniswap position`);
                }

                alert('Deep trading analysis complete! Check console for detailed volume calculations and conclusions.');

            } catch (error) {
                console.error('❌ Deep analysis failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Analyze specific token for trading activity
        async function analyzeSpecificToken() {
            console.log('🎯 ANALYZING SPECIFIC TOKEN 🎯');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            const targetToken = '0xfE63785eEB6117259FEbd92E95d597F683950C29';
            console.log(`🔍 Searching for token: ${targetToken}`);

            try {
                const userTokens = await getUserTokens(userAddress);
                console.log(`📊 Total user tokens: ${userTokens.length}`);

                // Find the specific token
                let targetTokenData = null;
                for (let i = 0; i < userTokens.length; i++) {
                    const tokenData = userTokens[i];
                    const tokenAddr = Array.isArray(tokenData) ? tokenData[0] : tokenData.tokenAddress;

                    if (tokenAddr.toLowerCase() === targetToken.toLowerCase()) {
                        targetTokenData = tokenData;
                        console.log(`✅ Found target token at index ${i}`);
                        break;
                    }
                }

                if (!targetTokenData) {
                    console.log(`❌ Token ${targetToken} not found in your created tokens`);
                    alert(`Token ${targetToken} not found in your created tokens list. Make sure this token was created through this platform.`);
                    return;
                }

                const tokenId = Array.isArray(targetTokenData) ? targetTokenData[4] : targetTokenData.tokenId;
                const tokenName = Array.isArray(targetTokenData) ? targetTokenData[2] : targetTokenData.name;
                const poolAddr = Array.isArray(targetTokenData) ? targetTokenData[6] : targetTokenData.pool;

                console.log(`\n🪙 TARGET TOKEN ANALYSIS:`);
                console.log(`  📛 Name: ${tokenName}`);
                console.log(`  📍 Address: ${targetToken}`);
                console.log(`  🏊 Pool: ${poolAddr}`);
                console.log(`  🆔 LP NFT ID: ${tokenId}`);

                if (!poolAddr || poolAddr === '0x0000000000000000000000000000000000000000') {
                    console.log('❌ No pool address found');
                    return;
                }

                // Extended analysis with much wider timeframe
                console.log(`\n🔍 EXTENDED TRADING ANALYSIS (Last 20,000 blocks ~ 2-3 weeks)`);

                const poolCONTRACT = new ethers.Contract(poolAddr, [
                    "function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)",
                    "function token0() external view returns (address)",
                    "function token1() external view returns (address)",
                    "function fee() external view returns (uint24)",
                    "event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick)"
                ], provider);

                const [token0, token1, feeLevel] = await Promise.all([
                    poolCONTRACT.token0(),
                    poolCONTRACT.token1(),
                    poolCONTRACT.fee()
                ]);

                console.log(`  🎯 Token0 (WETH): ${token0}`);
                console.log(`  🎯 Token1 (Your Token): ${token1}`);
                console.log(`  💰 Fee Level: ${feeLevel / 10000}%`);

                // Check for swap events with extended range
                const swapFilter = poolCONTRACT.filters.Swap();
                const swapEvents = await poolCONTRACT.queryFilter(swapFilter, -20000); // Last ~20k blocks

                console.log(`\n📈 SWAP EVENTS ANALYSIS:`);
                console.log(`  📊 Total swaps found: ${swapEvents.length}`);

                if (swapEvents.length > 0) {
                    console.log(`  ✅ TRADING ACTIVITY DETECTED!`);

                    let totalVolume = 0;
                    let recentSwaps = 0;
                    const currentBlock = await provider.getBlockNumber();

                    console.log(`  📅 Current block: ${currentBlock}`);
                    console.log(`\n🔄 RECENT SWAPS BREAKDOWN:`);

                    for (let i = 0; i < Math.min(swapEvents.length, 10); i++) {
                        const swap = swapEvents[i];
                        const { amount0, amount1, sender, recipient } = swap.args;
                        const blockAge = currentBlock - swap.blockNumber;

                        const vol0 = Math.abs(parseFloat(ethers.utils.formatEther(amount0)));
                        const vol1 = Math.abs(parseFloat(ethers.utils.formatEther(amount1)));
                        const tradeSize = Math.max(vol0, vol1);
                        totalVolume += tradeSize;

                        if (blockAge < 10000) recentSwaps++; // Recent = last ~10k blocks

                        console.log(`    Swap ${i + 1}: ${vol0.toFixed(4)} WETH ↔ ${vol1.toFixed(0)} tokens`);
                        console.log(`      Block: ${swap.blockNumber} (${blockAge} blocks ago)`);
                        console.log(`      Trader: ${sender} → ${recipient}`);
                        console.log(`      Trade Size: ${tradeSize.toFixed(4)}`);
                    }

                    console.log(`\n💰 VOLUME SUMMARY:`);
                    console.log(`  📊 Total Volume: ${totalVolume.toFixed(4)} tokens`);
                    console.log(`  🕒 Recent swaps (last 10k blocks): ${recentSwaps}`);

                    // Calculate expected fees
                    const feeRate = feeLevel / 1000000;
                    const expectedFees = totalVolume * feeRate;
                    console.log(`  💸 Expected fees (${feeRate * 100}%): ${expectedFees.toFixed(4)} tokens`);

                    // Check if these fees were collected
                    console.log(`\n🔍 CHECKING FEE COLLECTION HISTORY:`);
                    const feeFilter = CONTRACT.filters.FeesCollected(tokenId);
                    const feeEvents = await CONTRACT.queryFilter(feeFilter, -20000);

                    console.log(`  📊 FeesCollected events: ${feeEvents.length}`);

                    let totalFeesCollected = 0;
                    for (const event of feeEvents) {
                        const { ethAmount, tokenAmount, swappedETH } = event.args;
                        const ethFees = parseFloat(ethers.utils.formatEther(ethAmount));
                        const tokenFees = parseFloat(ethers.utils.formatEther(tokenAmount));
                        totalFeesCollected += tokenFees;

                        console.log(`    💰 Fee Collection: ${ethFees.toFixed(6)} ETH + ${tokenFees.toFixed(2)} tokens`);
                        console.log(`      Block: ${event.blockNumber}`);
                    }

                    console.log(`\n🎯 ANALYSIS CONCLUSION:`);
                    console.log(`  📈 Trading Volume Found: ${totalVolume.toFixed(4)} tokens`);
                    console.log(`  💸 Expected Fees: ${expectedFees.toFixed(4)} tokens`);
                    console.log(`  💰 Fees Collected: ${totalFeesCollected.toFixed(4)} tokens`);
                    console.log(`  🤔 Missing Fees: ${(expectedFees - totalFeesCollected).toFixed(4)} tokens`);

                    if (expectedFees > totalFeesCollected + 100) { // Buffer for rounding
                        console.log(`  🚨 FEES ARE MISSING! There should be more fees to collect.`);
                        console.log(`  💡 Try running "Collect LP Fees" to claim them.`);
                    } else {
                        console.log(`  ✅ Fees appear to be collected correctly.`);
                    }

                } else {
                    console.log(`  📭 No swap events found in extended timeframe`);
                    console.log(`  💭 This suggests trading might have happened:`);
                    console.log(`    - On a different DEX (not Uniswap)`);
                    console.log(`    - More than 20,000 blocks ago`);
                    console.log(`    - On a different pool/token`);
                }

                alert(`Analysis complete for ${targetToken}! Check console for detailed trading and fee analysis.`);

            } catch (error) {
                console.error('❌ Specific token analysis failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Check why fees aren't being recognized - debug the actual Uniswap position
        async function debugFeeRecognition() {
            console.log('🔍 DEBUGGING FEE RECOGNITION ISSUE 🔍');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            const targetToken = '0xfE63785eEB6117259FEbd92E95d597F683950C29';
            console.log(`🎯 Debugging fee recognition for: ${targetToken}`);

            try {
                const userTokens = await getUserTokens(userAddress);

                // Find the specific token
                let targetTokenData = null;
                for (let i = 0; i < userTokens.length; i++) {
                    const tokenData = userTokens[i];
                    const tokenAddr = Array.isArray(tokenData) ? tokenData[0] : tokenData.tokenAddress;

                    if (tokenAddr.toLowerCase() === targetToken.toLowerCase()) {
                        targetTokenData = tokenData;
                        break;
                    }
                }

                if (!targetTokenData) {
                    console.log(`❌ Token not found`);
                    return;
                }

                const tokenId = Array.isArray(targetTokenData) ? targetTokenData[4] : targetTokenData.tokenId;
                const tokenName = Array.isArray(targetTokenData) ? targetTokenData[2] : targetTokenData.name;
                const poolAddr = Array.isArray(targetTokenData) ? targetTokenData[6] : targetTokenData.pool;

                console.log(`\n🪙 DEBUGGING: ${tokenName}`);
                console.log(`  🆔 LP NFT ID: ${tokenId}`);
                console.log(`  🏊 Pool: ${poolAddr}`);

                // Check what Uniswap actually sees for this position
                const positionManager = new ethers.Contract(POSITION_MANAGER_ADDRESS, [
                    "function positions(uint256) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)",
                    "function collect((uint256 tokenId, address recipient, uint128 amount0Max, uint128 amount1Max)) external returns (uint256 amount0, uint256 amount1)",
                    "function ownerOf(uint256) external view returns (address)"
                ], provider);

                console.log(`\n🔍 UNISWAP POSITION DETAILS:`);

                // 1. Check ownership
                const owner = await positionManager.ownerOf(tokenId);
                console.log(`  👤 Current Owner: ${owner}`);
                console.log(`  🏭 Factory Address: ${TOKEN_FACTORY_ADDRESS}`);
                console.log(`  ✅ Ownership Correct: ${owner.toLowerCase() === TOKEN_FACTORY_ADDRESS.toLowerCase()}`);

                // 2. Get position details
                const position = await positionManager.positions(tokenId);
                console.log(`\n📊 POSITION DATA:`);
                console.log(`  🔄 Liquidity: ${position.liquidity}`);
                console.log(`  💰 Tokens Owed 0 (WETH): ${position.tokensOwed0}`);
                console.log(`  💰 Tokens Owed 1 (Token): ${position.tokensOwed1}`);
                console.log(`  📈 Fee Growth 0: ${position.feeGrowthInside0LastX128}`);
                console.log(`  📈 Fee Growth 1: ${position.feeGrowthInside1LastX128}`);

                const tokensOwed0 = ethers.utils.formatEther(position.tokensOwed0);
                const tokensOwed1 = ethers.utils.formatEther(position.tokensOwed1);

                console.log(`\n💰 FORMATTED FEES:`);
                console.log(`  WETH Fees: ${tokensOwed0}`);
                console.log(`  Token Fees: ${tokensOwed1}`);

                if (parseFloat(tokensOwed0) === 0 && parseFloat(tokensOwed1) === 0) {
                    console.log(`\n🚨 PROBLEM IDENTIFIED: Uniswap shows ZERO fees owed!`);
                    console.log(`\n🤔 POSSIBLE REASONS:`);
                    console.log(`  1. 📊 Fee calculation in pool is working differently than expected`);
                    console.log(`  2. 🔄 Fees are auto-collected by some mechanism`);
                    console.log(`  3. 💱 Someone else collected them already`);
                    console.log(`  4. 🎯 Position is not earning fees (outside active range)`);
                    console.log(`  5. 🐛 There's a bug in our volume calculation`);

                    // Check if position is in active range
                    console.log(`\n🎯 CHECKING POSITION RANGE:`);
                    const poolCONTRACT = new ethers.Contract(poolAddr, [
                        "function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)"
                    ], provider);

                    const slot0 = await poolCONTRACT.slot0();
                    const currentTick = slot0.tick;
                    const tickLower = position.tickLower;
                    const tickUpper = position.tickUpper;

                    console.log(`  📍 Current Tick: ${currentTick}`);
                    console.log(`  📉 Position Lower Tick: ${tickLower}`);
                    console.log(`  📈 Position Upper Tick: ${tickUpper}`);
                    console.log(`  🎯 Position Active: ${currentTick >= tickLower && currentTick <= tickUpper}`);

                    if (currentTick < tickLower || currentTick > tickUpper) {
                        console.log(`  🚨 POSITION IS OUT OF RANGE!`);
                        console.log(`  💡 This means it's not earning fees from recent trades`);
                        console.log(`  🔧 The LP position needs to be in the active trading range to earn fees`);
                    }

                    // Check pool's fee growth globally
                    console.log(`\n📈 CHECKING GLOBAL FEE GROWTH:`);
                    const poolCONTRACTExtended = new ethers.Contract(poolAddr, [
                        "function feeGrowthGlobal0X128() external view returns (uint256)",
                        "function feeGrowthGlobal1X128() external view returns (uint256)"
                    ], provider);

                    const [globalFeeGrowth0, globalFeeGrowth1] = await Promise.all([
                        poolCONTRACTExtended.feeGrowthGlobal0X128(),
                        poolCONTRACTExtended.feeGrowthGlobal1X128()
                    ]);

                    console.log(`  🌍 Global Fee Growth 0: ${globalFeeGrowth0}`);
                    console.log(`  🌍 Global Fee Growth 1: ${globalFeeGrowth1}`);

                    if (globalFeeGrowth0.toString() === '0' && globalFeeGrowth1.toString() === '0') {
                        console.log(`  🚨 POOL HAS NO GLOBAL FEE GROWTH - Something is very wrong!`);
                    } else {
                        console.log(`  ✅ Pool has accumulated fees globally`);
                    }

                } else {
                    console.log(`\n✅ FEES ARE AVAILABLE IN UNISWAP!`);
                    console.log(`  💰 Ready to collect: ${tokensOwed0} WETH + ${tokensOwed1} tokens`);
                    console.log(`  🤔 But why isn't collectFees() working?`);

                    // Test the actual collect call
                    console.log(`\n🧪 TESTING DIRECT COLLECTION:`);
                    try {
                        // Simulate the collect call (don't actually execute)
                        const collectParams = {
                            tokenId: tokenId,
                            recipient: TOKEN_FACTORY_ADDRESS,
                            amount0Max: ethers.constants.MaxUint128,
                            amount1Max: ethers.constants.MaxUint128
                        };

                        console.log(`  📋 Collect Params: ${JSON.stringify(collectParams)}`);
                        console.log(`  💡 This should be called by your CONTRACT's collectFees function`);

                    } catch (collectError) {
                        console.log(`  ❌ Collect simulation failed: ${collectError.message}`);
                    }
                }

                console.log(`\n🎯 DIAGNOSIS COMPLETE`);
                alert('Fee recognition debugging complete! Check console for detailed analysis of why fees aren\'t being recognized.');

            } catch (error) {
                console.error('❌ Fee recognition debug failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Direct check of Uniswap position bypassing CONTRACT issues
        async function checkUniswapDirectly() {
            console.log('🎯 CHECKING UNISWAP POSITION DIRECTLY 🎯');

            if (!provider) {
                alert('Connect wallet first!');
                return;
            }

            const targetTokenId = 3771090; // Your "fee maker" token LP NFT ID
            console.log(`🔍 Checking LP NFT ID: ${targetTokenId}`);

            try {
                // Direct Uniswap Position Manager call
                const positionManager = new ethers.Contract(POSITION_MANAGER_ADDRESS, [
                    "function positions(uint256) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)",
                    "function ownerOf(uint256) external view returns (address)"
                ], provider);

                console.log(`\n📊 POSITION MANAGER: ${POSITION_MANAGER_ADDRESS}`);

                // Check ownership
                const owner = await positionManager.ownerOf(targetTokenId);
                console.log(`👤 NFT Owner: ${owner}`);
                console.log(`🏭 Your Factory: ${TOKEN_FACTORY_ADDRESS}`);
                console.log(`✅ Correct Ownership: ${owner.toLowerCase() === TOKEN_FACTORY_ADDRESS.toLowerCase()}`);

                // Get position data
                const position = await positionManager.positions(targetTokenId);
                console.log(`\n💰 UNISWAP POSITION DATA:`);
                console.log(`  🔄 Liquidity: ${position.liquidity.toString()}`);
                console.log(`  🏊 Token0: ${position.token0}`);
                console.log(`  🏊 Token1: ${position.token1}`);
                console.log(`  💰 Fee Tier: ${position.fee / 10000}%`);

                // THE CRITICAL VALUES - what Uniswap shows as owed
                const tokensOwed0Raw = position.tokensOwed0;
                const tokensOwed1Raw = position.tokensOwed1;

                console.log(`\n🚨 CRITICAL FEE DATA:`);
                console.log(`  💰 Tokens Owed 0 (Raw): ${tokensOwed0Raw.toString()}`);
                console.log(`  💰 Tokens Owed 1 (Raw): ${tokensOwed1Raw.toString()}`);

                const tokensOwed0 = ethers.utils.formatEther(tokensOwed0Raw);
                const tokensOwed1 = ethers.utils.formatEther(tokensOwed1Raw);

                console.log(`  💰 Tokens Owed 0 (WETH): ${tokensOwed0}`);
                console.log(`  💰 Tokens Owed 1 (FEE): ${tokensOwed1}`);

                if (parseFloat(tokensOwed0) > 0 || parseFloat(tokensOwed1) > 0) {
                    console.log(`\n✅ FEES FOUND IN UNISWAP!`);
                    console.log(`  🎉 WETH Fees: ${tokensOwed0} (${parseFloat(tokensOwed0) * 4300} USD)`);
                    console.log(`  🎉 FEE Token Fees: ${tokensOwed1}`);

                    const totalUSDValue = (parseFloat(tokensOwed0) * 4300) + (parseFloat(tokensOwed1) * 0.000001); // rough estimate
                    console.log(`  💵 Estimated Total USD: $${totalUSDValue.toFixed(4)}`);

                    console.log(`\n🚨 WHY ISN'T YOUR CONTRACT SEEING THESE?`);
                    console.log(`  🔍 Possible reasons:`);
                    console.log(`    1. CONTRACT ABI is missing functions`);
                    console.log(`    2. CONTRACT doesn't properly query Uniswap`);
                    console.log(`    3. There's a bug in the fee collection logic`);
                    console.log(`    4. CONTRACT needs to be updated`);

                    // Try to simulate a direct collect call
                    console.log(`\n🧪 SIMULATING DIRECT COLLECTION:`);
                    try {
                        const collectData = positionManager.interface.encodeFunctionData('collect', [{
                            tokenId: targetTokenId,
                            recipient: TOKEN_FACTORY_ADDRESS,
                            amount0Max: ethers.constants.MaxUint128,
                            amount1Max: ethers.constants.MaxUint128
                        }]);

                        console.log(`  📋 Collect Call Data: ${collectData.substring(0, 20)}...`);
                        console.log(`  💡 Your CONTRACT should make this call to collect fees`);

                    } catch (simError) {
                        console.log(`  ❌ Simulation error: ${simError.message}`);
                    }

                } else {
                    console.log(`\n❌ NO FEES IN UNISWAP POSITION`);
                    console.log(`  🤔 This means:`);
                    console.log(`    - Fees were already collected`);
                    console.log(`    - Position is not earning fees`);
                    console.log(`    - There's a discrepancy with Uniswap UI`);

                    console.log(`\n🔄 The Uniswap UI might be showing cached/estimated data`);
                    console.log(`  💡 Try refreshing the Uniswap interface`);
                }

                // Check if position is in range
                console.log(`\n🎯 CHECKING POSITION RANGE:`);
                const poolCONTRACT = new ethers.Contract('0xA856Cc48A9E0Bf7a17a389981DdB189b15c4E99E', [
                    "function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)"
                ], provider);

                const slot0 = await poolCONTRACT.slot0();
                const currentTick = slot0.tick;

                console.log(`  📍 Current Tick: ${currentTick}`);
                console.log(`  📉 Position Lower: ${position.tickLower}`);
                console.log(`  📈 Position Upper: ${position.tickUpper}`);
                console.log(`  🎯 In Range: ${currentTick >= position.tickLower && currentTick <= position.tickUpper}`);

                alert('Direct Uniswap check complete! This shows exactly what fees are available vs what your CONTRACT can see.');

            } catch (error) {
                console.error('❌ Direct Uniswap check failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Investigate why fees aren't accumulating properly
        async function investigateFeeAccumulation() {
            console.log('🕵️ INVESTIGATING FEE ACCUMULATION ISSUE 🕵️');

            if (!provider) {
                alert('Connect wallet first!');
                return;
            }

            const targetTokenId = 3771090;
            const poolAddress = '0xA856Cc48A9E0Bf7a17a389981DdB189b15c4E99E';

            try {
                console.log(`🔍 Deep dive investigation for LP NFT ${targetTokenId}`);
                console.log(`🏊 Pool: ${poolAddress}`);

                // 1. Check if position was modified recently
                const positionManager = new ethers.Contract(POSITION_MANAGER_ADDRESS, [
                    "function positions(uint256) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)",
                    "event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)",
                    "event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)",
                    "event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1)"
                ], provider);

                console.log(`\n🔍 CHECKING POSITION MODIFICATION HISTORY:`);

                // Check for recent Collect events
                const collectFilter = positionManager.filters.Collect(targetTokenId);
                const collectEvents = await positionManager.queryFilter(collectFilter, -10000);

                console.log(`💰 Collect events found: ${collectEvents.length}`);
                for (const event of collectEvents) {
                    const { recipient, amount0, amount1 } = event.args;
                    console.log(`  📅 Block ${event.blockNumber}: Collected ${ethers.utils.formatEther(amount0)} WETH + ${ethers.utils.formatEther(amount1)} tokens`);
                    console.log(`  👤 Recipient: ${recipient}`);
                }

                // Check for liquidity changes
                const increaseFilter = positionManager.filters.IncreaseLiquidity(targetTokenId);
                const decreaseFilter = positionManager.filters.DecreaseLiquidity(targetTokenId);

                const [increaseEvents, decreaseEvents] = await Promise.all([
                    positionManager.queryFilter(increaseFilter, -10000),
                    positionManager.queryFilter(decreaseFilter, -10000)
                ]);

                console.log(`📈 Liquidity increase events: ${increaseEvents.length}`);
                console.log(`📉 Liquidity decrease events: ${decreaseEvents.length}`);

                // 2. Check pool's fee mechanism
                console.log(`\n🏊 CHECKING POOL FEE MECHANISM:`);

                const poolCONTRACT = new ethers.Contract(poolAddress, [
                    "function feeGrowthGlobal0X128() external view returns (uint256)",
                    "function feeGrowthGlobal1X128() external view returns (uint256)",
                    "function protocolFees() external view returns (uint128 token0, uint128 token1)",
                    "function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)",
                    "event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick)"
                ], provider);

                const [slot0, feeGrowthGlobal0, feeGrowthGlobal1] = await Promise.all([
                    poolCONTRACT.slot0(),
                    poolCONTRACT.feeGrowthGlobal0X128(),
                    poolCONTRACT.feeGrowthGlobal1X128()
                ]);

                console.log(`🌍 Global fee growth 0: ${feeGrowthGlobal0.toString()}`);
                console.log(`🌍 Global fee growth 1: ${feeGrowthGlobal1.toString()}`);
                console.log(`🔒 Fee Protocol: ${slot0.feeProtocol}`);

                // Check if there are protocol fees being extracted
                try {
                    const protocolFees = await poolCONTRACT.protocolFees();
                    console.log(`🏛️ Protocol fees token0: ${ethers.utils.formatEther(protocolFees.token0)}`);
                    console.log(`🏛️ Protocol fees token1: ${ethers.utils.formatEther(protocolFees.token1)}`);
                } catch (e) {
                    console.log(`🏛️ Protocol fees not available: ${e.message}`);
                }

                // 3. Manual fee calculation based on growth
                console.log(`\n🧮 MANUAL FEE CALCULATION:`);

                const position = await positionManager.positions(targetTokenId);
                const feeGrowthInside0 = position.feeGrowthInside0LastX128;
                const feeGrowthInside1 = position.feeGrowthInside1LastX128;
                const liquidity = position.liquidity;

                console.log(`📊 Position liquidity: ${liquidity.toString()}`);
                console.log(`📈 Fee growth inside 0 (last): ${feeGrowthInside0.toString()}`);
                console.log(`📈 Fee growth inside 1 (last): ${feeGrowthInside1.toString()}`);

                // 4. Check for very recent swaps that might not have updated fees yet
                console.log(`\n🔄 CHECKING VERY RECENT SWAPS:`);
                const swapFilter = poolCONTRACT.filters.Swap();
                const recentSwaps = await poolCONTRACT.queryFilter(swapFilter, -100); // Last 100 blocks

                console.log(`📈 Very recent swaps (last 100 blocks): ${recentSwaps.length}`);
                for (let i = 0; i < Math.min(recentSwaps.length, 5); i++) {
                    const swap = recentSwaps[i];
                    const { amount0, amount1 } = swap.args;
                    console.log(`  Swap ${i + 1}: ${ethers.utils.formatEther(amount0.abs())} token0, ${ethers.utils.formatEther(amount1.abs())} token1`);
                    console.log(`    Block: ${swap.blockNumber}`);
                }

                // 5. Check if there's a fee collection threshold
                console.log(`\n🎯 POSSIBLE ISSUES IDENTIFIED:`);

                if (feeGrowthGlobal0.toString() === '0' && feeGrowthGlobal1.toString() === '0') {
                    console.log(`❌ Pool has ZERO global fee growth - fees aren't accumulating at pool level`);
                    console.log(`💡 This suggests the pool's fee mechanism is broken or disabled`);
                } else if (collectEvents.length > 0) {
                    console.log(`🔄 Fees were recently collected - this might explain the discrepancy`);
                } else if (recentSwaps.length === 0) {
                    console.log(`📭 No recent trading activity to generate fees`);
                } else {
                    console.log(`🚨 MYSTERY: Pool has fee growth, trading exists, but position shows 0 fees`);
                    console.log(`💡 Possible causes:`);
                    console.log(`  - Position went out of range during fee accumulation`);
                    console.log(`  - There's a minimum threshold before fees show up`);
                    console.log(`  - Uniswap V3 fee calculation has edge cases`);
                    console.log(`  - The position was created after the swaps occurred`);
                }

                alert('Fee accumulation investigation complete! Check console for detailed analysis.');

            } catch (error) {
                console.error('❌ Fee accumulation investigation failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Debug CONTRACT interface and fee collection methods
        async function debugCONTRACTInterface() {
            console.log('🔧 DEBUGGING CONTRACT INTERFACE & METHODS 🔧');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            try {
                console.log(`🏭 CONTRACT Address: ${TOKEN_FACTORY_ADDRESS}`);
                console.log(`👤 User Address: ${userAddress}`);
                console.log(`🌐 Network: Base (Chain ID: 8453)`);

                // 1. Check what methods are actually available in our CONTRACT
                console.log(`\n📋 CHECKING AVAILABLE CONTRACT METHODS:`);
                console.log(`✅ getUserTokens helper: ${typeof getUserTokens}`);
                console.log(`✅ CONTRACT.collectFees: ${typeof CONTRACT.collectFees}`);
                console.log(`✅ CONTRACT.collectAllTokens: ${typeof CONTRACT.collectAllTokens}`);
                console.log(`? CONTRACT.getCreatorFees: ${typeof CONTRACT.getCreatorFees}`);
                console.log(`? CONTRACT.claimCreatorFees: ${typeof CONTRACT.claimCreatorFees}`);

                // 2. Test direct Uniswap position manager calls
                console.log(`\n🦄 TESTING DIRECT UNISWAP CALLS:`);
                const positionManager = new ethers.Contract(POSITION_MANAGER_ADDRESS, [
                    "function positions(uint256) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)",
                    "function collect(tuple(uint256 tokenId, address recipient, uint128 amount0Max, uint128 amount1Max)) external returns (uint256 amount0, uint256 amount1)"
                ], signer);

                const targetTokenId = 3771090;

                // Try to simulate a direct collect call
                console.log(`💰 TESTING DIRECT COLLECT SIMULATION:`);
                try {
                    const collectParams = {
                        tokenId: targetTokenId,
                        recipient: userAddress, // Try collecting to your address directly
                        amount0Max: ethers.constants.MaxUint128,
                        amount1Max: ethers.constants.MaxUint128
                    };

                    // Don't actually call, just encode
                    const collectData = positionManager.interface.encodeFunctionData('collect', [collectParams]);
                    console.log(`📝 Collect call data: ${collectData.substring(0, 50)}...`);

                    // Try to estimate gas (this will fail if there are no fees)
                    try {
                        const gasEstimate = await positionManager.estimateGas.collect(collectParams);
                        console.log(`⛽ Gas estimate for direct collect: ${gasEstimate.toString()}`);
                        console.log(`✅ SUCCESS: Direct collect would work! Fees exist!`);

                        // If gas estimation succeeds, fees definitely exist
                        console.log(`\n🚨 FEES DEFINITELY EXIST BUT OUR CONTRACT ISN'T COLLECTING THEM!`);

                        // Test if we can actually do the direct collection
                        console.log(`🔄 Should we try direct collection? (This would bypass your factory)`);

                    } catch (gasError) {
                        console.log(`❌ Gas estimation failed: ${gasError.message}`);
                        if (gasError.message.includes('No fees')) {
                            console.log(`💡 This confirms no fees exist in the position`);
                        }
                    }

                } catch (simulationError) {
                    console.log(`❌ Direct collect simulation failed: ${simulationError.message}`);
                }

                // 3. Check if our factory CONTRACT can make the call
                console.log(`\n🏭 TESTING FACTORY CONTRACT METHODS:`);

                // Get the token info to use with collectFees
                const userTokens = await getUserTokens(userAddress);
                const feeToken = userTokens.find(token => {
                    const tokenAddr = Array.isArray(token) ? token[0] : token.tokenAddress;
                    return tokenAddr.toLowerCase() === '0xfE63785eEB6117259FEbd92E95d597F683950C29'.toLowerCase();
                });

                if (feeToken) {
                    const tokenId = Array.isArray(feeToken) ? feeToken[4] : feeToken.tokenId;
                    console.log(`🪙 Found fee token with ID: ${tokenId}`);

                    // Try collectFees function
                    console.log(`💰 TESTING collectFees(${tokenId}):`);
                    try {
                        const gasEstimate = await CONTRACT.estimateGas.collectFees(tokenId);
                        console.log(`⛽ Gas estimate for collectFees: ${gasEstimate.toString()}`);
                        console.log(`✅ collectFees would work!`);

                        // If this works, the issue might be elsewhere
                        console.log(`🤔 If this works, why isn't it showing fees? Possible issues:`);
                        console.log(`  - collectFees collects but doesn't show in UI`);
                        console.log(`  - Fees are collected but not credited properly`);
                        console.log(`  - UI is checking wrong account/CONTRACT`);

                    } catch (collectError) {
                        console.log(`❌ collectFees estimation failed: ${collectError.message}`);

                        if (collectError.message.includes('Only token creator')) {
                            console.log(`🔒 Permission error - checking ownership...`);
                        } else if (collectError.message.includes('No fees')) {
                            console.log(`💰 No fees to collect according to CONTRACT`);
                        }
                    }
                }

                // 4. Check creator fees function
                console.log(`\n💰 TESTING CREATOR FEE FUNCTIONS:`);
                try {
                    if (typeof CONTRACT.getCreatorFees === 'function') {
                        const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                        console.log(`💰 getCreatorFees result: ${ethers.utils.formatEther(creatorFees)} ETH`);
                    } else {
                        console.log(`❌ getCreatorFees function not available`);
                        console.log(`🔍 Available functions:`, Object.keys(CONTRACT.functions || {}));
                    }
                } catch (feeError) {
                    console.log(`❌ Creator fee check failed: ${feeError.message}`);
                }

                console.log(`\n🎯 DIAGNOSIS SUMMARY:`);
                console.log(`If direct collect works but factory doesn't:`);
                console.log(`  - Factory CONTRACT has bugs`);
                console.log(`  - Wrong ABI or CONTRACT address`);
                console.log(`  - Permissions/ownership issue`);

                alert('CONTRACT interface debugging complete! Check console for detailed analysis.');

            } catch (error) {
                console.error('❌ CONTRACT interface debug failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Check what ABI functions we have vs what we need
        async function analyzeABI() {
            console.log('📋 ANALYZING CONTRACT ABI & MISSING FUNCTIONS 📋');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            try {
                console.log(`🏭 CONTRACT: ${TOKEN_FACTORY_ADDRESS}`);
                console.log(`\n📚 CURRENT ABI FUNCTIONS:`);

                // List all functions we have in ABI
                const abiFunctions = [
                    "createToken", "collectFees", "collectAllTokens", "withdrawCreatorFees",
                    "withdrawPlatformFees", "getCreatorFees", "getPlatformFees", "getTokenCount",
                    "platformAdmin", "tokenCreators", "creatorFeesETH", "platformFeesETH",
                    "allTokens", "createdTokens"
                ];

                abiFunctions.forEach(func => {
                    const hasFunction = typeof CONTRACT[func] === 'function';
                    console.log(`  ${hasFunction ? '✅' : '❌'} ${func}: ${hasFunction ? 'Available' : 'Missing'}`);
                });

                console.log(`\n🔍 TESTING EACH FEE-RELATED FUNCTION:`);

                // Test getCreatorFees
                console.log(`💰 Testing getCreatorFees(${userAddress}):`);
                try {
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log(`  Result: ${ethers.utils.formatEther(creatorFees)} ETH`);
                } catch (e) {
                    console.log(`  Error: ${e.message}`);
                }

                // Test creatorFeesETH (different function)
                console.log(`💰 Testing creatorFeesETH(${userAddress}):`);
                try {
                    const creatorFeesETH = await CONTRACT.creatorFeesETH(userAddress);
                    console.log(`  Result: ${ethers.utils.formatEther(creatorFeesETH)} ETH`);
                } catch (e) {
                    console.log(`  Error: ${e.message}`);
                }

                // Get user tokens to test collectFees on specific tokens
                const userTokens = await getUserTokens(userAddress);
                console.log(`\n🪙 TESTING INDIVIDUAL TOKEN FEES:`);

                for (let i = 0; i < Math.min(userTokens.length, 5); i++) {
                    const token = userTokens[i];
                    const tokenId = Array.isArray(token) ? token[4] : token.tokenId;
                    const tokenName = Array.isArray(token) ? token[2] : token.name;
                    const totalFeesETH = Array.isArray(token) ? token[9] : token.totalFeesETH;

                    console.log(`\n  Token ${i + 1}: ${tokenName} (ID: ${tokenId})`);
                    console.log(`    totalFeesETH from struct: ${ethers.utils.formatEther(totalFeesETH)} ETH`);

                    // Test collectFees gas estimation
                    try {
                        const gasEstimate = await CONTRACT.estimateGas.collectFees(tokenId);
                        console.log(`    collectFees gas estimate: ${gasEstimate.toString()}`);
                        console.log(`    ✅ collectFees would execute`);
                    } catch (e) {
                        console.log(`    ❌ collectFees would fail: ${e.message}`);
                    }
                }

                console.log(`\n🔍 CHECKING MISSING FUNCTIONS WE MIGHT NEED:`);

                // Check if these functions might exist but not in our ABI
                const possiblyMissingFunctions = [
                    'getTokenFees', 'getLPNFTFees', 'collectTokenFees',
                    'getTotalFeesForToken', 'getUniswapPosition', 'collectUniswapFees',
                    'claimFees', 'collectLPNFTFees', 'withdrawTokenFees'
                ];

                for (const funcName of possiblyMissingFunctions) {
                    const testCONTRACT = new ethers.Contract(TOKEN_FACTORY_ADDRESS, [
                        `function ${funcName}() view returns (uint256)`
                    ], provider);

                    try {
                        // Just test if function exists by trying to encode it
                        testCONTRACT.interface.encodeFunctionData(funcName, []);
                        console.log(`  🤔 ${funcName}: Might exist (untested)`);
                    } catch (e) {
                        // Function doesn't exist in our test ABI (expected)
                    }
                }

                console.log(`\n🚨 KEY QUESTIONS:`);
                console.log(`1. Why does totalFeesETH in token struct show fees but getCreatorFees shows 0?`);
                console.log(`2. Does collectFees actually collect to creator balance or somewhere else?`);
                console.log(`3. Are there other fee storage variables we should check?`);

                // Let's check the actual blockchain state
                console.log(`\n🔍 DIRECT BLOCKCHAIN STATE CHECK:`);

                // Check CONTRACT's ETH balance
                const CONTRACTBalance = await provider.getBalance(TOKEN_FACTORY_ADDRESS);
                console.log(`CONTRACT ETH Balance: ${ethers.utils.formatEther(CONTRACTBalance)} ETH`);

                // Check if CONTRACT has any ETH at all
                if (CONTRACTBalance.gt(0)) {
                    console.log(`✅ CONTRACT has ETH - fees might be stuck in CONTRACT`);
                } else {
                    console.log(`📭 CONTRACT has no ETH - fees not accumulated or were withdrawn`);
                }

                alert('ABI analysis complete! Check console for detailed function analysis and potential issues.');

            } catch (error) {
                console.error('❌ ABI analysis failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Complete fee system test with updated ABI
        async function testUpdatedABI() {
            console.log('🔧 TESTING UPDATED ABI & FEE SYSTEM 🔧');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            try {
                console.log(`🏭 CONTRACT: ${TOKEN_FACTORY_ADDRESS}`);
                console.log(`👤 User: ${userAddress}`);

                // 1. Test both fee functions with updated ABI
                console.log(`\n💰 TESTING FEE FUNCTIONS:`);

                try {
                    const getCreatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log(`✅ getCreatorFees: ${ethers.utils.formatEther(getCreatorFees)} ETH`);
                } catch (e) {
                    console.log(`❌ getCreatorFees failed: ${e.message}`);
                }

                try {
                    const creatorFeesETH = await CONTRACT.creatorFeesETH(userAddress);
                    console.log(`✅ creatorFeesETH: ${ethers.utils.formatEther(creatorFeesETH)} ETH`);
                } catch (e) {
                    console.log(`❌ creatorFeesETH failed: ${e.message}`);
                }

                // 2. Check individual token fee status
                console.log(`\n🪙 CHECKING TOKEN FEE STATUS:`);
                const userTokens = await getUserTokens(userAddress);
                console.log(`📊 Total tokens to scan: ${userTokens.length}`);

                let totalFeesFound = ethers.BigNumber.from(0);
                let feeTokenFound = false;

                for (let i = 0; i < userTokens.length; i++) {
                    const token = userTokens[i];

                    // Add to total fees
                    totalFeesFound = totalFeesFound.add(token.totalFeesETH);

                    // Log every token briefly, but detailed info for FEE token
                    const isFeeToken = token.tokenAddress.toLowerCase() === '0xfE63785eEB6117259FEbd92E95d597F683950C29'.toLowerCase();

                    if (isFeeToken || token.totalFeesETH.gt(0)) {
                        console.log(`\n  Token ${i + 1}: ${token.name} (${token.symbol})`);
                        console.log(`    Address: ${token.tokenAddress}`);
                        console.log(`    Token ID: ${token.tokenId}`);
                        console.log(`    Pool: ${token.pool}`);
                        console.log(`    Total Fees ETH: ${ethers.utils.formatEther(token.totalFeesETH)} ETH`);

                        if (isFeeToken) {
                            feeTokenFound = true;
                            console.log(`    🎯 This is the FEE token - testing collection...`);

                            try {
                                // Check current Uniswap position status first
                                const positionManager = new ethers.Contract('0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1', [
                                    "function positions(uint256) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)"
                                ], provider);

                                const position = await positionManager.positions(token.tokenId);
                                const tokensOwed0 = ethers.utils.formatEther(position.tokensOwed0);
                                const tokensOwed1 = ethers.utils.formatEther(position.tokensOwed1);

                                console.log(`    🦄 Uniswap Position Status:`);
                                console.log(`      Tokens Owed 0: ${tokensOwed0}`);
                                console.log(`      Tokens Owed 1: ${tokensOwed1}`);

                                if (parseFloat(tokensOwed0) === 0 && parseFloat(tokensOwed1) === 0) {
                                    console.log(`    📭 No fees in Uniswap position to collect`);
                                } else {
                                    console.log(`    💰 Fees available in Uniswap!`);
                                }

                                // Try gas estimation for collectFees
                                try {
                                    const gasEstimate = await CONTRACT.estimateGas.collectFees(token.tokenId);
                                    console.log(`    ⛽ collectFees gas estimate: ${gasEstimate.toString()}`);
                                    console.log(`    ✅ collectFees transaction would succeed`);

                                    // If gas estimation works, there might be something to collect
                                    console.log(`    🚀 ATTEMPTING ACTUAL FEE COLLECTION...`);

                                    const tx = await CONTRACT.collectFees(token.tokenId);
                                    console.log(`    📝 Transaction sent: ${tx.hash}`);

                                    const receipt = await tx.wait();
                                    console.log(`    ✅ Transaction confirmed in block ${receipt.blockNumber}`);

                                    // Check for FeesCollected event
                                    const feesCollectedEvents = receipt.logs.filter(log =>
                                        log.address.toLowerCase() === TOKEN_FACTORY_ADDRESS.toLowerCase() &&
                                        log.topics[0] === CONTRACT.interface.getEventTopic('FeesCollected')
                                    );

                                    if (feesCollectedEvents.length > 0) {
                                        for (const event of feesCollectedEvents) {
                                            const parsed = CONTRACT.interface.parseLog(event);
                                            console.log(`    🎉 FeesCollected Event:`);
                                            console.log(`      Token ID: ${parsed.args.tokenId}`);
                                            console.log(`      ETH Amount: ${ethers.utils.formatEther(parsed.args.ethAmount)}`);
                                            console.log(`      Token Amount: ${ethers.utils.formatEther(parsed.args.tokenAmount)}`);
                                            console.log(`      Swapped ETH: ${ethers.utils.formatEther(parsed.args.swappedETH)}`);
                                        }
                                    } else {
                                        console.log(`    📭 No FeesCollected events found`);
                                    }

                                } catch (gasError) {
                                    console.log(`    ❌ collectFees would fail: ${gasError.reason || gasError.message}`);
                                }

                            } catch (positionError) {
                                console.log(`    ❌ Position check failed: ${positionError.message}`);
                            }
                        }

                        if (token.totalFeesETH.gt(0)) {
                            console.log(`    💰 This token has accumulated ${ethers.utils.formatEther(token.totalFeesETH)} ETH in fees!`);
                        }
                    } else if (i < 5 || i % 10 === 0) {
                        // Log every 10th token to show progress
                        console.log(`  Token ${i + 1}: ${token.name} (${token.symbol}) - ${ethers.utils.formatEther(token.totalFeesETH)} ETH`);
                    }
                }

                console.log(`\n📊 SCAN SUMMARY:`);
                console.log(`Total tokens scanned: ${userTokens.length}`);
                console.log(`Total fees in all tokens: ${ethers.utils.formatEther(totalFeesFound)} ETH`);
                console.log(`FEE token found: ${feeTokenFound}`);

                if (!feeTokenFound) {
                    console.log(`🔍 FEE token not found - it might be created under a different address`);
                }

                // 3. Final fee check after potential collection
                console.log(`\n🔄 FINAL FEE STATUS CHECK:`);
                try {
                    const finalCreatorFees = await CONTRACT.getCreatorFees(userAddress);
                    const finalCreatorFeesETH = await CONTRACT.creatorFeesETH(userAddress);

                    console.log(`Final getCreatorFees: ${ethers.utils.formatEther(finalCreatorFees)} ETH`);
                    console.log(`Final creatorFeesETH: ${ethers.utils.formatEther(finalCreatorFeesETH)} ETH`);

                    if (finalCreatorFees.gt(0) || finalCreatorFeesETH.gt(0)) {
                        console.log(`🎉 FEES AVAILABLE FOR WITHDRAWAL!`);
                        console.log(`💡 Try clicking "Withdraw Creator Fees" now`);
                    } else {
                        console.log(`📭 Still no fees available`);
                    }

                } catch (finalError) {
                    console.log(`❌ Final check failed: ${finalError.message}`);
                }

                alert('Updated ABI test complete! Check console for detailed results.');

            } catch (error) {
                console.error('❌ Updated ABI test failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Test platform fees instead of creator fees
        async function testPlatformFees() {
            console.log('🏛️ TESTING PLATFORM FEES 🏛️');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            try {
                console.log(`🏭 CONTRACT: ${TOKEN_FACTORY_ADDRESS}`);
                console.log(`👤 User: ${userAddress}`);

                // Check if user is platform admin
                const platformAdmin = await CONTRACT.platformAdmin();
                console.log(`🔑 Platform Admin: ${platformAdmin}`);
                console.log(`👤 You are admin: ${userAddress.toLowerCase() === platformAdmin.toLowerCase()}`);

                // Check platform fees
                const platformFeesETH = await CONTRACT.platformFeesETH();
                console.log(`💰 Platform Fees Available: ${ethers.utils.formatEther(platformFeesETH)} ETH`);

                if (platformFeesETH.gt(0)) {
                    console.log(`🎉 PLATFORM FEES FOUND!`);
                    console.log(`💡 The $5.39 WETH might be platform fees, not creator fees!`);

                    if (userAddress.toLowerCase() === platformAdmin.toLowerCase()) {
                        console.log(`✅ You can withdraw platform fees!`);

                        // Test gas estimation for platform fee withdrawal
                        try {
                            const gasEstimate = await CONTRACT.estimateGas.withdrawPlatformFees();
                            console.log(`⛽ withdrawPlatformFees gas: ${gasEstimate.toString()}`);
                            console.log(`🚀 PLATFORM FEE WITHDRAWAL READY!`);

                            // Optional: Ask if user wants to withdraw
                            const shouldWithdraw = confirm(`Platform fees available: ${ethers.utils.formatEther(platformFeesETH)} ETH\n\nWithdraw platform fees now?`);

                            if (shouldWithdraw) {
                                console.log(`💸 Executing withdrawPlatformFees...`);
                                const tx = await CONTRACT.withdrawPlatformFees();
                                console.log(`📝 Transaction sent: ${tx.hash}`);

                                const receipt = await tx.wait();
                                console.log(`✅ Platform fees withdrawn! Block: ${receipt.blockNumber}`);

                                // Check for PlatformWithdraw event
                                const withdrawEvents = receipt.logs.filter(log =>
                                    log.address.toLowerCase() === TOKEN_FACTORY_ADDRESS.toLowerCase() &&
                                    log.topics[0] === CONTRACT.interface.getEventTopic('PlatformWithdraw')
                                );

                                if (withdrawEvents.length > 0) {
                                    for (const event of withdrawEvents) {
                                        const parsed = CONTRACT.interface.parseLog(event);
                                        console.log(`🎉 PlatformWithdraw Event:`);
                                        console.log(`  Amount: ${ethers.utils.formatEther(parsed.args.ethAmount)} ETH`);
                                    }
                                }

                                alert(`Platform fees withdrawn successfully! Check your wallet.`);
                                return;
                            }

                        } catch (gasError) {
                            console.log(`❌ withdrawPlatformFees would fail: ${gasError.reason || gasError.message}`);
                        }

                    } else {
                        console.log(`❌ You are not the platform admin, cannot withdraw platform fees`);
                    }

                } else {
                    console.log(`📭 No platform fees available`);
                    console.log(`🤔 The $5.39 WETH mystery continues...`);

                    // Check CONTRACT's raw ETH balance
                    const CONTRACTBalance = await provider.getBalance(TOKEN_FACTORY_ADDRESS);
                    console.log(`💰 CONTRACT ETH Balance: ${ethers.utils.formatEther(CONTRACTBalance)} ETH`);

                    // Check CONTRACT's WETH balance
                    const wethCONTRACT = new ethers.Contract('0x4200000000000000000000000000000000000006', [
                        "function balanceOf(address) external view returns (uint256)"
                    ], provider);

                    const wethBalance = await wethCONTRACT.balanceOf(TOKEN_FACTORY_ADDRESS);
                    console.log(`🔄 CONTRACT WETH Balance: ${ethers.utils.formatEther(wethBalance)} WETH`);

                    console.log(`\n🚨 CONCLUSION:`);
                    if (wethBalance.gt(0)) {
                        console.log(`CONTRACT has WETH but it's not in fee accounting system`);
                        console.log(`Possible causes:`);
                        console.log(`- WETH from token creation excess funds`);
                        console.log(`- Manual WETH transfers to CONTRACT`);
                        console.log(`- Bug in fee collection logic`);
                        console.log(`- Stuck WETH from failed transactions`);
                    }
                }

                alert('Platform fee test complete! Check console for results.');

            } catch (error) {
                console.error('❌ Platform fee test failed:', error);
                alert('Error: ' + error.message);
            }
        }

        // Debug permission issues with fee collection
        async function debugPermissions() {
            console.log('🔐 DEBUGGING PERMISSION ISSUES 🔐');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            try {
                console.log('👤 Your address:', userAddress);

                // Check if you're the platform admin
                try {
                    const platformAdmin = await CONTRACT.platformAdmin();
                    console.log('🔑 Platform admin:', platformAdmin);
                    console.log('🤔 Are you admin?', userAddress.toLowerCase() === platformAdmin.toLowerCase());
                } catch (adminError) {
                    console.log('❌ Cannot get platform admin:', adminError.message);
                }

                // Get your tokens and check creator mapping
                console.log('\n🪙 Checking token creators...');
                const userTokens = await getUserTokens(userAddress);
                console.log(`Found ${userTokens.length} tokens`);

                for (let i = 0; i < Math.min(userTokens.length, 5); i++) {
                    const tokenData = userTokens[i];
                    const tokenId = Array.isArray(tokenData) ? tokenData[4] : tokenData.tokenId;
                    const tokenName = Array.isArray(tokenData) ? tokenData[2] : tokenData.name;
                    const creatorFromStruct = Array.isArray(tokenData) ? tokenData[1] : tokenData.creator;

                    console.log(`\n🪙 Token ${i + 1}: ${tokenName} (ID: ${tokenId})`);
                    console.log(`  📊 Creator from struct: ${creatorFromStruct}`);
                    console.log(`  🤔 Struct creator matches you: ${creatorFromStruct.toLowerCase() === userAddress.toLowerCase()}`);

                    // Check the tokenCreators mapping directly
                    try {
                        const creatorFromMapping = await CONTRACT.tokenCreators(tokenId);
                        console.log(`  🗺️ Creator from mapping: ${creatorFromMapping}`);
                        console.log(`  🤔 Mapping creator matches you: ${creatorFromMapping.toLowerCase() === userAddress.toLowerCase()}`);

                        if (creatorFromMapping.toLowerCase() !== userAddress.toLowerCase()) {
                            console.log(`  🚨 PERMISSION PROBLEM: Mapping shows different creator!`);
                            console.log(`  💡 Expected: ${userAddress}`);
                            console.log(`  💡 Got: ${creatorFromMapping}`);
                        } else {
                            console.log(`  ✅ Permission should work for this token`);
                        }

                    } catch (mappingError) {
                        console.log(`  ❌ Cannot get creator from mapping: ${mappingError.message}`);
                    }
                }

                // Test permission check directly
                console.log('\n🧪 Testing permission check...');
                const firstToken = userTokens[0];
                const firstTokenId = Array.isArray(firstToken) ? firstToken[4] : firstToken.tokenId;

                try {
                    console.log(`🔍 Testing collectFees(${firstTokenId}) permission...`);

                    // Optimized gas for testing
                    let gasLimit;
                    try {
                        const estimatedGas = await CONTRACT.estimateGas.collectFees(firstTokenId);
                        gasLimit = Math.floor(estimatedGas.toNumber() * 1.15);
                        console.log(`💡 Test gas optimized: ${gasLimit}`);
                    } catch (estError) {
                        gasLimit = 200000; // Much lower fallback
                    }

                    // Try to simulate the call to see what error we get
                    const tx = await CONTRACT.collectFees(firstTokenId, { gasLimit: gasLimit });
                    console.log('✅ collectFees call successful!');
                    await tx.wait();
                    console.log('✅ collectFees transaction confirmed');

                } catch (permissionError) {
                    console.log('❌ collectFees failed:', permissionError.message);

                    if (permissionError.message.includes('Only creator or admin')) {
                        console.log('🚨 CONFIRMED: Permission check is failing');
                        console.log('💡 This means either:');
                        console.log('  - tokenCreators mapping is wrong');
                        console.log('  - You are not the platform admin');
                        console.log('  - CONTRACT bug in permission logic');
                    } else if (permissionError.message.includes('Invalid token ID')) {
                        console.log('🚨 Token ID not found in tokenCreators mapping');
                    } else {
                        console.log('🤔 Different error - not permission related');
                    }
                }

                console.log('\n💡 PERMISSION DIAGNOSIS COMPLETE');
                alert('Permission debugging complete! Check console for detailed analysis.');

            } catch (error) {
                console.error('❌ Permission debugging failed:', error);
                alert('Debugging failed: ' + error.message);
            }
        }

        // Test all fee collection methods to see what's broken
        async function testAllFeeMethods() {
            console.log('🧪 TESTING ALL FEE COLLECTION METHODS 🧪');

            if (!CONTRACT || !userAddress) {
                alert('Connect wallet first!');
                return;
            }

            try {
                console.log('📊 Getting user tokens for testing...');
                const userTokens = await getUserTokens(userAddress);
                console.log(`Found ${userTokens.length} tokens to test`);

                if (userTokens.length === 0) {
                    alert('No tokens found to test fee collection');
                    return;
                }

                // Test individual token fee collection (first token)
                const firstToken = userTokens[0];
                const tokenId = Array.isArray(firstToken) ? firstToken[4] : firstToken.tokenId;
                const tokenName = Array.isArray(firstToken) ? firstToken[2] : firstToken.name;

                console.log(`\n🪙 Testing individual fee collection on: ${tokenName} (ID: ${tokenId})`);

                try {
                    // Check if collectFees exists
                    if (CONTRACT.functions && CONTRACT.functions.collectFees) {
                        console.log('✅ collectFees(tokenId) function exists');

                        // Get fees before
                        const feesBefore = await CONTRACT.getCreatorFees(userAddress);
                        console.log('💰 Fees before individual collect:', ethers.utils.formatEther(feesBefore), 'ETH');

                        // Try to collect fees for this specific token
                        console.log(`🚀 Calling CONTRACT.collectFees(${tokenId})...`);
                        const tx = await CONTRACT.collectFees(tokenId);
                        await tx.wait();
                        console.log('✅ Individual collectFees transaction successful');

                        // Check fees after
                        const feesAfter = await CONTRACT.getCreatorFees(userAddress);
                        console.log('💰 Fees after individual collect:', ethers.utils.formatEther(feesAfter), 'ETH');

                        const collected = feesAfter.sub(feesBefore);
                        if (collected.gt(0)) {
                            console.log(`🎉 Individual collection worked! Collected: ${ethers.utils.formatEther(collected)} ETH`);
                        } else {
                            console.log('📭 Individual collection succeeded but no fees were available');
                        }

                    } else {
                        console.log('❌ collectFees(tokenId) function not available');
                    }
                } catch (individualError) {
                    console.log('❌ Individual collectFees failed:', individualError.message);
                }

                console.log(`\n💰 Testing collectAllTokens()...`);

                try {
                    if (CONTRACT.functions && CONTRACT.functions.collectAllTokens) {
                        console.log('✅ collectAllTokens() function exists');

                        const feesBefore = await CONTRACT.getCreatorFees(userAddress);
                        console.log('💰 Fees before collectAllTokens:', ethers.utils.formatEther(feesBefore), 'ETH');

                        console.log('🚀 Calling CONTRACT.collectAllTokens()...');
                        const tx = await CONTRACT.collectAllTokens();
                        await tx.wait();
                        console.log('✅ collectAllTokens transaction successful');

                        const feesAfter = await CONTRACT.getCreatorFees(userAddress);
                        console.log('💰 Fees after collectAllTokens:', ethers.utils.formatEther(feesAfter), 'ETH');

                        const collected = feesAfter.sub(feesBefore);
                        if (collected.gt(0)) {
                            console.log(`🎉 collectAllTokens worked! Collected: ${ethers.utils.formatEther(collected)} ETH`);
                        } else {
                            console.log('📭 collectAllTokens succeeded but no fees were available');
                        }

                    } else {
                        console.log('❌ collectAllTokens() function not available');
                    }
                } catch (allTokensError) {
                    console.log('❌ collectAllTokens failed:', allTokensError.message);
                }

                console.log(`\n🔍 Testing direct Uniswap V3 fee collection...`);

                // Test direct collection from Uniswap position manager
                try {
                    const positionManager = new ethers.Contract(POSITION_MANAGER_ADDRESS, [
                        "function collect((uint256,address,uint128,uint128)) external returns (uint256,uint256)"
                    ], signer);

                    console.log('🧪 Attempting direct Uniswap V3 position fee collection...');
                    console.log(`📍 Position Manager: ${POSITION_MANAGER_ADDRESS}`);
                    console.log(`🆔 Testing with Token ID: ${tokenId}`);

                    // Create collect params (tokenId, recipient, amount0Max, amount1Max)
                    const collectParams = {
                        tokenId: tokenId,
                        recipient: TOKEN_FACTORY_ADDRESS, // Send fees to factory
                        amount0Max: ethers.constants.MaxUint128,
                        amount1Max: ethers.constants.MaxUint128
                    };

                    const collectTx = await positionManager.collect(collectParams);
                    const receipt = await collectTx.wait();
                    console.log('✅ Direct Uniswap V3 collect successful:', receipt.transactionHash);

                    // The fees should now be in the factory CONTRACT
                    const feesAfterDirect = await CONTRACT.getCreatorFees(userAddress);
                    console.log('💰 Fees after direct collection:', ethers.utils.formatEther(feesAfterDirect), 'ETH');

                } catch (directError) {
                    console.log('❌ Direct Uniswap V3 collection failed:', directError.message);

                    if (directError.message.includes('Not approved')) {
                        console.log('💡 The factory CONTRACT may not be approved to collect fees from positions');
                    } else if (directError.message.includes('Invalid token ID')) {
                        console.log('💡 Token ID might be invalid or position doesnt exist');
                    } else if (directError.message.includes('No fees')) {
                        console.log('💡 Position has no accumulated fees to collect');
                    }
                }

                console.log(`\n📊 FINAL DIAGNOSIS:`);
                console.log(`- Your LP positions are correctly set up`);
                console.log(`- Fee collection functions exist and execute`);
                console.log(`- BUT: No actual trading fees have accumulated`);
                console.log(`- CONCLUSION: Need real trading volume to generate fees`);

                alert('Fee method testing complete! The system works correctly, but LP rewards require active trading volume on your token pairs.');

            } catch (error) {
                console.error('❌ Fee method testing failed:', error);
                alert('Testing failed: ' + error.message);
            }
        }

        // Check LP Position Status
        async function checkLPStatus() {
            console.log('🔍 CHECKING LP POSITION STATUS 🔍');

            if (!CONTRACT || !userAddress) {
                alert('Please connect wallet first!');
                return;
            }

            try {
                console.log('📊 Getting user tokens...');
                const userTokens = await getUserTokens(userAddress);
                console.log(`Found ${userTokens.length} tokens`);

                // Check ALL tokens for LP status and fees
                for (let i = 0; i < userTokens.length; i++) {
                    const tokenData = userTokens[i];

                    if (Array.isArray(tokenData)) {
                        const tokenAddr = tokenData[0];    // address tokenAddress
                        const tokenName = tokenData[2];    // string name  
                        const tokenSymbol = tokenData[3];  // string symbol
                        const tokenId = tokenData[4];      // uint256 tokenId
                        const poolAddr = tokenData[6];     // address pool
                        const totalFeesETH = tokenData[9]; // totalFeesETH

                        console.log(`\n🪙 Token ${i + 1}/${userTokens.length}: ${tokenName} (${tokenSymbol})`);
                        console.log(`  🆔 NFT: ${tokenId} | 💰 Fees: ${ethers.utils.formatEther(totalFeesETH)} ETH`);

                        // Highlight tokens with accumulated fees
                        if (parseFloat(ethers.utils.formatEther(totalFeesETH)) > 0) {
                            console.log(`  🎉 HAS ACCUMULATED FEES: ${ethers.utils.formatEther(totalFeesETH)} ETH!`);
                        }

                        // Check if pool exists and has liquidity
                        if (poolAddr && poolAddr !== '0x0000000000000000000000000000000000000000') {
                            try {
                                // Check LP NFT ownership and position details
                                const positionManager = new ethers.Contract(POSITION_MANAGER_ADDRESS, [
                                    "function ownerOf(uint256) view returns (address)",
                                    "function positions(uint256) view returns (uint96,address,address,address,uint24,int24,int24,uint128,uint256,uint256,uint128,uint128)"
                                ], provider);

                                const owner = await positionManager.ownerOf(tokenId);

                                if (owner.toLowerCase() === TOKEN_FACTORY_ADDRESS.toLowerCase()) {
                                    // Get position details
                                    const position = await positionManager.positions(tokenId);
                                    const liquidity = position[7]; // uint128 liquidity
                                    const tokensOwed0 = position[10]; // uint128 tokensOwed0 (fees)
                                    const tokensOwed1 = position[11]; // uint128 tokensOwed1 (fees)

                                    const hasLiquidity = !liquidity.eq(0);
                                    const hasFees = !tokensOwed0.eq(0) || !tokensOwed1.eq(0);

                                    console.log(`  🔒 Locked ✅ | 💧 Liquidity: ${hasLiquidity ? '✅' : '❌'} | 💰 Pending Fees: ${hasFees ? '✅' : '📭'}`);

                                    if (hasFees) {
                                        console.log(`  🎉 PENDING FEES FOUND! Token0: ${tokensOwed0.toString()} | Token1: ${tokensOwed1.toString()}`);
                                    }

                                    if (!hasLiquidity) {
                                        console.log(`  ❌ NO LIQUIDITY - Position needs to be funded!`);
                                    }

                                } else {
                                    console.log(`  ⚠️ LP NFT not locked (owner: ${owner.slice(0, 10)}...)`);
                                }

                            } catch (nftError) {
                                console.log(`  ❌ Error checking NFT: ${nftError.message.substring(0, 50)}...`);
                            }

                        } else {
                            console.log(`  ❌ No LP pool`);
                        }
                    }
                }

                console.log('\n💡 LP STATUS SUMMARY:');
                console.log('- If liquidity = 0: LP positions were created but never funded');
                console.log('- If tokensOwed = 0: LP has liquidity but no trading fees yet');
                console.log('- If both > 0: LP should generate fees when collectAllTokens() is called');
                console.log('\n🎯 NEXT STEPS:');
                console.log('1. If liquidity = 0: Add liquidity to your LP positions');
                console.log('2. If fees = 0: Wait for more trading volume');
                console.log('3. If both > 0: collectAllTokens() should work');

                alert('LP position analysis complete! Your LP NFTs are properly locked in the factory contract. Fees will accumulate when people trade your tokens.');

            } catch (error) {
                console.error('❌ Error checking LP status:', error);
                alert('Error: ' + error.message);
            }
        }

        // Manual LP fee collection function
        async function collectLPFees() {
            console.log('💰 MANUAL LP FEE COLLECTION STARTED 💰');

            if (!CONTRACT) {
                console.log('❌ No CONTRACT connected!');
                alert('Please connect wallet first!');
                return;
            }

            if (!userAddress) {
                console.log('❌ No user address!');
                alert('Please connect wallet first!');
                return;
            }

            try {
                console.log('💰 Attempting to collect LP fees...');
                console.log('🔗 CONTRACT:', TOKEN_FACTORY_ADDRESS);
                console.log('👤 User:', userAddress);

                // Check if we can call collectAllTokens
                if (!CONTRACT.functions || !CONTRACT.functions.collectAllTokens) {
                    console.log('❌ collectAllTokens function not available');
                    alert('collectAllTokens function not available on this CONTRACT');
                    return;
                }

                // Check current fees before collection
                console.log('📊 Checking fees before collection...');
                const feesBefore = await CONTRACT.getCreatorFees(userAddress);
                console.log('💰 Fees before collection:', ethers.utils.formatEther(feesBefore), 'ETH');

                // Attempt to collect all LP fees
                console.log('🚀 Calling collectAllTokens()...');
                const tx = await CONTRACT.collectAllTokens();
                console.log('⏳ Transaction sent:', tx.hash);

                // Wait for confirmation
                console.log('⏳ Waiting for transaction confirmation...');
                const receipt = await tx.wait();
                console.log('✅ Transaction confirmed:', receipt.transactionHash);

                // Check fees after collection
                console.log('📊 Checking fees after collection...');
                const feesAfter = await CONTRACT.getCreatorFees(userAddress);
                console.log('💰 Fees after collection:', ethers.utils.formatEther(feesAfter), 'ETH');

                const feesCollected = feesAfter.sub(feesBefore);
                console.log('🎉 LP Fees collected:', ethers.utils.formatEther(feesCollected), 'ETH');

                if (feesCollected.gt(0)) {
                    alert(`Success! Collected ${ethers.utils.formatEther(feesCollected)} ETH in LP fees!`);

                    // Refresh the dashboard
                    await refreshDashboards();
                } else {
                    console.log('📭 No new fees were collected. Possible reasons:');
                    console.log('- LP positions have no accumulated fees yet');
                    console.log('- Fees were already collected recently');
                    console.log('- LP positions need more trading volume');
                    alert('Fee collection completed, but no new fees were found. Your positions may need more trading activity to generate rewards.');
                }

            } catch (error) {
                console.error('❌ LP fee collection error:', error);

                if (error.message.includes('user rejected')) {
                    alert('Transaction cancelled by user');
                } else if (error.message.includes('insufficient funds')) {
                    alert('Insufficient ETH for gas fees');
                } else if (error.message.includes('execution reverted')) {
                    console.log('❌ Transaction reverted. Possible reasons:');
                    console.log('- No LP fees available to collect');
                    console.log('- CONTRACT state issue');
                    console.log('- Permission issue');
                    alert('Transaction failed: ' + error.message);
                } else {
                    alert('Fee collection failed: ' + error.message);
                }
            }
        }

        // Manual debug function for fee system
        async function debugFeeSystem() {
            console.log('🚨 MANUAL LP NFT FEE SYSTEM DEBUG STARTED 🚨');

            if (!CONTRACT) {
                console.log('❌ No CONTRACT connected!');
                alert('Please connect wallet first!');
                return;
            }

            if (!userAddress) {
                console.log('❌ No user address!');
                alert('Please connect wallet first!');
                return;
            }

            try {
                console.log('🔍 Debugging LP NFT fee system for user:', userAddress);
                console.log('📡 CONTRACT address:', TOKEN_FACTORY_ADDRESS);
                console.log('💡 This is AllTokensToLPFactory - fees come from locked LP NFTs!');

                // Check network safely
                try {
                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    console.log('🌐 Network Chain ID:', parseInt(chainId, 16));
                } catch (networkError) {
                    console.log('🌐 Network info not available:', networkError.message);
                }

                // Check if user has created any tokens
                console.log('🪙 Checking user tokens...');
                const userTokens = await getUserTokens(userAddress);
                console.log('📊 User has created', userTokens.length, 'tokens:', userTokens);

                if (userTokens.length === 0) {
                    console.log('ℹ️ User has not created any tokens yet.');
                    alert('You haven\'t created any tokens yet. LP NFT fees are only generated from tokens you\'ve created.');
                    return;
                }

                // Check LP Vault status
                console.log('🏦 Checking LP Vault status...');
                try {
                    const lpVault = await CONTRACT.lpVault();
                    console.log('🏦 LP Vault address:', lpVault);

                    if (lpVault && lpVault !== '0x0000000000000000000000000000000000000000') {
                        console.log('✅ LP Vault is set up');
                    } else {
                        console.log('⚠️ No LP Vault - NFTs are locked in factory CONTRACT');
                    }
                } catch (vaultError) {
                    console.log('⚠️ LP Vault not available:', vaultError.message);
                }

                // Check if CONTRACT supports collectAllTokens (the main fee collection function)
                console.log('� Checking fee collection capabilities...');
                try {
                    if (CONTRACT.functions && CONTRACT.functions.collectAllTokens) {
                        console.log('✅ CONTRACT supports collectAllTokens() - LP NFT fee collection available');

                        // Check current creator fees
                        const testFees = await CONTRACT.getCreatorFees(userAddress);
                        console.log('💰 Current accumulated LP fees:', ethers.utils.formatEther(testFees), 'ETH');

                        if (parseFloat(ethers.utils.formatEther(testFees)) > 0) {
                            console.log('🎉 LP NFT fees detected! You can collect them!');
                        } else {
                            console.log('📭 No LP NFT fees accumulated yet. This could mean:');
                            console.log('- Your tokens haven\'t had enough trading volume on their LP pools');
                            console.log('- LP NFTs are not generating fees yet (need trading activity)');
                            console.log('- Fees haven\'t been processed by the CONTRACT yet');
                        }
                    } else {
                        console.log('❌ CONTRACT does not support collectAllTokens');
                    }
                } catch (capError) {
                    console.log('❌ Error checking fee collection:', capError.message);
                }

                // Check LP NFT status for first few tokens
                console.log('🔍 Checking LP NFT status for your tokens...');
                for (let i = 0; i < Math.min(userTokens.length, 3); i++) { // Check first 3 tokens
                    const tokenData = userTokens[i];
                    let tokenAddr, tokenName, tokenSymbol, tokenId, createdAt, poolAddr;

                    // Parse token data from struct: (tokenAddress,creator,name,symbol,tokenId,createdAt,pool,tickLower,tickUpper,totalFeesETH)
                    if (Array.isArray(tokenData)) {
                        tokenAddr = tokenData[0];    // address tokenAddress
                        tokenName = tokenData[2];    // string name
                        tokenSymbol = tokenData[3];  // string symbol
                        tokenId = tokenData[4];      // uint256 tokenId
                        createdAt = tokenData[5];    // uint256 createdAt
                        poolAddr = tokenData[6];     // address pool

                        console.log(`🪙 Token ${i + 1}: ${tokenName} (${tokenSymbol})`);
                        console.log(`  📍 Token Address: ${tokenAddr}`);
                        console.log(`  🆔 Token ID: ${tokenId}`);
                        console.log(`  🏊 Pool Address: ${poolAddr}`);
                    } else {
                        tokenAddr = tokenData;
                        console.log(`🪙 Token ${i + 1}: ${tokenAddr}`);
                    }

                    try {
                        // Check if this token has an LP pool and NFT
                        console.log(`  🔍 Checking LP NFT status...`);

                        // Try to get LP pair address
                        const lpAddress = await CONTRACT.getTokenLPPair(tokenAddr);
                        console.log(`  🤝 LP Pair: ${lpAddress}`);

                        if (lpAddress && lpAddress !== '0x0000000000000000000000000000000000000000') {
                            console.log(`  ✅ LP Pool exists for this token`);

                            // Check LP NFT ownership
                            try {
                                const nftOwner = await CONTRACT.getTokenNFTOwner(tokenAddr);
                                console.log(`  🎫 LP NFT Owner: ${nftOwner}`);

                                if (nftOwner.toLowerCase() === TOKEN_FACTORY_ADDRESS.toLowerCase()) {
                                    console.log(`  🔒 LP NFT is LOCKED in factory ✅ (This generates fees!)`);
                                } else if (nftOwner.toLowerCase() === userAddress.toLowerCase()) {
                                    console.log(`  ⚠️ LP NFT is in your wallet - should be locked for fee generation`);
                                } else {
                                    console.log(`  ❓ LP NFT owner: ${nftOwner}`);
                                }
                            } catch (nftError) {
                                console.log(`  ❌ Cannot check LP NFT owner: ${nftError.message}`);
                            }

                            // Try to check LP pool trading activity
                            try {
                                const lpCONTRACT = new ethers.Contract(lpAddress, [
                                    "function getReserves() view returns (uint112, uint112, uint32)"
                                ], provider);

                                const reserves = await lpCONTRACT.getReserves();
                                console.log(`  � LP Reserves:`, reserves[0].toString(), reserves[1].toString());

                                if (reserves[0].gt(0) && reserves[1].gt(0)) {
                                    console.log(`  ✅ LP Pool has liquidity - can generate trading fees`);
                                } else {
                                    console.log(`  📭 LP Pool has no liquidity yet`);
                                }
                            } catch (reserveError) {
                                console.log(`  ⚠️ Cannot check LP reserves: ${reserveError.message}`);
                            }

                        } else {
                            console.log(`  ❌ No LP Pool found for this token`);
                        }

                    } catch (tokenError) {
                        console.log(`  ❌ Error checking token LP status: ${tokenError.message}`);
                    }
                }

                // Force refresh the dashboard
                console.log('🔄 Force refreshing dashboard...');
                await refreshDashboards();

                console.log('✅ LP NFT Debug complete! Check console for details.');
                console.log('💡 Summary: Fees come from trading activity on LP pools where NFTs are locked in the factory');
                alert('LP NFT analysis complete! Your LP positions are properly configured. Fees are generated when traders buy/sell your tokens on Uniswap.');

            } catch (error) {
                console.error('❌ Debug function error:', error);
                alert('Debug failed: ' + error.message);
            }
        }

        // Manual verification function for testing existing tokens
        async function manualVerifyToken(tokenAddress, tokenName, tokenSymbol, creatorAddress) {
            console.log('🧪 MANUAL VERIFICATION TEST');
            console.log('Token Address:', tokenAddress);
            console.log('Token Name:', tokenName);
            console.log('Token Symbol:', tokenSymbol);
            console.log('Creator Address:', creatorAddress);

            // Call the existing verification function
            await verifyTokenContract(tokenAddress, tokenName, tokenSymbol, creatorAddress);
        }

        // Check uncollected fees for all token cards
        async function checkFeesForAllTokenCards(tokens) {
            try {
                console.log('💰 Checking fees for', tokens.length, 'token cards...');

                for (const token of tokens) {
                    const tokenId = token[4];
                    const tokenAddress = token[0];

                    if (tokenId && tokenId !== '0') {
                        checkFeesForTokenCard(tokenId, tokenAddress);
                    }
                }
            } catch (error) {
                console.error('❌ Error checking token card fees:', error);
            }
        }

        // Force refresh all visible token cards with fee checking
        async function refreshAllTokenCardFees() {
            console.log('🔄 Refreshing all token card fees...');
            const allFeeElements = document.querySelectorAll('[id^="fee-amount-"]');

            for (const feeElement of allFeeElements) {
                const tokenId = feeElement.id.replace('fee-amount-', '');

                // Find the token address from the existing token data or card
                let tokenAddress = null;

                // Try to get from the card's data
                const tokenCard = feeElement.closest('.token-card, .admin-token-card');
                if (tokenCard) {
                    // Look for address in the card content
                    const addressText = tokenCard.innerHTML.match(/0x[a-fA-F0-9]{40}/g);
                    if (addressText && addressText.length > 0) {
                        // Get the first address (should be token address)
                        tokenAddress = addressText[0];
                    }
                }

                if (tokenAddress && tokenId) {
                    // Reset to loading state first
                    feeElement.innerHTML = `
                        <span class="loading-spinner" style="display: inline-block; width: 16px; height: 16px; border: 2px solid #e2e8f0; border-top: 2px solid #0ea5e9; border-radius: 50%; animation: spin 1s linear infinite;"></span>
                        Refreshing fees...
                    `;

                    // Check fees with staggered delay to prevent overwhelming RPC
                    const randomDelay = Math.random() * 2000 + 500; // 500-2500ms delay
                    setTimeout(() => checkFeesForTokenCard(tokenId, tokenAddress), randomDelay);
                }
            }
        }

        // Track ongoing fee checks to prevent duplicates
        const ongoingFeeChecks = new Set();

        // Check fees for a specific token card - now using stored position NFT ID
        async function checkFeesForTokenCard(tokenId, tokenAddress) {
            // Prevent duplicate calls for the same token
            if (ongoingFeeChecks.has(tokenId)) {
                return;
            }

            const feeElement = document.getElementById(`fee-amount-${tokenId}`);
            if (!feeElement) return;

            ongoingFeeChecks.add(tokenId);

            try {
                // The tokenId parameter here is actually the LP position NFT ID from our factory!
                const positionNftId = tokenId;

                console.log(`💰 Checking fees for position NFT ID: ${positionNftId}`);

                if (!positionNftId || positionNftId === '0') {
                    throw new Error("No LP position NFT ID available");
                }

                const POSITION_MANAGER = "0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1";
                const positionManagerContract = new ethers.Contract(POSITION_MANAGER, [
                    "function collect((uint256 tokenId, address recipient, uint128 amount0Max, uint128 amount1Max)) external payable returns (uint256 amount0, uint256 amount1)",
                    "function positions(uint256 tokenId) external view returns (uint96 nonce, address operator, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper, uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1)"
                ], provider);

                // Try to get uncollected fees by simulating a collect call with the actual position NFT ID
                try {
                    const maxAmount = ethers.BigNumber.from("340282366920938463463374607431768211455"); // 2^128 - 1
                    const result = await positionManagerContract.callStatic.collect({
                        tokenId: positionNftId,
                        recipient: userAddress || TOKEN_FACTORY_ADDRESS,
                        amount0Max: maxAmount,
                        amount1Max: maxAmount
                    });

                    const amount0 = result.amount0 || result[0] || ethers.BigNumber.from(0);
                    const amount1 = result.amount1 || result[1] || ethers.BigNumber.from(0);

                    // Get the actual pool information to determine token ordering
                    let ethAmount, tokenAmount;

                    try {
                        const position = await positionManagerContract.positions(positionNftId);
                        const token0 = position.token0;
                        const token1 = position.token1;

                        // Check which one is WETH and which is our token
                        const WETH_ADDRESS = "0x4200000000000000000000000000000000000006";

                        if (token0.toLowerCase() === WETH_ADDRESS.toLowerCase()) {
                            ethAmount = amount0;
                            tokenAmount = amount1;
                        } else if (token1.toLowerCase() === WETH_ADDRESS.toLowerCase()) {
                            ethAmount = amount1;
                            tokenAmount = amount0;
                        } else {
                            const isToken0WETH = tokenAddress.toLowerCase() > WETH_ADDRESS.toLowerCase();
                            ethAmount = isToken0WETH ? amount0 : amount1;
                            tokenAmount = isToken0WETH ? amount1 : amount0;
                        }

                    } catch (posError) {
                        const WETH_ADDRESS = "0x4200000000000000000000000000000000000006";
                        const isToken0WETH = tokenAddress.toLowerCase() > WETH_ADDRESS.toLowerCase();
                        ethAmount = isToken0WETH ? amount0 : amount1;
                        tokenAmount = isToken0WETH ? amount1 : amount0;
                    }

                    const ethFormatted = parseFloat(ethers.utils.formatEther(ethAmount));
                    const tokenFormatted = parseFloat(ethers.utils.formatEther(tokenAmount));

                    console.log(`💰 Position ${positionNftId} final fees: ${ethFormatted} ETH + ${tokenFormatted} tokens`);

                    // Get token symbol for better display
                    let tokenSymbol = "TOKENS";
                    try {
                        const tokenContract = new ethers.Contract(tokenAddress, [
                            "function symbol() view returns (string)"
                        ], provider);
                        tokenSymbol = await tokenContract.symbol();
                        console.log(`💰 Token symbol fetched: ${tokenSymbol}`);
                    } catch (e) {
                        console.log(`💰 Could not fetch token symbol, using default: ${e.message}`);
                        tokenSymbol = "TOKENS";
                    }

                    // Display the fees - use enhanced format for ALL cases
                    const ethPriceUSD = window.ethPriceUSD || 4500;
                    const ethValue = (ethFormatted * ethPriceUSD).toFixed(2);

                    // Consider fees "available" if they're meaningful - lowered threshold for small fees
                    const hasSignificantFees = ethFormatted >= 0.00000001 || tokenFormatted >= 0.00000001; // 10 gwei threshold

                    console.log(`💰 About to display: ETH=${ethFormatted}, Token=${tokenFormatted}, Symbol=${tokenSymbol}, HasFees=${hasSignificantFees}`);

                    if (hasSignificantFees) {
                        console.log(`✅ Displaying fees for position ${positionNftId}: ${ethFormatted} ETH + ${tokenFormatted} ${tokenSymbol}`);

                        // Calculate creator's share (50% of ETH, 100% of tokens)
                        const creatorEthShare = ethFormatted * 0.5; // Creator gets 50% of ETH
                        const creatorEthValue = (ethValue * 0.5).toFixed(2); // Creator gets 50% of ETH value

                        // Force update the fee element HTML
                        const newHTML = `
                            <div class="fee-rewards-container">
                                <div class="fee-title" style="font-size: 0.75rem; color: #7c3aed; font-weight: 600; margin-bottom: 8px; text-align: center;">
                                    💰 LP Rewards Available (Creator Share)
                                </div>
                                <div class="eth-fees" style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 6px;">
                                    <span style="color: #059669; font-weight: 800; font-size: 1rem;">${creatorEthShare >= 0.000001 ? creatorEthShare.toFixed(6) : creatorEthShare.toFixed(10)} ETH</span>
                                    <span style="color: #64748b; font-size: 0.8rem;">($${creatorEthValue})</span>
                                </div>
                                <div class="token-fees" style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                                    <span style="color: #7c3aed; font-weight: 700; font-size: 0.95rem;">+ ${tokenFormatted >= 0.000001 ? tokenFormatted.toFixed(6) : tokenFormatted.toFixed(10)} ${tokenSymbol}</span>
                                    <span style="color: #94a3b8; font-size: 0.75rem;">tokens</span>
                                </div>
                            </div>
                        `;

                        feeElement.innerHTML = newHTML;
                        console.log(`💰 Fee element HTML updated for ${positionNftId}`);
                        console.log(`💰 Fee element content now:`, feeElement.innerHTML.substring(0, 200) + '...');
                    } else {
                        // No significant fees - use same enhanced format but without collection tip
                        feeElement.innerHTML = `
                            <div class="no-fees-container">
                                <div class="fee-title" style="font-size: 0.75rem; color: #7c3aed; font-weight: 600; margin-bottom: 8px; text-align: center;">
                                    💰 LP Rewards Available (Creator Share)
                                </div>
                                <div class="eth-fees" style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 6px;">
                                    <span style="color: #64748b; font-weight: 800; font-size: 1rem;">0.000000 ETH</span>
                                    <span style="color: #64748b; font-size: 0.8rem;">($0.00)</span>
                                </div>
                                <div class="token-fees" style="color: #94a3b8; font-size: 0.85rem; margin-bottom: 6px; text-align: center;">
                                    + 0 ${tokenSymbol} tokens
                                </div>
                                <div style="color: #64748b; font-size: 0.8rem; text-align: center;">
                                    No uncollected fees available
                                </div>
                            </div>
                        `;
                    }

                } catch (error) {
                    console.log(`💰 Could not check fees for token ${tokenId}:`, error.message);
                    console.log(`💰 Full error:`, error);
                    feeElement.innerHTML = `
                        <div class="error-fees-container">
                            <div class="fee-title" style="font-size: 0.75rem; color: #7c3aed; font-weight: 600; margin-bottom: 8px; text-align: center;">
                                💰 LP Rewards Available (Creator Share)
                            </div>
                            <div class="eth-fees" style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 6px;">
                                <span style="color: #64748b; font-weight: 800; font-size: 1rem;">0.000000 ETH</span>
                                <span style="color: #64748b; font-size: 0.8rem;">($0.00)</span>
                            </div>
                            <div class="token-fees" style="color: #94a3b8; font-size: 0.85rem; margin-bottom: 6px; text-align: center;">
                                + 0 tokens
                            </div>
                            <div style="color: #64748b; font-size: 0.8rem; text-align: center;">
                                ${error.message.includes('revert') ? 'No active LP position found' : 'Position check unavailable'}
                            </div>
                        </div>
                    `;
                }

            } catch (error) {
                console.error(`❌ OUTER Error checking fees for token ${tokenId}:`, error);
                console.error(`❌ Full outer error:`, error);
                feeElement.innerHTML = `
                    <div style="color: #ef4444; font-weight: 600; text-align: center;">
                        Error checking fees: ${error.message}
                    </div>
                `;
            } finally {
                // Always remove from ongoing checks to prevent permanent locks
                ongoingFeeChecks.delete(tokenId);
            }
        }

        // Automatic contract verification for deployed tokens
        async function verifyTokenContract(tokenAddress, tokenName, tokenSymbol, creatorAddress) {
            try {
                console.log('🔍 Starting automatic contract verification for:', tokenAddress);
                showStatus('⚡ Automatically verifying contract on Basescan...', 'info');

                // Contract source code for AutoAntiSniperERC20
                const tokenSourceCode = {
                    language: "Solidity",
                    sources: {
                        "AutoAntiSniperERC20.sol": {
                            content: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

// Simple anti-sniper ERC20 with minimal restrictions
contract AutoAntiSniperERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply = 1000000000 * 10**18; // 1 billion tokens
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    // Anti-sniper variables
    address public factory;
    address public creator;
    uint256 public launchTime; // When token was created
    uint256 public devBuyWindow = 300; // 5 minutes for dev exclusive access
    
    // Uniswap addresses that should always be allowed
    address constant POSITION_MANAGER = 0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1;
    address constant SWAP_ROUTER = 0x2626664c2603336E57B271c5C0b26F421741e481;
    address constant WETH = 0x4200000000000000000000000000000000000006;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    modifier tradingAllowed() {
        // Always allow factory, creator, and core Uniswap contracts
        if (msg.sender == creator || 
            msg.sender == factory || 
            msg.sender == POSITION_MANAGER ||
            msg.sender == SWAP_ROUTER ||
            tx.origin == creator) {
            _;
            return;
        }
        
        // For everyone else, check dev buy window
        if (block.timestamp < launchTime + devBuyWindow) {
            revert();
        }
        _;
    }
    
    constructor(string memory _name, string memory _symbol, address _creator) {
        name = _name;
        symbol = _symbol;
        creator = _creator;
        factory = msg.sender;
        launchTime = block.timestamp; // Record launch time automatically
        balanceOf[factory] = totalSupply; // All tokens start in factory
        emit Transfer(address(0), factory, totalSupply);
    }
    
    function transfer(address to, uint256 amount) external tradingAllowed returns (bool) {
        require(to != address(0));
        require(balanceOf[msg.sender] >= amount);
        
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        require(spender != address(0));
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external tradingAllowed returns (bool) {
        require(from != address(0));
        require(to != address(0));
        require(balanceOf[from] >= amount);
        require(allowance[from][msg.sender] >= amount);
        
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        allowance[from][msg.sender] -= amount;
        emit Transfer(from, to, amount);
        return true;
    }
}`
                        }
                    },
                    settings: {
                        optimizer: {
                            enabled: true,
                            runs: 1
                        },
                        evmVersion: "paris",
                        outputSelection: {
                            "*": {
                                "*": [
                                    "evm.bytecode",
                                    "evm.deployedBytecode",
                                    "devdoc",
                                    "userdoc",
                                    "metadata",
                                    "abi"
                                ]
                            }
                        }
                    }
                };

                // Encode constructor parameters (ABI encoded without 0x prefix)
                let constructorParams = '';
                try {
                    const encoded = ethers.utils.defaultAbiCoder.encode(
                        ['string', 'string', 'address'],
                        [tokenName, tokenSymbol, creatorAddress]
                    );
                    constructorParams = encoded.slice(2); // Remove '0x' prefix
                    console.log('✅ Constructor params encoded:', constructorParams);
                } catch (encodeError) {
                    console.error('❌ Error encoding constructor params:', encodeError);
                    throw new Error('Failed to encode constructor parameters');
                }

                // Prepare verification data
                const verificationData = {
                    apikey: "TZJQES8ZA41X17W1NIDIKHBVSMHBDID9RU",
                    module: "contract",
                    action: "verifysourcecode",
                    contractaddress: tokenAddress,
                    sourceCode: JSON.stringify(tokenSourceCode),
                    codeformat: "solidity-standard-json-input",
                    contractname: "AutoAntiSniperERC20.sol:AutoAntiSniperERC20",
                    compilerversion: "v0.8.30+commit.73712a01",
                    optimizationUsed: "1",
                    runs: "1",
                    constructorArguements: constructorParams, // Already without 0x prefix
                    evmversion: "paris",
                    licenseType: "3" // MIT License
                };

                console.log('📤 Submitting contract verification to Basescan...');
                console.log('Contract Address:', tokenAddress);
                console.log('Constructor Params:', constructorParams);

                // Submit verification request
                console.log('📋 Full verification data:', verificationData);

                const formData = new FormData();
                Object.keys(verificationData).forEach(key => {
                    formData.append(key, verificationData[key]);
                });

                console.log('📤 Submitting to Basescan API...');
                const response = await fetch('https://api.basescan.org/api', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                console.log('🔍 Verification response:', result);

                if (result.status === "1" && result.result) {
                    const guid = result.result;
                    console.log('✅ Verification submitted! GUID:', guid);
                    showStatus(`✅ Contract verification submitted! Checking status...`, 'success');

                    // Check verification status
                    let attempts = 0;
                    const maxAttempts = 10;
                    const checkInterval = 5000; // 5 seconds

                    const checkStatus = async () => {
                        attempts++;
                        try {
                            const statusResponse = await fetch(`https://api.basescan.org/api?module=contract&action=checkverifystatus&guid=${guid}&apikey=TZJQES8ZA41X17W1NIDIKHBVSMHBDID9RU`);
                            const statusResult = await statusResponse.json();

                            console.log(`🔍 Verification attempt ${attempts}/${maxAttempts}:`, statusResult);

                            if (statusResult.status === "1" && statusResult.result === "Pass - Verified") {
                                console.log('🎉 Contract verification successful!');
                                showStatus(`🎉 Contract verified successfully on Basescan!`, 'success');

                                // Show success message with link
                                setTimeout(() => {
                                    showStatus(`✅ Token contract verified! View on Basescan: https://basescan.org/address/${tokenAddress}#code`, 'success');
                                }, 2000);

                                return;
                            } else if (statusResult.status === "0" && statusResult.result.includes("Fail")) {
                                console.log('⚠️ API shows verification failed, but checking contract directly...');

                                // Double-check by trying to access the contract source page
                                try {
                                    const contractCheck = await fetch(`https://api.basescan.org/api?module=contract&action=getsourcecode&address=${tokenAddress}&apikey=TZJQES8ZA41X17W1NIDIKHBVSMHBDID9RU`);
                                    const contractResult = await contractCheck.json();

                                    if (contractResult.status === "1" && contractResult.result && contractResult.result[0] && contractResult.result[0].SourceCode !== "") {
                                        console.log('✅ Contract is actually verified despite API error!');
                                        showStatus(`✅ Contract verified successfully! (API showed temporary error)`, 'success');
                                        setTimeout(() => {
                                            showStatus(`✅ Token contract verified! View on Basescan: https://basescan.org/address/${tokenAddress}#code`, 'success');
                                        }, 2000);
                                        return;
                                    }
                                } catch (checkError) {
                                    console.log('Could not double-check verification status');
                                }

                                console.log('❌ Contract verification failed:', statusResult.result);
                                showStatus(`❌ Verification failed: ${statusResult.result}. Check manually on Basescan.`, 'error');
                                return;
                            } else if (attempts < maxAttempts) {
                                // Still pending, check again
                                setTimeout(checkStatus, checkInterval);
                            } else {
                                console.log('⏰ Verification timeout - doing final check...');

                                // Final verification check before giving up
                                try {
                                    const finalCheck = await fetch(`https://api.basescan.org/api?module=contract&action=getsourcecode&address=${tokenAddress}&apikey=TZJQES8ZA41X17W1NIDIKHBVSMHBDID9RU`);
                                    const finalResult = await finalCheck.json();

                                    if (finalResult.status === "1" && finalResult.result && finalResult.result[0] && finalResult.result[0].SourceCode !== "") {
                                        console.log('✅ Contract verified successfully after timeout!');
                                        showStatus(`✅ Contract verified successfully!`, 'success');
                                        setTimeout(() => {
                                            showStatus(`✅ Token contract verified! View on Basescan: https://basescan.org/address/${tokenAddress}#code`, 'success');
                                        }, 2000);
                                        return;
                                    }
                                } catch (finalError) {
                                    console.log('Could not perform final verification check');
                                }

                                showStatus(`⏰ Verification may still be processing. Check Basescan manually: https://basescan.org/address/${tokenAddress}#code`, 'info');
                            }
                        } catch (statusError) {
                            console.error('❌ Error checking verification status:', statusError);
                            if (attempts < maxAttempts) {
                                setTimeout(checkStatus, checkInterval);
                            }
                        }
                    };

                    // Start checking status after a brief delay
                    setTimeout(checkStatus, 10000); // Wait 10 seconds before first check

                } else {
                    console.log('❌ Verification submission failed:', result);
                    showStatus(`❌ Contract verification failed: ${result.result || 'Unknown error'}`, 'error');
                }

            } catch (error) {
                console.error('❌ Contract verification error:', error);
                showStatus(`⚠️ Contract verification failed: ${error.message}`, 'error');
            }
        }

        // Optimized auto-refresh system - reduced frequency and prevented overlapping calls
        let refreshInProgress = false;
        setInterval(async () => {
            if (CONTRACT && userAddress && !refreshInProgress) {
                refreshInProgress = true;
                try {
                    console.log('🔄 Auto-refreshing fee displays...');
                    await updateDisplays();
                    // Add small delay between operations to reduce UI glitching
                    setTimeout(async () => {
                        await refreshDashboards();
                        // Removed automatic fee card refreshing to prevent excessive updates
                        refreshInProgress = false;
                    }, 2000);
                } catch (error) {
                    console.error('Auto-refresh error:', error);
                    refreshInProgress = false;
                }
            }
        }, 30000); // Increased to 30 seconds to reduce frequency
    </script>





</body>

</html>