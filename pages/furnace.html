<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Token Furnace</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ”¥</text></svg>">
  <!-- Console Filter - Universal console control -->
  <script src="../js/console-filter.js"></script>
  <!-- Legal Disclaimer System - Must load first for compliance -->
  <script src="../js/legal-disclaimer.js"></script>
  <!-- Mobile Debug System - Comprehensive mobile debugging -->
  <script src="../js/mobile-debug.js"></script>
  <!-- Core wallet dependencies -->
  <script src="../js/wallet.js"></script>
  <!-- Mobile Wallet Integration - Clean mobile experience -->
  <script src="../js/mobile-wallet-detector.js"></script>
  <script src="../js/mobile-wallet-integration.js"></script>
  <!-- Environment Configuration -->
  <script src="../js/env-config.js"></script>
  <!-- Production Configuration (GitHub Secrets injection) -->
  <script src="../js/production-config.js?v=20250727"></script>
  <!-- Development Configuration (Fallback endpoints for mobile/wallet browsers) -->
  <script src="../js/dev-config.js"></script>
  <!-- RPC Configuration (must load before API calls) -->
  <script src="../js/rpc-config.js"></script>
  <!-- Performance optimizations for wallet browsers -->
  <script src="../js/wallet-performance.js"></script>
  <!-- API Efficiency Monitoring -->
  <script src="../js/api-audit.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Nosifer&family=Orbitron:wght@900&family=Bangers&family=Creepster&family=UnifrakturMaguntia&family=MedievalSharp&family=Ewert&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="../css/styles.css">

  <style>
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      background: radial-gradient(ellipse at 60% 120%, #ff1a1a 0%, #0a0000 60%, #000 100%),
                  linear-gradient(180deg, #2d0000 0%, #0a0000 100%);
      color: #fffbe7;
      text-shadow: 0 0 4px #000, 0 0 2px #ffae00;
      font-family: 'Orbitron', Arial, sans-serif;
      min-height: 100vh;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      overflow-x: hidden;
      line-height: 1.6;
      /* Add a subtle vignette for depth */
      box-shadow: 0 0 0 100vw #000a inset;
    }
    body::before {
      content: '';
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      z-index: 0;
      pointer-events: none;
      background:
        radial-gradient(circle at 20% 80%, #ffae0033 0%, #ff1a1a11 40%, transparent 80%),
        radial-gradient(circle at 80% 90%, #ff1a1a22 0%, #ffae0011 40%, transparent 80%),
        linear-gradient(180deg, #ff1a1a22 0%, transparent 100%);
      animation: emberBG 8s linear infinite;
      filter: blur(1px) brightness(1.05);
      will-change: filter;
    }
    body::after {
      content: '';
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      z-index: 1;
      pointer-events: none;
      background:
        radial-gradient(circle at 60% 10%, #fff2 0%, transparent 60%),
        radial-gradient(circle at 40% 20%, #ffae0033 0%, transparent 70%),
        linear-gradient(180deg, transparent 80%, #ff1a1a22 100%);
      mix-blend-mode: lighten;
      opacity: 0.32;
      animation: smokeBG 10s linear infinite alternate;
      will-change: filter, opacity;
    }

    /* Performance optimization: Disable heavy animations on mobile and wallet browsers */
    @media (max-width: 768px), (prefers-reduced-motion: reduce) {
      body::before, body::after {
        animation: none !important;
        filter: none !important;
        will-change: auto !important;
        background: 
          radial-gradient(ellipse at 60% 120%, #ff1a1a 0%, #0a0000 60%, #000 100%),
          linear-gradient(180deg, #2d0000 0%, #0a0000 100%);
      }
      
      .header {
        box-shadow: 0 0 32px 8px #ff1a1a66, 0 0 16px #ffae0099; /* Reduced glow */
      }
    }

    /* Detect wallet browsers and reduce animations */
    @supports (font: -webkit-pictograph) {
      /* Webkit-based wallet browsers */
      body::before, body::after {
        animation-duration: 12s !important; /* Slower animations */
        filter: blur(0.5px) brightness(1.02) !important; /* Reduced filter effects */
      }
    }
    /* Performance optimization: Reduce animations on mobile and wallet browsers */
    @media (max-width: 768px), (prefers-reduced-motion: reduce) {
      body::before, body::after {
        animation: none !important;
        filter: none !important;
        will-change: auto !important;
        background: 
          radial-gradient(ellipse at 60% 120%, #ff1a1a 0%, #0a0000 60%, #000 100%),
          linear-gradient(180deg, #2d0000 0%, #0a0000 100%);
      }
    }

    @keyframes emberBG {
      0% { filter: blur(1px) brightness(1.05); }
      50% { filter: blur(1.5px) brightness(1.08); }
      100% { filter: blur(1px) brightness(1.05); }
    }
    @keyframes smokeBG {
      0% { filter: blur(1px) brightness(1.05); opacity: 0.22; }
      100% { filter: blur(1.5px) brightness(1.08); opacity: 0.32; }
    }
    .header {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      background: linear-gradient(90deg, #1a0909 60%, #ff1a1a 100%);
      padding: 48px 0 24px 0;
      margin-bottom: 32px;
      padding-bottom: 0;
      position: relative;
      box-shadow: 0 0 64px 16px #ff1a1a99, 0 0 32px #ffae00cc;
      z-index: 10;
    }
    
    /* Desktop Header Improvements */
    @media (min-width: 1024px) {
      .header {
        padding: 60px 0 32px 0;
        margin-bottom: 24px; /* Reduced from 48px */
      }
      
      .logo {
        font-size: 3.5em;
        margin-bottom: 0.4em;
      }
      
      .wildwest-title {
        font-size: 7.5em !important;
      }
      
      .header::after {
        width: 480px;
        height: 80px;
        background-size: 480px 80px;
      }
      
      @keyframes fireBanner {
        0% { background-position-x: 0; }
        100% { background-position-x: 480px; }
      }
    }
    
    @media (min-width: 1440px) {
      .header {
        padding: 80px 0 40px 0;
        margin-bottom: 32px; /* Reduced from 64px */
      }
      
      .logo {
        font-size: 4em;
      }
      
      .wildwest-title {
        font-size: 8.5em !important;
      }
    }
    .header::after {
      content: '';
      display: block;
      position: absolute;
      left: 50%;
      top: 100%;
      transform: translateX(-50%);
      width: 320px;
      height: 60px;
      background: url('https://svgshare.com/i/14kA.svg') repeat-x bottom/320px 60px;
      opacity: 0.7;
      pointer-events: none;
      animation: fireBanner 2.5s linear infinite;
      z-index: 2;
    }
    @keyframes fireBanner {
      0% { background-position-x: 0; }
      100% { background-position-x: 320px; }
    }
    .logo {
      font-family: 'Nosifer', 'Bangers', 'Orbitron', Arial, sans-serif;
      font-size: 2.7em;
      letter-spacing: 0.08em;
      color: #fffbe7;
      margin-bottom: 0.3em;
      margin-top: 0.2em;
      padding: 0 32px;
      background: rgba(30,0,0,0.92);
      border-radius: 16px;
      /* border: 3px solid #ffae00; */
      box-shadow: 0 0 64px #ffae00, 0 0 32px #ff1a1a, 0 0 8px #fffbe7;
      text-align: center;
      display: block;
      filter: drop-shadow(0 0 16px #ff1a1a) drop-shadow(0 0 8px #ffae00);
      animation: flicker 2.5s infinite alternate;
    }
    @keyframes flicker {
      0% { text-shadow: 0 0 32px #ff1a1a, 0 0 16px #ffae00, 0 0 2px #000; filter: brightness(1.1); }
      50% { text-shadow: 0 0 48px #ffae00, 0 0 32px #ff1a1a, 0 0 8px #fffbe7; filter: brightness(1.3); }
      100% { text-shadow: 0 0 32px #ff1a1a, 0 0 16px #ffae00, 0 0 2px #000; filter: brightness(1.1); }
    }
    .connect-btn {
      margin: 0 auto 0 auto;
      display: block;
      align-self: center;
      font-size: 1.2em;
      padding: 14px 32px;
      border-radius: 12px;
      background: linear-gradient(90deg, #ff1a1a 60%, #ffae00 100%);
      color: #fffbe7;
      border: 2.5px solid #ffae00;
      font-weight: 900;
      box-shadow: 0 0 32px #ff1a1a, 0 0 16px #ffae00, 0 0 8px #fffbe7;
      text-shadow: 0 0 8px #ffae00, 0 0 2px #000;
      transition: box-shadow 0.2s, background 0.2s, transform 0.1s;
      cursor: pointer;
      z-index: 20;
      animation: pulseBtn 2.2s infinite alternate;
      text-transform: uppercase;
      font-family: 'Bangers', 'Ewert', 'Orbitron', cursive, sans-serif;
      letter-spacing: 2.5px;
    }
    @keyframes pulseBtn {
      0% { box-shadow: 0 0 16px #ff1a1a, 0 0 8px #ffae00; }
      100% { box-shadow: 0 0 48px #ffae00, 0 0 24px #ff1a1a; }
    }
    .connect-btn:active {
      transform: scale(0.97);
      background: linear-gradient(90deg, #ffae00 60%, #ff1a1a 100%);
    }
    .connect-btn.connected {
      background: linear-gradient(90deg, #ff4500 60%, #ffae00 100%);
      box-shadow: 0 0 48px #ff1a1a, 0 0 24px #ffae00;
    }
    .burn-container {
      background: linear-gradient(120deg, #1a0909ee 80%, #2d0000ee 100%);
      border-radius: 32px;
      box-shadow: 0 0 96px 24px #ff1a1acc, 0 0 48px #ffae00, 0 0 24px #fffbe7;
      padding: 48px 36px 36px 36px;
      max-width: 440px;
      width: 100%;
      margin: 0 auto 64px auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 3px solid #ffae00;
      gap: 28px;
      position: relative;
      z-index: 2;
      /* Fire reflection */
      overflow: visible;
    }
    
    /* Desktop Layout Improvements */
    @media (min-width: 1024px) {
      .burn-container {
        max-width: 600px;
        padding: 60px 48px 48px 48px;
        gap: 36px;
        margin: 0 auto 80px auto;
      }
      
      .burn-form {
        width: 100%;
        max-width: 500px;
      }
      
      .burn-form input {
        padding: 18px 24px;
        font-size: 1.1rem;
      }
      
      .burn-btn {
        padding: 20px 40px;
        font-size: 1.2rem;
        min-height: 60px;
      }
      
      .burn-title {
        font-size: 3rem;
        margin-bottom: 24px;
      }
      
      .burn-warning {
        font-size: 1.1rem;
        padding: 20px 24px;
        max-width: 500px;
        animation: none !important;
        transition: none !important;
        opacity: 1 !important;
      }
      
      .burn-balance {
        font-size: 1.1rem;
        padding: 16px 24px;
      }
    }
    
    @media (min-width: 1440px) {
      .burn-container {
        max-width: 700px;
        padding: 80px 60px 60px 60px;
        gap: 40px;
      }
      
      .burn-title {
        font-size: 3.5rem;
      }
      
      .burn-form input {
        font-size: 1.2rem;
        padding: 20px 28px;
      }
      
      .burn-btn {
        font-size: 1.3rem;
        padding: 24px 48px;
      }
    }
    .burn-container::after {
      content: '';
      display: block;
      position: absolute;
      left: 50%;
      bottom: -32px;
      transform: translateX(-50%) scaleY(-1);
      width: 90%;
      height: 40px;
      background: url('https://svgshare.com/i/14kA.svg') repeat-x bottom/100% 40px;
      opacity: 0.18;
      filter: blur(2.5px) brightness(1.2);
      pointer-events: none;
      z-index: 1;
      animation: fireBanner 2.5s linear infinite;
    }
    .logo, .modal-title, .wallet-chain-title, .burn-title {
      text-align: center;
    }
    .modal, .modal-content, .modal-title, .wallet-section, .wallet-chain-title, .wallet-btn-row, .wallet-btn, #walletModalClose,
    .burn-container, .burn-title, .burn-warning, .burn-form, .burn-form input, .burn-btn, .burn-success, .burn-balance {
      text-align: center !important;
    }
    form, .burn-form, .burn-form input, .burn-btn, .burn-success, .burn-balance {
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    .burn-title {
      font-size: 2.3em;
      color: #fffbe7;
      text-shadow: 0 0 48px #ff1a1a, 0 0 24px #ffae00, 0 0 4px #000;
      font-family: 'Nosifer', 'Orbitron', Arial, sans-serif;
      letter-spacing: 0.08em;
      margin-bottom: 10px;
      background: rgba(30,0,0,0.92);
      padding: 10px 18px;
      border-radius: 14px;
      box-shadow: 0 0 24px #ffae00, 0 0 12px #ff1a1a;
      animation: flicker 2.2s infinite alternate;
    }
    .burn-warning {
      color: #ffffff !important;
      font-weight: 900 !important;
      text-shadow: 3px 3px 6px #000000, -1px -1px 2px #000000, 1px -1px 2px #000000, -1px 1px 2px #000000, 0 0 16px #ff1a1a !important;
      margin-bottom: 0;
      text-align: center;
      font-size: 1.4em !important;
      border: 4px solid #ff1a1a !important;
      border-radius: 12px;
      background: #000000 !important;
      padding: 20px 16px !important;
      box-shadow: 0 0 30px #ff1a1a, 0 0 15px #ffae00, inset 0 0 20px rgba(255, 255, 255, 0.1) !important;
      animation: none !important;
      transition: none !important;
      opacity: 1 !important;
      filter: contrast(1.5) brightness(1.2) !important;
    }
    .burn-form {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 22px;
      margin-top: 10px;
      z-index: 2;
    }
    .burn-form input {
      width: 100%;
      padding: 18px;
      border-radius: 12px;
      border: 2.5px solid #ffae00;
      background: #1a0909ee;
      color: #fffbe7;
      box-shadow: 0 0 24px #ff4500cc, 0 0 12px #ffae00;
      font-size: 1.15em;
      font-weight: 700;
      text-shadow: 0 0 6px #ffae00, 0 0 2px #000;
      transition: box-shadow 0.2s, background 0.2s;
    }
    .burn-form input:focus {
      outline: none;
      background: #2d0000ee;
      color: #fffbe7;
      border-color: #fffbe7;
      box-shadow: 0 0 32px #ffae00, 0 0 16px #ff1a1a;
    }
    .burn-form input::placeholder {
      color: #ffae00;
      opacity: 1;
      text-shadow: 0 0 2px #000, 0 0 2px #ffae00;
    }
    .burn-btn {
      width: 100%;
      background: linear-gradient(90deg, #ff1a1a 60%, #ffae00 100%);
      box-shadow: 0 0 96px #ff1a1a, 0 0 48px #ffae00, 0 0 16px #fffbe7;
      font-size: 1.5em;
      border: 3px solid #ffae00;
      border-radius: 16px;
      text-transform: uppercase;
      font-family: 'Bangers', 'Ewert', 'Orbitron', cursive, sans-serif;
      letter-spacing: 2.5px;
      filter: brightness(1.1) saturate(1.2);
      padding: 22px 0;
      margin-top: 10px;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s, transform 0.1s;
      color: #fffbe7;
      font-weight: 900;
      text-shadow: 0 0 12px #ffae00, 0 0 4px #000;
      animation: burnBtnFlicker 2.2s infinite alternate, pulseBtn 2.2s infinite alternate;
      position: relative;
      z-index: 2;
      overflow: visible;
    }
    .burn-btn:active {
      background: linear-gradient(90deg, #ffae00 60%, #ff1a1a 100%);
      filter: brightness(1.3) saturate(1.3);
      color: #fffbe7;
      border: 3px solid #fffbe7;
      transform: scale(0.97);
    }
    .burn-btn::before {
      content: '';
      display: block;
      position: absolute;
      left: 50%;
      top: -38px;
      transform: translateX(-50%);
      width: 120px;
      height: 32px;
      background: url('https://svgshare.com/i/14kA.svg') repeat-x bottom/120px 32px;
      opacity: 0.7;
      pointer-events: none;
      animation: fireBanner 2.5s linear infinite;
      z-index: 2;
    }
    @keyframes burnBtnFlicker {
      0% { filter: brightness(1.1) saturate(1.2); }
      100% { filter: brightness(1.3) saturate(1.5); }
    }
    .burn-success {
      color: #fffbe7;
      font-size: 1.15em;
      margin-top: 18px;
      text-shadow: 0 0 16px #ffae00, 0 0 8px #ff1a1a, 0 0 2px #000;
      background: rgba(30,0,0,0.96);
      border-radius: 12px;
      padding: 16px 12px;
      box-shadow: 0 0 24px #ffae00, 0 0 12px #ff1a1a;
      text-align: center;
      animation: flicker 2.2s infinite alternate;
      border: 2.5px solid #ffae00;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin-left: auto;
      margin-right: auto;
      max-width: 90%;
    }
    .burn-balance {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: #fffbe7;
      font-size: 1.08em;
      background: linear-gradient(90deg, #ffae00 0%, #ff1a1a 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-fill-color: transparent;
      border: 2px solid #ffae00;
      box-shadow: 0 0 8px #ffae00, 0 0 4px #ff1a1a;
      position: relative;
      z-index: 2;
      font-weight: 900;
      text-shadow: 0 0 8px #ffae00, 0 0 2px #000;
    }
    .fire-emoji {
      font-size: 1.2em;
      animation: fireEmojiFlicker 1.2s infinite alternate;
      filter: drop-shadow(0 0 6px #ffae00) drop-shadow(0 0 2px #ff1a1a);
    }
    @keyframes fireEmojiFlicker {
      0% { filter: drop-shadow(0 0 6px #ffae00) drop-shadow(0 0 2px #ff1a1a); }
      100% { filter: drop-shadow(0 0 12px #ffae00) drop-shadow(0 0 6px #ff1a1a); }
    }
    /* --- ENHANCED EMBERS --- */
    .ember {
      opacity: 0.8;
      animation: emberFloat 4s linear infinite, emberDrift 8s ease-in-out infinite alternate;
    }
    @keyframes emberDrift {
      0% { transform: translateX(0); }
      100% { transform: translateX(40vw); }
    }
    /* --- GLASSY OVERLAY --- */
    .burn-container, .modal-content {
      background: linear-gradient(120deg, #1a0909ee 80%, #2d0000ee 100%), rgba(255,255,255,0.04);
      backdrop-filter: blur(2.5px) brightness(1.1);
      border-radius: 32px;
    }
    /* --- FIRE BORDER --- */
    .fire-border {
      position: relative;
      box-shadow: 0 0 64px 16px #ff1a1a99, 0 0 32px #ffae00cc, 0 0 0 8px #ffae0033;
      border: 4px solid transparent;
      background-clip: padding-box;
      overflow: visible;
    }
    .fire-border::before {
      content: '';
      position: absolute;
      inset: -8px;
      border-radius: 36px;
      z-index: 0;
      pointer-events: none;
      background: conic-gradient(from 0deg, #ffae00 0%, #ff1a1a 30%, #ffae00 60%, #ff1a1a 100%);
      filter: blur(8px) brightness(1.3) saturate(1.5);
      opacity: 0.7;
    }
    @keyframes fireGlow {
      0% { filter: blur(8px) brightness(1.2) saturate(1.2); opacity: 0.7; }
      50% { filter: blur(16px) brightness(1.5) saturate(2); opacity: 1; }
      100% { filter: blur(8px) brightness(1.2) saturate(1.2); opacity: 0.7; }
    }
    /* --- FIRE REFLECTION UNDER TITLE --- */
    .fire-reflection {
      position: relative;
    }
    .fire-reflection::after {
      content: '';
      display: block;
      position: absolute;
      left: 50%;
      top: 100%;
      transform: translateX(-50%) scaleY(-1);
      width: 80%;
      height: 18px;
      background: linear-gradient(180deg, #ffae00cc 0%, transparent 100%);
      opacity: 0.25;
      filter: blur(2.5px) brightness(1.2);
      pointer-events: none;
      z-index: 1;
      animation: fireBanner 2.5s linear infinite;
    }
    /* --- INPUT ICONS --- */
    .input-icon-group {
      position: relative;
      width: 100%;
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .input-icon-group input {
      transition: border-color 0.3s ease;
    }
    
    .input-icon-group input:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(255, 174, 0, 0.3);
    }
    
    #addressValidation {
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
    }
    .input-icon {
      position: absolute;
      left: 14px;
      z-index: 3;
      pointer-events: none;
      opacity: 0.85;
      filter: drop-shadow(0 0 4px #ffae00);
    }
    .input-icon + input {
      padding-left: 44px !important;
    }
    /* --- FIRE BUTTON --- */
    .fire-btn {
      position: relative;
      overflow: visible;
    }
    .fire-btn::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(1.1);
      width: 120%;
      height: 120%;
      border-radius: 50%;
      background: radial-gradient(circle, #ffae00 0%, #ff1a1a 60%, transparent 100%);
      opacity: 0.18;
      filter: blur(8px) brightness(1.5);
      z-index: 0;
      pointer-events: none;
      transition: opacity 0.2s, filter 0.2s;
      animation: fireBtnPulse 2.2s infinite alternate;
    }
    .fire-btn:hover::after, .fire-btn:focus::after {
      opacity: 0.32;
      filter: blur(16px) brightness(2.2);
    }
    @keyframes fireBtnPulse {
      0% { opacity: 0.18; filter: blur(8px) brightness(1.5); }
      100% { opacity: 0.32; filter: blur(16px) brightness(2.2); }
    }
    
    /* Mode Toggle Styles */
    .mode-toggle {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      background: rgba(26, 9, 9, 0.8);
      border-radius: 12px;
      padding: 4px;
      border: 2px solid #ffae00;
      box-shadow: 0 0 16px #ffae0066;
    }
    .mode-btn {
      flex: 1;
      padding: 12px 16px;
      background: transparent;
      border: none;
      color: #ffae00;
      font-family: 'Orbitron', Arial, sans-serif;
      font-weight: 700;
      font-size: 0.9em;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .mode-btn.active {
      background: linear-gradient(90deg, #ffae00 0%, #ff1a1a 100%);
      color: #fffbe7;
      box-shadow: 0 0 12px #ffae00, 0 0 6px #ff1a1a;
      text-shadow: 0 0 4px #000;
    }
    .mode-btn:hover:not(.active) {
      background: rgba(255, 174, 0, 0.1);
      color: #fff;
    }
    
    /* NFT Mode Styles */
    .nft-interface {
      display: none;
    }
    .nft-interface.active {
      display: block;
    }
    .nft-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 12px;
      margin: 16px 0;
      max-height: 300px;
      overflow-y: auto;
      padding: 8px;
      background: rgba(26, 9, 9, 0.6);
      border-radius: 8px;
      border: 1px solid #ffae0066;
    }
    .nft-item {
      aspect-ratio: 1;
      background: rgba(45, 0, 0, 0.8);
      border: 2px solid #ffae0066;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    .nft-item:hover {
      border-color: #ffae00;
      box-shadow: 0 0 8px #ffae0066;
      transform: scale(1.02);
    }
    .nft-item.selected {
      border-color: #ff1a1a;
      box-shadow: 0 0 16px #ff1a1a66;
      background: rgba(255, 26, 26, 0.2);
    }
    .nft-image {
      width: 100%;
      height: 70%;
      object-fit: cover;
      border-radius: 4px;
    }
    .nft-id {
      font-size: 0.7em;
      color: #ffae00;
      margin-top: 4px;
      text-align: center;
      word-break: break-all;
    }
    .nft-loading {
      color: #ffae00;
      text-align: center;
      padding: 20px;
      font-style: italic;
    }
    
    /* Modal styles - more 3D, infernal */
    .modal {
      display: none;
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.92);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      padding: 16px;
      backdrop-filter: blur(2.5px) brightness(0.9);
      box-sizing: border-box;
    }
    .modal.active {
      display: flex;
    }
    .modal-content {
      background: linear-gradient(120deg, #1a0909 80%, #2d0000 100%);
      border-radius: 18px;
      padding: 32px 24px 24px 24px;
      width: 100%;
      max-width: 520px;
      margin: 0 auto;
      box-shadow: 0 0 64px #ff1a1a, 0 0 32px #ffae00, 0 0 8px #fffbe7;
      border: 3px solid #ffae00;
      position: relative;
      z-index: 2;
      animation: modalFlicker 2.2s infinite alternate;
      box-sizing: border-box;
    }
    
    /* Desktop Modal Improvements */
    @media (min-width: 1024px) {
      .modal-content {
        max-width: 600px;
        padding: 48px 36px 36px 36px;
        border-radius: 24px;
      }
      
      .modal-title {
        font-size: 2.2em;
        margin-bottom: 32px;
      }
      
      .wallet-btn {
        padding: 18px 36px;
        font-size: 1.1em;
        margin: 12px 0;
      }
      
      #walletModalClose {
        width: 48px;
        height: 48px;
        font-size: 1.8em;
        top: 20px;
        right: 20px;
      }
    }
    @keyframes modalFlicker {
      0% { box-shadow: 0 0 32px #ff1a1a, 0 0 16px #ffae00; }
      100% { box-shadow: 0 0 64px #ffae00, 0 0 32px #ff1a1a; }
    }
    .modal-title {
      font-family: 'Nosifer', 'Orbitron', Arial, sans-serif;
      font-size: 1.7em;
      color: #ffae00;
      text-shadow: 0 0 16px #ff1a1a, 0 0 12px #ffae00;
      margin-bottom: 22px;
      text-align: center;
      letter-spacing: 0.06em;
      animation: flicker 2.2s infinite alternate;
    }
    .wallet-section {
      margin-bottom: 22px;
      width: 100%;
      text-align: center;
    }
    .wallet-chain-title {
      font-family: 'Orbitron', Arial, sans-serif;
      color: #fffbe7;
      font-size: 1.15em;
      margin-bottom: 10px;
      text-align: center;
      letter-spacing: 0.04em;
      text-shadow: 0 0 10px #ffae00, 0 0 2px #000;
      border: none;
    }
    .wallet-btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
      margin-bottom: 10px;
      text-align: center;
    }
    .wallet-btn {
      font-family: 'Orbitron', Arial, sans-serif;
      font-size: 1.05em;
      font-weight: 700;
      padding: 12px 26px;
      border-radius: 10px;
      border: 2.5px solid #ffae00;
      background: #1a0909;
      color: #ffae00;
      box-shadow: 0 0 12px #ff4500cc, 0 0 6px #ffae00;
      cursor: pointer;
      transition: background 0.2s, color 0.2s, box-shadow 0.2s;
      margin: 0 4px 4px 0;
      text-shadow: 0 0 6px #ffae00, 0 0 2px #000;
      animation: burnBtnFlicker 2.2s infinite alternate;
      text-align: center;
      text-transform: uppercase;
      font-family: 'Bangers', 'Ewert', 'Orbitron', cursive, sans-serif;
      letter-spacing: 2.5px;
    }
    .wallet-btn:hover, .wallet-btn:focus {
      background: linear-gradient(90deg, #ff1a1a 60%, #ffae00 100%);
      color: #fffbe7;
      box-shadow: 0 0 24px #ff1a1a, 0 0 12px #ffae00;
      outline: none;
      border: 2.5px solid #fffbe7;
    }
    #walletModalClose {
      margin-top: 14px;
      width: 100%;
      background: #1a0909;
      color: #ffae00;
      border: none;
      border-radius: 10px;
      font-size: 1.05em;
      font-weight: 700;
      padding: 12px 0;
      cursor: pointer;
      box-shadow: 0 0 12px #ff4500cc, 0 0 6px #ffae00;
      text-shadow: 0 0 6px #ffae00, 0 0 2px #000;
      transition: background 0.2s, color 0.2s, box-shadow 0.2s;
      animation: burnBtnFlicker 2.2s infinite alternate;
      text-align: center;
      text-transform: uppercase;
      font-family: 'Bangers', 'Ewert', 'Orbitron', cursive, sans-serif;
      letter-spacing: 2.5px;
    }
    #walletModalClose:hover {
      background: linear-gradient(90deg, #ff1a1a 60%, #ffae00 100%);
      color: #fffbe7;
      box-shadow: 0 0 24px #ff1a1a, 0 0 12px #ffae00;
      border: none;
    }
    .top-right-link {
      position: absolute;
      top: 24px;
      right: 32px;
      z-index: 100;
      background: linear-gradient(90deg, #ffae00 60%, #ff1a1a 100%);
      color: #fffbe7;
      font-family: 'Orbitron', 'Arial', sans-serif;
      font-size: 1.1em;
      font-weight: 900;
      border: none;
      border-radius: 8px;
      padding: 10px 24px;
      box-shadow: 0 0 16px #ffae00, 0 0 8px #ff1a1a;
      text-shadow: 0 0 8px #ffae00, 0 0 2px #000;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      text-decoration: none;
      letter-spacing: 0.04em;
      display: inline-block;
      text-align: center;
      text-transform: uppercase;
      font-family: 'Bangers', 'Ewert', 'Orbitron', cursive, sans-serif;
    }
    .top-right-link:hover {
      background: linear-gradient(90deg, #ff1a1a 60%, #ffae00 100%);
      color: #fffbe7;
      box-shadow: 0 0 32px #ff1a1a, 0 0 16px #ffae00;
    }
    .wildwest-title {
      font-family: 'Ewert', 'UnifrakturMaguntia', 'Creepster', cursive;
      font-size: 6.2em;
      color: #ffae00;
      text-shadow: 0 0 32px #ffae00, 0 0 16px #ff1a1a, 0 0 4px #000;
      letter-spacing: 0.14em;
      margin-bottom: 0.1em;
      margin-top: 0.1em;
      text-align: center;
      display: block;
      filter: drop-shadow(0 0 16px #ffae00);
      animation: flicker 2.2s infinite alternate;
    }
    @media (max-width: 800px) {
      .wildwest-title {
        font-size: 5.2em; /* Increased from 4.2em for better mobile visibility */
        margin-top: 0.8em; /* Further reduced from 1.5em for better spacing */
        margin-bottom: 0.2em;
      }
      .top-right-link {
        top: 0.7em;
        right: 2vw;
        font-size: 0.7em;
        padding: 2px 6px;
        border-radius: 4px;
        z-index: 200;
        min-width: 0;
        min-height: 0;
      }
      .burn-container {
        margin: 0 auto 32px auto;
        padding: 24px 16px 24px 16px;
        max-width: 90%;
        width: 90%;
        gap: 16px;
      }
      .header {
        padding: 24px 16px 12px 16px;
        margin-bottom: 16px;
      }
      .connect-btn {
        padding: 12px 24px;
        font-size: 0.9em;
        margin: 8px 0;
      }
    }
    @media (max-width: 420px) {
      .wildwest-title {
        font-size: 4.0em; /* Increased from 3.2em for better mobile visibility */
        margin-top: 1.0em; /* Further reduced from 1.8em for better spacing */
        margin-bottom: 0.25em;
      }
      .top-right-link {
        top: 1.2em; /* Increased from 0.5em to add more space */
        right: 2vw;
        font-size: 0.6em;
        padding: 1.5px 4px;
        border-radius: 3px;
        z-index: 1000; /* Ensure it stays above other elements */
      }
      .modal {
        padding: 8px;
      }
      .modal-content {
        padding: 12px 8px;
        width: 85vw;
        max-width: 85vw;
        max-height: 75vh;
      }
      .burn-container {
        margin: 0 auto 24px auto;
        padding: 16px 12px 16px 12px;
        max-width: 95%;
        width: 95%;
        gap: 12px;
      }
      .header {
        padding: 16px 12px 8px 12px;
        margin-bottom: 12px;
      }
      .connect-btn {
        padding: 10px 20px;
        font-size: 0.8em;
        margin: 6px 0;
      }
      /* Further reduce animations on very small screens */
      body::before, body::after {
        animation-duration: 15s;
        filter: blur(0.3px) brightness(1.01);
      }
      .ember {
        animation-duration: 10s;
        box-shadow: 0 0 6px #ffae00, 0 0 3px #ff1a1a;
      }
    }
    /* Ember particles - optimized for mobile */
    .ember {
      position: fixed;
      pointer-events: none;
      z-index: 9999;
      border-radius: 50%;
      opacity: 0.6;
      background: radial-gradient(circle, #ffae00 0%, #ff1a1a 60%, transparent 100%);
      animation: emberFloat 6s linear infinite;
      box-shadow: 0 0 12px #ffae00, 0 0 6px #ff1a1a;
      filter: blur(0.5px) brightness(1.1);
      will-change: transform, opacity;
    }
    @keyframes emberFloat {
      0% { transform: translateY(0) scale(1); opacity: 0.6; }
      80% { opacity: 0.8; }
      100% { transform: translateY(-100vh) scale(0.8); opacity: 0; }
    }
    /* Responsive tweaks */
    @media (max-width: 800px) {
      html, body {
        overflow-x: hidden;
        width: 100%;
        position: relative;
      }
      /* DISABLE EMBERS ON MOBILE FOR PERFORMANCE */
      body::before,
      body::after {
        display: none !important;
      }
      .ember {
        display: none !important;
      }
      .header::after {
        animation: fireBanner 4s linear infinite;
      }
      .burn-container::after {
        animation: fireBanner 4s linear infinite;
      }
    }
      .header {
        padding: 12px 0 0 0;
        margin-bottom: 0;
        min-width: 0;
      }
      .logo {
        font-size: 1.3em;
        padding: 0 4px;
        margin-bottom: 0.2em;
      }
      .wildwest-title {
        font-size: 3.0em; /* Increased from 2.2em for better visibility on very small screens */
        margin-bottom: 0.1em;
        margin-top: 1.2em; /* Further reduced from 2.0em for better spacing */
      }
      .connect-btn {
        margin: 10px auto 0 auto;
        font-size: 0.95em;
        padding: 8px 8px;
        min-width: 0;
        border-radius: 8px;
      }
      .top-right-link {
        top: 1.5em; /* Increased from 0.7em to add more space on very small screens */
        right: 2vw;
        font-size: 0.7em;
        padding: 2px 6px;
        border-radius: 4px;
        z-index: 200;
        min-width: 0;
        min-height: 0;
      }
      
      /* Additional mobile performance optimizations */
      @media (max-width: 480px) {
        /* Disable heavy animations on very small screens */
        body::before {
          animation: none;
          background: linear-gradient(180deg, #ff1a1a22 0%, transparent 100%);
          filter: none;
        }
        
        body::after {
          animation: none;
          background: radial-gradient(circle at 50% 50%, #ff1a1a11 0%, transparent 60%);
          filter: none;
        }
        
        .big-fire-title {
          animation: flicker 4s infinite alternate;
        }
        
        .fire-banner::before {
          animation: fireBanner 5s linear infinite;
        }
        
        .connect-btn {
          animation: none;
        }
        
        .burn-btn {
          animation: none;
        }
        
        .ember {
          animation: none;
        }
      }
      
      .fire-animation {
        width: 60px;
        height: 24px;
        margin-bottom: 8px;
      }
      .burn-container {
        padding: 10px 2vw 10px 2vw;
        max-width: 99vw;
        min-width: 0;
        border-radius: 18px;
        box-shadow: 0 0 32px 8px #ff1a1a99, 0 0 16px #ffae00cc;
        margin: 0 auto 24px auto;
        gap: 14px;
      }
      .modal-content {
        padding: 16px 12px;
        max-width: 90vw;
        margin: 0 auto;
        border-radius: 14px;
        box-sizing: border-box;
        width: 90vw;
        max-height: 80vh;
        overflow-y: auto;
        position: relative;
      }
      .modal {
        padding: 16px;
        box-sizing: border-box;
        align-items: center;
        justify-content: center;
      }
      
      .burn-title {
        font-size: 1.2em;
        padding: 6px 4px;
        border-radius: 8px;
      }
      .burn-warning {
        font-size: 0.95em;
        padding: 7px 4px;
        border-radius: 8px;
        animation: none !important;
        transition: none !important;
        opacity: 1 !important;
      }
      .burn-form {
        gap: 10px;
      }
      .burn-form input {
        padding: 10px;
        font-size: 0.95em;
        border-radius: 8px;
      }
      .burn-btn {
        font-size: 1em;
        padding: 12px 0;
        border-radius: 10px;
        margin-top: 6px;
      }
      .burn-success {
        font-size: 0.95em;
        padding: 8px 4px;
        border-radius: 8px;
      }
      .burn-balance {
        font-size: 0.95em;
        border-radius: 8px;
        padding: 4px 2px;
      }
      .wallet-chain-btn {
        font-size: 1em !important;
        padding: 10px 0 !important;
        border-radius: 8px !important;
      }
      #walletModalClose {
        font-size: 1em;
        padding: 10px 0;
        border-radius: 8px;
      }
    
    .burn-balance, .wallet-btn[data-mint], .base-token-list-item, #tokenAddress {
      word-break: break-all;
      overflow-wrap: anywhere;
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: inline-block;
      vertical-align: middle;
      position: relative;
      cursor: pointer;
    }
    .burn-balance:hover, .wallet-btn[data-mint]:hover, .base-token-list-item:hover, #tokenAddress:hover {
      white-space: normal;
      background: #1a0909ee;
      z-index: 10;
      box-shadow: 0 0 16px #ffae00, 0 0 8px #ff1a1a;
    }
    .base-token-list-item {
      margin: 6px 0;
      padding: 8px 10px;
      border-radius: 10px;
      border: 2px solid #ffae00;
      background: #1a0909ee;
      color: #fffbe7;
      font-size: 1em;
      box-shadow: 0 0 8px #ffae00, 0 0 4px #ff1a1a;
      transition: background 0.2s, box-shadow 0.2s;
      cursor: pointer;
      text-align: left;
      width: 100%;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .base-token-list-item .base-token-address {
      font-size: 0.95em;
      color: #ffae00;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: inline-block;
      vertical-align: middle;
    }
    .base-token-list-item .base-token-address:hover {
      white-space: normal;
      background: #1a0909ee;
      z-index: 10;
      box-shadow: 0 0 16px #ffae00, 0 0 8px #ff1a1a;
    }
    
    /* NUCLEAR OPTION: Force burn-warning to be completely static */
    .burn-warning, .burn-warning *, div.burn-warning {
      animation: none !important;
      transition: none !important;
      opacity: 1 !important;
      transform: none !important;
      filter: contrast(1.5) brightness(1.2) !important;
    }
    
    /* MAXIMUM VISIBILITY for burn-warning */
    .burn-warning {
      background: #000000 !important;
      color: #ffffff !important;
      font-weight: 900 !important;
      border: 4px solid #ff0000 !important;
      text-shadow: 3px 3px 6px #000000, -2px -2px 4px #000000, 2px -2px 4px #000000, -2px 2px 4px #000000 !important;
      box-shadow: 0 0 40px #ff0000, 0 0 20px #ffae00 !important;
    }
  </style>
</head>
<body class="page-furnace">  <!-- Determines hero picture -->
    <a href="../index.html" class="top-right-link" style="text-transform:uppercase;font-family:'Bangers','Ewert','Orbitron',cursive,sans-serif;letter-spacing:2.5px;">BACK TO MAIN</a>
    <!-- Top chrome: fixed wrapper that always stays above the page -->
    <div class="site-chrome">
        <!-- Transaction Ticker Widget -->
        <iframe id="transaction-ticker-iframe" src="../transaction-ticker-widget.html" scrolling="no"
            title="Transaction Ticker">
        </iframe>

        <!-- ========== Nav Bar =============
        ====================================
        =================================-->

        <nav class="navbar">

            <!-- Left: Logo -->
            <div class="navlogo">WILD WEST</div>

            <!-- Center: Main Links -->
            <ul class="nav-links">
                <li><a href="../index.html">Home</a></li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Launch Token â–¾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <!-- NOTE: from /pages/ use same-folder path, not ./pages/... -->
                        <li><a href="launch-base.html" role="menuitem" aria-current="page">Base</a></li>
                        <li><a href="coming-soon.html" role="menuitem">Solana (Coming soon!)</a></li>
                    </ul>
                </li>

                <li><a href="coming-soon.html">NFT Marketplace</a></li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Staking â–¾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <li><a href="coming-soon.html" role="menuitem">Base</a></li>
                        <li><a href="coming-soon.html" role="menuitem">Solana (Coming soon!)</a></li>
                    </ul>
                </li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Token Locking â–¾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <li><a href="locking-base.html" role="menuitem">Base</a></li>
                        <li><a href="locking-solana.html" role="menuitem">Solana</a></li>
                    </ul>
                </li>

                <li><a href="furnace.html">Token Furnace</a></li>
                <li><a href="the-team.html">The Team</a></li>
                <li><a href="coming-soon.html">Arcade</a></li> <!-- (double-check: both go to team.html) -->
            </ul>

            <!-- Right: Icons -->
            <div class="nav-actions">
                <a href="https://t.me/wildwestlaunchpad" target="_blank" rel="noopener">
                    <img src="../images/icons/icons8-telegram-app-240_WHITE.png" alt="Telegram" class="nav-icon">
                </a>
                <a href="https://x.com/WILDWESTLP?t=wmcDfvCKnkAaLCtJbmAxgA" target="_blank" rel="noopener">
                    <img src="../images/icons/icons8-twitterx-240_WHITE.png" alt="Twitter/X" class="nav-icon">
                </a>
                <a href="https://dexscreener.com/base/0x8129609e5303910464fce3022a809fa44455fe9a" target="_blank"
                    rel="noopener">
                    <img src="../images/icons/661375b92a7e161501f4b5e5_dexscreener.322a5a2d_WHITE.png" alt="DEXScreener"
                        class="nav-icon">
                </a>
                <div class="connect-wallet-btn">
                    <a>Connect Wallet</a>
                </div>
            </div>
        </nav>

        <!-- Token Furnace Style Wallet Modal System -->
        <script>
            // Utility function for mobile detection
            function isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
            }

            // Get mobile-aware wallet message
            function getMobileAwareWalletMessage() {
                if (isMobileDevice()) {
                    return 'Please open this website in your EVM wallet browser (MetaMask, Trust Wallet, Coinbase Wallet, etc.)';
                } else {
                    return 'Please install MetaMask or another compatible EVM wallet to use this application';
                }
            }

            // Token Furnace Style Wallet Modal Implementation for Base Launch
            document.addEventListener('DOMContentLoaded', function () {
                console.log('ðŸš€ Base Launch: Setting up token furnace style wallet');
                setupBaseLaunchWallet();
            });

            function showChainSelectionModal() {
                console.log('ðŸš€ Base Launch: showChainSelectionModal called!');

                // Focus on Ethereum/Base wallets only for base launch page
                const availableWallets = {
                    ethereum: []
                };

                // Detect Ethereum/Base wallets
                if (window.ethereum) {
                    const providers = window.ethereum.providers || [window.ethereum];

                    providers.forEach(provider => {
                        if (provider.isMetaMask) {
                            availableWallets.ethereum.push({ name: 'MetaMask', provider: provider });
                        }
                        if (provider.isCoinbaseWallet) {
                            availableWallets.ethereum.push({ name: 'Coinbase Wallet', provider: provider });
                        }
                        if (provider.isRabby) {
                            availableWallets.ethereum.push({ name: 'Rabby Wallet', provider: provider });
                        }
                        if (provider.isTrust) {
                            availableWallets.ethereum.push({ name: 'Trust Wallet', provider: provider });
                        }
                    });

                    if (availableWallets.ethereum.length === 0) {
                        availableWallets.ethereum.push({ name: 'Ethereum Wallet', provider: window.ethereum });
                    }
                }

                console.log('ðŸ” Base Launch: Detected wallets:', availableWallets);

                const modal = document.createElement('div');
                modal.id = 'walletConnectionModal'; // Add ID for easier reference
                modal.className = 'wallet-modal';
                modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center;
                z-index: 10000; animation: fadeIn 0.2s ease-out;
            `;

                let walletOptionsHTML = '';

                if (availableWallets.ethereum.length > 0) {
                    walletOptionsHTML += '<h4 style="color: #00eaff; margin: 1rem 0 0.5rem 0; font-size: 1rem; text-align: center;">Base Network (Ethereum)</h4>';
                    availableWallets.ethereum.forEach((wallet, index) => {
                        walletOptionsHTML += `
                        <button onclick="connectSpecificWallet('ethereum', ${index})" style="
                            display: block; width: 100%; margin: 8px 0; padding: 12px 16px;
                            background: linear-gradient(135deg, #0052ff, #0041cc);
                            color: white; border: 1px solid rgba(0, 234, 255, 0.3); border-radius: 8px;
                            cursor: pointer;
                            transition: all 0.3s ease; text-align: center;
                        " onmouseover="this.style.background='linear-gradient(135deg, #0066ff, #0052ff)'; this.style.borderColor='#00eaff'; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='linear-gradient(135deg, #0052ff, #0041cc)'; this.style.borderColor='rgba(0, 234, 255, 0.3)'; this.style.transform='translateY(0)'">
                            Connect ${wallet.name}
                        </button>
                    `;
                    });
                } else {
                    // Mobile-aware messaging when no wallets detected
                    if (isMobileDevice()) {
                        walletOptionsHTML = `
                        <div style="text-align: center; padding: 1rem; color: #ff6b6b;">
                            <h4 style="color: #ff6b6b; margin-bottom: 1rem; text-align: center;">Open in Wallet Browser</h4>
                            <p style="margin-bottom: 1.5rem; color: #c0c0c0; text-align: center; line-height: 1.5;">To use this application on mobile, please open this website in your EVM wallet's built-in browser:</p>
                            <div style="text-align: center; margin-bottom: 1.5rem;">
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">ðŸ“± MetaMask Mobile</span> â†’ Browser Tab â†’ Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">ðŸ“± Trust Wallet</span> â†’ Browser Tab â†’ Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">ðŸ“± Coinbase Wallet</span> â†’ Browser Tab â†’ Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">ðŸ“± Other EVM Wallets</span> â†’ In-App Browser</p>
                            </div>
                            <div style="background: rgba(0, 234, 255, 0.1); border: 1px solid rgba(0, 234, 255, 0.3); border-radius: 8px; padding: 1rem; margin-top: 1rem;">
                                <p style="margin: 0; color: #00eaff; font-size: 0.85rem; font-weight: 500;">ðŸ’¡ Tip: Copy this URL and paste it in your mobile wallet's browser</p>
                            </div>
                        </div>
                    `;
                    } else {
                        walletOptionsHTML = `
                        <div style="text-align: center; padding: 1rem; color: #ff6b6b;">
                            <h4 style="color: #ff6b6b; margin-bottom: 1rem; text-align: center;">No Base Wallets Detected</h4>
                            <p style="margin-bottom: 1rem; color: #c0c0c0; text-align: center;">Please install a Base-compatible wallet:</p>
                            <section class="link-panel link-panel--center-vertically">
                              <a class="panel-item" href="https://metamask.io/" target="_blank" rel="noopener">
                                <img src="../images/metamask-strip-white.webp" alt="Project One" loading="lazy">
                              </a>

                              <a class="panel-item" href="https://www.coinbase.com/wallet" target="_blank" rel="noopener">
                                <img src="../images/coinbase-strip-white.webp" alt="Project Two" loading="lazy">
                              </a>

                              <a class="panel-item" href="https://trustwallet.com/" target="_blank" rel="noopener">
                                <img src="../images/trustwallet-strip-white.webp" alt="Project Three" loading="lazy">
                              </a>
                            </section>
                        </div>
                    `;
                    }
                }

                modal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #1a1a2e, #16213e);
                    border: 2px solid #00eaff;
                    border-radius: 16px;
                    box-shadow: 0 0 30px rgba(0, 234, 255, 0.3);
                    max-width: 400px;
                    width: 90vw;
                    max-height: 80vh;
                    overflow-y: auto;
                ">
                    <div style="
                        padding: 1.5rem;
                        border-bottom: 1px solid rgba(0, 234, 255, 0.2);
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <h3 style="margin: 0; color: #00eaff; font-size: 1.25rem; text-align: center;">Connect Base Wallet</h3>
                        <button class="close-modal-btn" style="
                            background: none; border: none; color: #00eaff; font-size: 1.5rem;
                            cursor: pointer; padding: 0; width: 30px; height: 30px;
                            display: flex; align-items: center; justify-content: center;
                            border-radius: 50%; transition: background-color 0.2s;
                        ">Ã—</button>
                    </div>
                    <div style="padding: 1.5rem;">
                        ${walletOptionsHTML}
                        <button class="cancel-modal-btn" style="
                            display: block; width: 100%; margin-top: 1rem; padding: 10px;
                            background: rgba(102, 102, 102, 0.8); color: white;
                            border: 1px solid rgba(0, 234, 255, 0.2); border-radius: 8px;
                            cursor: pointer;
                            font-family: var(--font-ui);
                        ">Cancel</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);

                const closeBtn = modal.querySelector('.close-modal-btn');
                const cancelBtn = modal.querySelector('.cancel-modal-btn');

                function closeModal() {
                    modal.remove();
                }

                closeBtn.addEventListener('click', closeModal);
                cancelBtn.addEventListener('click', closeModal);
                modal.addEventListener('click', function (e) {
                    if (e.target === modal) closeModal();
                });

                // Store modal reference globally for easy closing
                window.currentWalletModal = modal;
                window.availableWallets = availableWallets;
            }

            window.connectSpecificWallet = async function (network, walletIndex) {
                console.log(`ðŸ”— Base Launch: Connecting to wallet ${walletIndex} on ${network} network`);

                try {
                    if (network === 'ethereum') {
                        const wallet = window.availableWallets.ethereum[walletIndex];
                        if (!wallet) {
                            throw new Error(`Wallet not found at index ${walletIndex}`);
                        }

                        console.log(`ðŸ“‹ Base Launch: Connecting to ${wallet.name}`);

                        const accounts = await wallet.provider.request({ method: 'eth_requestAccounts' });
                        if (accounts.length > 0) {
                            try {
                                await wallet.provider.request({
                                    method: 'wallet_switchEthereumChain',
                                    params: [{ chainId: '0x2105' }], // Base mainnet
                                });
                            } catch (switchError) {
                                if (switchError.code === 4902) {
                                    await wallet.provider.request({
                                        method: 'wallet_addEthereumChain',
                                        params: [{
                                            chainId: '0x2105',
                                            chainName: 'Base',
                                            nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                                            rpcUrls: [BASE_RPC_URL],
                                            blockExplorerUrls: ['https://basescan.org']
                                        }]
                                    });
                                }
                            }

                            // Update global state for launch page
                            window.currentAddress = accounts[0];
                            window.currentChain = 'base';
                            window.currentProvider = wallet.provider;

                            // CRITICAL: Set the main script variables immediately
                            provider = new ethers.providers.Web3Provider(wallet.provider);
                            signer = provider.getSigner();
                            userAddress = accounts[0];

                            // Initialize CONTRACT
                            CONTRACT = new ethers.Contract(TOKEN_FACTORY_ADDRESS, TOKEN_FACTORY_ABI, signer);

                            console.log('ðŸ”§ Base Launch: FIXED - Set provider:', !!provider);
                            console.log('ðŸ”§ Base Launch: FIXED - Set userAddress:', userAddress);

                            // Close modal IMMEDIATELY after successful connection
                            if (window.currentWalletModal) {
                                console.log('ðŸ”„ Base Launch: Closing wallet modal immediately');
                                window.currentWalletModal.remove();
                                window.currentWalletModal = null;
                            }

                            // Fallback: close modal by ID if reference didn't work
                            const modalById = document.getElementById('walletConnectionModal');
                            if (modalById) {
                                console.log('ðŸ”„ Base Launch: Closing modal by ID (fallback)');
                                modalById.remove();
                            }

                            // Fallback: close any remaining wallet modal by class
                            const modalByClass = document.querySelector('.wallet-modal');
                            if (modalByClass) {
                                console.log('ðŸ”„ Base Launch: Closing modal by class (fallback)');
                                modalByClass.remove();
                            }

                            // Update UI
                            updateBaseLaunchUI(accounts[0]);

                            console.log(`âœ… Base Launch: ${wallet.name} connected successfully!`);

                            // Load dashboards directly instead of page reload
                            setTimeout(async () => {
                                console.log('ðŸ”„ Base Launch: Loading user tokens...');
                                try {
                                    await connectWallet();
                                    await refreshDashboards();
                                } catch (e) {
                                    console.error('Dashboard loading failed:', e);
                                }
                            }, 500);

                            console.log(`âœ… Base Launch: ${wallet.name} connected successfully!`);
                        }
                    }
                } catch (error) {
                    const walletName = window.availableWallets.ethereum[walletIndex]?.name;
                    console.error(`âŒ Base Launch: ${walletName} connection failed:`, error);
                    alert(`Connection failed: ${error.message}`);
                }
            };

            function updateBaseLaunchUI(address) {
                const connectBtn = document.getElementById('connectBtn');

                if (connectBtn) {
                    const shortAddr = `${address.slice(0, 6)}...${address.slice(-4)}`;
                    connectBtn.textContent = `Connected: ${shortAddr}`;
                    connectBtn.style.background = 'linear-gradient(135deg, #0070f3, #00c851, #0051cc)';
                    connectBtn.style.backgroundSize = '200% 200%';
                    connectBtn.style.animation = 'gradientShift 6s ease infinite';
                    connectBtn.disabled = false; // Keep button clickable for disconnect option
                    connectBtn.style.cursor = 'pointer'; // Show it's still clickable
                }

                // Hide the connection prompt when wallet is connected
                const connectionStatus = document.getElementById('connectionStatus');
                if (connectionStatus) {
                    connectionStatus.style.display = 'none';
                }

                // Show main content after wallet connection
                const mainContent = document.getElementById('mainContent');
                const priceStatus = document.getElementById('priceStatus');
                const tokenManagement = document.getElementById('tokenManagementSection');
                if (mainContent) mainContent.style.display = 'block';
                if (priceStatus) priceStatus.style.display = 'block';
                if (tokenManagement) tokenManagement.style.display = 'block';

                // Enable functionality
                document.querySelectorAll('.form-input, .btn').forEach(el => {
                    if (el.id !== 'connectBtn') {
                        el.disabled = false;
                    }
                });

                // Update displays
                if (typeof updateDisplays === 'function') {
                    updateDisplays();
                }

                console.log('âœ… Base Launch: UI updated and functionality enabled');
            }

            function setupBaseLaunchWallet() {
                console.log('ðŸ”§ Base Launch: Setting up wallet connection');

                const connectBtn = document.getElementById('connectBtn');
                if (!connectBtn) {
                    console.error('âŒ Base Launch: Connect wallet button not found');
                    return;
                }

                connectBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('ðŸ”— Base Launch: Connect button clicked');
                    handleConnectButtonClick();
                });

                // Ensure button is properly centered on page load
                adjustButtonGroupLayout();

                console.log('âœ… Base Launch: Wallet setup complete');
            }

            // Smart connect button handler - connects or disconnects based on current state
            function handleConnectButtonClick() {
                // Check if wallet is already connected
                if (userAddress && provider) {
                    // Wallet is connected, ask if user wants to disconnect
                    const shortAddr = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                    const confirmDisconnect = confirm(`Disconnect wallet ${shortAddr}?\n\nThis will hide all token management features and return you to the connection screen.`);

                    if (confirmDisconnect) {
                        console.log('ðŸ”Œ User requested wallet disconnection');
                        handleWalletDisconnect();
                    }
                } else {
                    // Wallet is not connected, show connection modal
                    console.log('ðŸ”— User wants to connect wallet');
                    showChainSelectionModal();
                }
            }

            // Global variables
            window.currentAddress = null;
            window.currentChain = null;
            window.currentProvider = null;

            // NEW ANTI-SNIPER & ENHANCED FUNCTIONS

            // Helper function to load user tokens using createdTokens mapping
            async function getUserTokens(userAddress) {
                const tokens = [];
                let tokenIndex = 0;
                let maxAttempts = 100; // Prevent infinite loops

                try {
                    while (tokenIndex < maxAttempts) {
                        try {
                            const tokenInfo = await CONTRACT.createdTokens(userAddress, tokenIndex);
                            // Check if we got a valid token (tokenAddress != 0x0)
                            if (tokenInfo[0] && tokenInfo[0] !== '0x0000000000000000000000000000000000000000') {
                                tokens.push(tokenInfo);
                                tokenIndex++;
                            } else {
                                break; // No more tokens
                            }
                        } catch (e) {
                            break; // No more tokens or error occurred
                        }
                    }
                } catch (err) {
                    console.log('Error loading user tokens:', err.message);
                }

                return tokens;
            }

            // Batch swap accumulated token fees
            async function batchSwapTokens() {
                console.log('ðŸš€ batchSwapTokens() function called!');
                console.log('CONTRACT:', CONTRACT);
                console.log('User Address:', userAddress);

                if (!CONTRACT || !userAddress) {
                    console.log('âŒ Missing CONTRACT or userAddress');
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    console.log('ðŸ”„ Starting token fee swap...');

                    // First get user's tokens to check if they have any
                    const userTokens = await getUserTokens(userAddress);
                    console.log('ðŸ“‹ User tokens found:', userTokens.length);

                    if (userTokens.length === 0) {
                        showStatus('No tokens found. Please create a token first.', 'error');
                        return;
                    }

                    // Check different types of balances that might be stuck
                    console.log('ðŸ” Checking for different types of stuck tokens...');

                    // Check creator token balance (fees earned as tokens)
                    const tokenBalance = await CONTRACT.getCreatorTokenBalance(userAddress);
                    console.log('ðŸ’° Creator token balance:', ethers.utils.formatEther(tokenBalance), 'tokens');

                    // Check if there are any LP token fees accumulated
                    let hasStuckTokens = false;
                    const tokenAddress = userTokens[0][0]; // First token address
                    console.log('ðŸŽ¯ Checking token:', tokenAddress);

                    // Try to check if CONTRACT has any of the user's tokens
                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function decimals() view returns (uint8)",
                        "function symbol() view returns (string)"
                    ];

                    const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                    const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                    const tokenSymbol = await tokenCONTRACT.symbol();

                    console.log('ðŸ¦ CONTRACT balance of', tokenSymbol + ':', ethers.utils.formatEther(CONTRACTTokenBalance));

                    if (tokenBalance.gt(0)) {
                        console.log('âœ… Found creator token fees to swap');
                        hasStuckTokens = true;
                    } else if (CONTRACTTokenBalance.gt(0)) {
                        console.log('âœ… Found CONTRACT token balance that might need swapping');
                        hasStuckTokens = true;
                    } else {
                        showStatus('No stuck tokens found to swap. Token balance: ' + ethers.utils.formatEther(tokenBalance) + ', CONTRACT balance: ' + ethers.utils.formatEther(CONTRACTTokenBalance), 'info');
                        return;
                    }

                    // Proceed with swap
                    console.log('ðŸ”„ Attempting to swap tokens for:', tokenAddress);
                    console.log('ðŸ“Š Creator token balance to swap:', ethers.utils.formatEther(tokenBalance));
                    console.log('ðŸ¦ CONTRACT token balance found:', ethers.utils.formatEther(CONTRACTTokenBalance));

                    // The tokens are stuck in the CONTRACT but not assigned to creator yet
                    // Try rescueAndSellStuckTokens function instead
                    console.log('ðŸ’¡ Using rescueAndSellStuckTokens to rescue stuck tokens...');
                    showStatus('Collecting rewards from your tokens...', 'info');

                    try {
                        console.log('ï¿½ Calling rescueAndSellStuckTokens for token:', tokenAddress);
                        const rescueTx = await CONTRACT.rescueAndSellStuckTokens([tokenAddress]);
                        console.log('â³ Rescue transaction sent:', rescueTx.hash);

                        const rescueReceipt = await rescueTx.wait();
                        console.log('âœ… Rescue confirmed:', rescueReceipt.transactionHash);

                        if (rescueReceipt.logs && rescueReceipt.logs.length > 0) {
                            console.log('ï¿½ Rescue completed with', rescueReceipt.logs.length, 'events');
                        }

                        showStatus('Rewards successfully collected and converted to ETH!', 'success');

                        // Refresh displays to show updated ETH balances
                        await checkPlatformFees();
                        return;

                    } catch (rescueError) {
                        console.error('Rescue tokens error:', rescueError);
                        let errorMsg = 'Rescue failed: ' + rescueError.message;

                        if (rescueError.message.includes('execution reverted')) {
                            errorMsg = 'Rescue failed - may be insufficient tokens or no liquidity';
                        } else if (rescueError.message.includes('user rejected')) {
                            errorMsg = 'Transaction rejected by user';
                        } else if (rescueError.message.includes('insufficient funds')) {
                            errorMsg = 'Insufficient ETH for gas fees';
                        }

                        showStatus('âŒ ' + errorMsg, 'error');
                        return;
                    }

                    showStatus('Testing batch swap function directly...', 'info');

                    // First test with callStatic to see what the error is
                    try {
                        console.log('ðŸ§ª Testing batchSwapTokenFees with callStatic...');
                        const result = await CONTRACT.callStatic.batchSwapTokenFees(userAddress, tokenAddress);
                        console.log('âœ… callStatic succeeded, result:', result);
                    } catch (testError) {
                        console.log('âŒ callStatic failed:', testError.message);
                        if (testError.message.includes('INSUFFICIENT_BALANCE')) {
                            showStatus('Insufficient tokens available for processing', 'error');
                            return;
                        } else if (testError.message.includes('NO_LIQUIDITY')) {
                            showStatus('Trading liquidity not yet available for this token', 'error');
                            return;
                        } else if (testError.message.includes('NOT_AUTHORIZED')) {
                            showStatus('Unable to process tokens at this time', 'error');
                            return;
                        }
                        // Continue anyway to see the real error
                        console.log('ðŸ¤” Continuing with actual transaction despite callStatic error...');
                    }

                    showStatus('Processing token fees...', 'info');

                    // Call the batch swap function
                    const tx = await CONTRACT.batchSwapTokenFees(userAddress, tokenAddress);
                    console.log('â³ Swap transaction sent:', tx.hash);

                    const receipt = await tx.wait();
                    console.log('âœ… Swap confirmed:', receipt.transactionHash);

                    // Check how much was swapped
                    if (receipt.logs && receipt.logs.length > 0) {
                        console.log('ðŸ“‹ Swap completed with', receipt.logs.length, 'events');
                    }

                    showStatus('Token fees successfully processed!', 'success');

                    // Refresh displays to show updated ETH balances
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Batch swap error:', error);
                    let errorMsg = 'Batch swap failed: ' + error.message;

                    if (error.message.includes('execution reverted')) {
                        errorMsg = 'Swap failed - may be insufficient liquidity or slippage too high';
                    } else if (error.message.includes('user rejected')) {
                        errorMsg = 'Transaction rejected by user';
                    } else if (error.message.includes('insufficient funds')) {
                        errorMsg = 'Insufficient ETH for gas fees';
                    }

                    showStatus('âŒ ' + errorMsg, 'error');
                }
            }

            // Show token selection dialog for multi-project fee collection
            async function showTokenSelectionDialog(tokenOptions) {
                return new Promise((resolve) => {
                    // Create modal dialog
                    const modal = document.createElement('div');
                    modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                    const dialog = document.createElement('div');
                    dialog.className = 'token-selection-modal';
                    dialog.style.cssText = `
                    background: white;
                    border-radius: 10px;
                    padding: 30px;
                    max-width: 600px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;

                    const tokensWithRewards = tokenOptions.filter(opt => opt.hasRewards);
                    const tokensWithoutRewards = tokenOptions.filter(opt => !opt.hasRewards);

                    dialog.innerHTML = `
                    <h2 style="margin-top: 0; color: #333; text-align: center;">Select Tokens to Collect Rewards</h2>
                    <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 12px; margin-bottom: 20px; color: #856404;">
                        <strong>Multiple Transaction Notice:</strong> Each selected token will require a separate transaction. You'll need to approve each transaction in your wallet.
                    </div>
                    <p style="color: #666; text-align: center; margin-bottom: 25px;">
                        Choose which tokens you want to collect LP rewards from to save on gas fees.
                    </p>
                    
                    ${tokensWithRewards.length > 0 ? `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #28a745; margin-bottom: 15px;">Tokens with Available Rewards:</h3>
                            ${tokensWithRewards.map(opt => `
                                <label style="display: block; margin-bottom: 10px; padding: 15px; border: 2px solid #28a745; border-radius: 8px; cursor: pointer; background-color: #f8fff8;">
                                    <input type="checkbox" value="${opt.index}" checked style="margin-right: 10px; transform: scale(1.3);">
                                    <div style="color: #333;">
                                        <strong style="font-size: 16px; color: #1a5f1a;">${opt.symbol}</strong>
                                        <br>
                                        <span style="color: #555; font-size: 14px;">Available: ${opt.rewardDisplay}</span>
                                        <br>
                                        <span style="color: #777; font-size: 12px;">Position ID: ${opt.tokenId}</span>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${tokensWithoutRewards.length > 0 ? `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #dc3545; margin-bottom: 15px;">Tokens without Rewards:</h3>
                            ${tokensWithoutRewards.map(opt => `
                                <label style="display: block; margin-bottom: 10px; padding: 15px; border: 2px solid #ddd; border-radius: 8px; background-color: #f8f8f8;">
                                    <input type="checkbox" value="${opt.index}" disabled style="margin-right: 10px; transform: scale(1.3);">
                                    <div style="color: #666;">
                                        <strong style="font-size: 16px; color: #999;">${opt.symbol}</strong>
                                        <br>
                                        <span style="color: #999; font-size: 14px;">No rewards available</span>
                                        <br>
                                        <span style="color: #bbb; font-size: 12px;">Position ID: ${opt.tokenId || 'unknown'}</span>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 30px; flex-wrap: wrap;">
                        <button id="selectAll" style="padding: 12px 24px; background-color: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Select All Available
                        </button>
                        <button id="confirmSelection" style="padding: 12px 24px; background-color: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Collect Selected (${tokensWithRewards.length} txns)
                        </button>
                        <button id="cancelSelection" style="padding: 12px 24px; background-color: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Cancel
                        </button>
                    </div>
                `;

                    modal.appendChild(dialog);
                    document.body.appendChild(modal);

                    // Event listeners
                    const selectAllBtn = dialog.querySelector('#selectAll');
                    const confirmBtn = dialog.querySelector('#confirmSelection');
                    const cancelBtn = dialog.querySelector('#cancelSelection');
                    const checkboxes = dialog.querySelectorAll('input[type="checkbox"]:not([disabled])');

                    // Function to update button text based on selection
                    const updateConfirmButtonText = () => {
                        const selectedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
                        confirmBtn.textContent = `Collect Selected (${selectedCount} txns)`;
                        confirmBtn.disabled = selectedCount === 0;
                        confirmBtn.style.opacity = selectedCount === 0 ? '0.5' : '1';
                    };

                    // Add change listeners to checkboxes
                    checkboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', updateConfirmButtonText);
                    });

                    selectAllBtn.addEventListener('click', () => {
                        checkboxes.forEach(cb => cb.checked = true);
                        updateConfirmButtonText();
                    });

                    confirmBtn.addEventListener('click', () => {
                        const selected = Array.from(checkboxes)
                            .filter(cb => cb.checked)
                            .map(cb => parseInt(cb.value));

                        document.body.removeChild(modal);
                        resolve(selected);
                    });

                    cancelBtn.addEventListener('click', () => {
                        document.body.removeChild(modal);
                        resolve(null);
                    });

                    // Close on backdrop click
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            document.body.removeChild(modal);
                            resolve(null);
                        }
                    });
                });
            }

            // Collect tokens directly to creator wallet (no conversion needed)
            async function transferTokensToCreator() {
                console.log('ðŸš€ Collect creator tokens from selected projects directly to wallet!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    console.log('ðŸ”„ Starting direct creator token collection...');

                    // Get current creator's tokens
                    const userTokens = await getUserTokens(userAddress);
                    if (userTokens.length === 0) {
                        showStatus('No tokens found for your wallet address', 'error');
                        return;
                    }

                    console.log(`ðŸ“Š Found ${userTokens.length} token(s) available for collection`);

                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function symbol() view returns (string)"
                    ];

                    // Step 1: If multiple tokens, let user select which ones to collect
                    let selectedTokens = userTokens;

                    if (userTokens.length === 1) {
                        console.log('ðŸ”„ Single token found, processing directly...');
                        const tokenInfo = userTokens[0];
                        const tokenAddress = tokenInfo[0];
                        const tokenId = tokenInfo[4];

                        // Quick check if single token has rewards
                        try {
                            const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                            const contractBalance = await tokenContract.balanceOf(CONTRACT.address);
                            const tokenSymbol = await tokenContract.symbol();

                            console.log(`ðŸ“Š Single token ${tokenSymbol} - contract balance:`, ethers.utils.formatEther(contractBalance));

                            if (contractBalance.eq(0)) {
                                // Check position rewards as well
                                try {
                                    const positionManagerContract = new ethers.Contract(
                                        '0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1',
                                        [
                                            "function positions(uint256) view returns (uint96, address, address, address, uint24, int24, int24, uint128, uint256, uint256, uint128, uint128)"
                                        ],
                                        provider
                                    );

                                    const position = await positionManagerContract.positions(tokenId);
                                    const tokensOwed0 = position[10];
                                    const tokensOwed1 = position[11];

                                    console.log(`ðŸ’° Single token position ${tokenId} - tokensOwed0:`, ethers.utils.formatEther(tokensOwed0));
                                    console.log(`ðŸ’° Single token position ${tokenId} - tokensOwed1:`, ethers.utils.formatEther(tokensOwed1));

                                    if (tokensOwed0.eq(0) && tokensOwed1.eq(0)) {
                                        showStatus(`No LP rewards available for ${tokenSymbol}. Position may need to be refreshed.`, 'info');
                                        return;
                                    }
                                } catch (posError) {
                                    console.log('âš ï¸ Could not check position for single token:', posError.message);
                                    showStatus(`No LP rewards available for ${tokenSymbol}. Contract balance is zero.`, 'info');
                                    return;
                                }
                            }
                        } catch (error) {
                            console.log('âŒ Error checking single token:', error.message);
                        }
                    } else {
                        console.log('Multiple tokens found, reading reward data from existing cards...');
                        showStatus('Reading reward data from your token cards...', 'info');

                        // Get reward data from existing cards instead of re-detecting
                        const tokenOptions = [];
                        for (let i = 0; i < userTokens.length; i++) {
                            const tokenInfo = userTokens[i];
                            const tokenAddress = tokenInfo[0];
                            const tokenId = tokenInfo[4];

                            try {
                                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                                const tokenSymbol = await tokenContract.symbol();

                                // Find the corresponding fee section by token ID
                                const feesSectionId = `fees-section-${tokenId}`;
                                const feesSection = document.getElementById(feesSectionId);
                                let cardRewardText = '';
                                let hasRewards = false;

                                if (feesSection) {
                                    // Extract ETH and token amounts from the fee section
                                    const ethFeesElement = feesSection.querySelector('.eth-fees span');
                                    const tokenFeesElement = feesSection.querySelector('.token-fees span');

                                    const ethText = ethFeesElement ? ethFeesElement.textContent : '';
                                    const tokenText = tokenFeesElement ? tokenFeesElement.textContent : '';

                                    console.log(`Token ${tokenSymbol} - ETH text: "${ethText}", Token text: "${tokenText}"`);

                                    // Check if there are meaningful rewards
                                    const ethMatch = ethText.match(/([0-9.]+)\s*ETH/);
                                    const tokenMatch = tokenText.match(/\+\s*([0-9.]+)\s*\S+/);

                                    const ethAmount = ethMatch ? parseFloat(ethMatch[1]) : 0; // This is already creator's 50% share
                                    const tokenAmount = tokenMatch ? parseFloat(tokenMatch[1]) : 0;

                                    hasRewards = ethAmount > 0.000001 || tokenAmount > 0.000001;

                                    if (hasRewards) {
                                        const parts = [];
                                        if (ethAmount > 0.000001) parts.push(`${ethAmount.toFixed(6)} ETH`);
                                        if (tokenAmount > 0.000001) parts.push(`${tokenAmount.toFixed(6)} ${tokenSymbol}`);
                                        cardRewardText = parts.join(' + ');
                                    } else {
                                        cardRewardText = 'Very small or no rewards';
                                    }

                                    console.log(`Token ${tokenSymbol} - Final: hasRewards=${hasRewards}, display="${cardRewardText}"`);
                                } else {
                                    console.log(`No fee section found for token ID ${tokenId}`);
                                    cardRewardText = 'Fee section not found';
                                }

                                tokenOptions.push({
                                    index: i,
                                    tokenInfo: tokenInfo,
                                    symbol: tokenSymbol,
                                    hasRewards: hasRewards,
                                    rewardDisplay: cardRewardText.trim() || 'No reward data found',
                                    tokenId: tokenId.toString()
                                });

                            } catch (error) {
                                console.log(`Error processing token ${i}:`, error.message);
                                tokenOptions.push({
                                    index: i,
                                    tokenInfo: tokenInfo,
                                    symbol: `Token ${i + 1}`,
                                    hasRewards: false,
                                    rewardDisplay: 'Error loading data',
                                    tokenId: 'unknown'
                                });
                            }
                        }

                        // Show selection dialog
                        const tokensWithRewards = tokenOptions.filter(opt => opt.hasRewards);
                        const tokensWithoutRewards = tokenOptions.filter(opt => !opt.hasRewards);

                        console.log('ðŸ“Š Token options summary:');
                        console.log('  Total tokens:', tokenOptions.length);
                        console.log('  Tokens with rewards:', tokensWithRewards.length);
                        console.log('  Tokens without rewards:', tokensWithoutRewards.length);

                        tokenOptions.forEach((opt, i) => {
                            console.log(`  ${i + 1}. ${opt.symbol}: hasRewards=${opt.hasRewards}, ETH=${opt.ethRewards}, Tokens=${opt.tokenRewards}`);
                        });

                        if (tokensWithRewards.length === 0) {
                            console.log('No tokens with rewards found');
                            showStatus('No LP rewards are currently available for your tokens. Try refreshing the page or waiting for more trading activity.', 'info');
                            return;
                        }

                        const selection = await showTokenSelectionDialog(tokenOptions);
                        if (!selection || selection.length === 0) {
                            showStatus('Collection cancelled by user.', 'info');
                            return;
                        }

                        selectedTokens = selection.map(index => userTokens[index]);
                        console.log(`ðŸ‘¤ User selected ${selectedTokens.length} token(s) for collection`);
                    }

                    let totalCollected = 0;
                    let successfulCollections = 0;
                    const collectionResults = [];

                    // Step 2: Process each selected token project
                    for (let i = 0; i < selectedTokens.length; i++) {
                        const tokenInfo = selectedTokens[i];
                        const tokenAddress = tokenInfo[0];
                        const tokenId = tokenInfo[4];
                        const creatorAddress = userAddress;

                        console.log(`\nðŸ”„ Processing selected token ${i + 1}/${selectedTokens.length}:`);
                        console.log('ðŸ‘¤ Creator:', creatorAddress);
                        console.log('ðŸª™ Token:', tokenAddress);
                        console.log('ðŸ†” Token ID:', tokenId.toString());

                        try {
                            // Check current token balances for this token
                            const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                            const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                            const creatorWalletBalance = await tokenCONTRACT.balanceOf(creatorAddress);
                            const tokenSymbol = await tokenCONTRACT.symbol();

                            console.log(`ðŸ¦ CONTRACT has ${ethers.utils.formatEther(CONTRACTTokenBalance)} ${tokenSymbol}`);
                            console.log(`ðŸ‘¤ Creator wallet has ${ethers.utils.formatEther(creatorWalletBalance)} ${tokenSymbol}`);

                            if (CONTRACTTokenBalance.eq(0)) {
                                console.log(`â„¹ï¸ No LP fees available for ${tokenSymbol}, skipping...`);
                                collectionResults.push({ symbol: tokenSymbol, collected: '0', status: 'No fees available' });
                                continue;
                            }

                            // Collect LP fees from Uniswap position for this token
                            showStatus(`Collecting rewards from ${tokenSymbol} position (${i + 1}/${selectedTokens.length})...`, 'info');
                            try {
                                const collectTx = await CONTRACT.collectFees(tokenId);
                                console.log(`â³ CollectFees transaction sent for ${tokenSymbol}:`, collectTx.hash);

                                const collectReceipt = await collectTx.wait();
                                console.log(`âœ… CollectFees confirmed for ${tokenSymbol}:`, collectReceipt.transactionHash);

                                if (collectReceipt.logs && collectReceipt.logs.length > 0) {
                                    console.log(`ðŸ“‹ Collection completed for ${tokenSymbol} with ${collectReceipt.logs.length} events`);
                                }

                                // Check what we collected for this token
                                const newCONTRACTBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                                const newCreatorWalletBalance = await tokenCONTRACT.balanceOf(creatorAddress);
                                const creatorTokenBalance = await CONTRACT.getCreatorTokenBalance(creatorAddress);

                                const tokensCollected = CONTRACTTokenBalance.sub(newCONTRACTBalance);
                                const tokensToWallet = newCreatorWalletBalance.sub(creatorWalletBalance);

                                let collectedAmount = '0';
                                let status = 'Success';

                                if (tokensToWallet.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(tokensToWallet);
                                    console.log(`âœ… ${collectedAmount} ${tokenSymbol} transferred to wallet`);
                                } else if (creatorTokenBalance.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(creatorTokenBalance);
                                    console.log(`âœ… ${collectedAmount} ${tokenSymbol} collected`);
                                } else if (tokensCollected.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(tokensCollected);
                                    console.log(`âœ… ${collectedAmount} ${tokenSymbol} rewards collected`);
                                } else {
                                    status = 'No token rewards found';
                                    console.log(`â„¹ï¸ LP fees collected for ${tokenSymbol}, but no token rewards found`);
                                }

                                collectionResults.push({
                                    symbol: tokenSymbol,
                                    collected: collectedAmount,
                                    status: status
                                });

                                if (parseFloat(collectedAmount) > 0) {
                                    totalCollected += parseFloat(collectedAmount);
                                    successfulCollections++;
                                }

                            } catch (collectError) {
                                console.log(`âŒ Collect LP fees failed for ${tokenSymbol}:`, collectError.message);
                                collectionResults.push({
                                    symbol: tokenSymbol,
                                    collected: '0',
                                    status: 'Collection failed: ' + collectError.message
                                });
                                // Continue with other tokens instead of stopping
                                continue;
                            }

                        } catch (tokenError) {
                            console.log(`âŒ Error processing token ${i + 1}:`, tokenError.message);
                            collectionResults.push({
                                symbol: `Token ${i + 1}`,
                                collected: '0',
                                status: 'Processing error: ' + tokenError.message
                            });
                            continue;
                        }
                    }

                    // Step 2: Display comprehensive results
                    console.log('\nï¿½ Collection Summary:');
                    console.log(`âœ… Successfully processed: ${successfulCollections}/${selectedTokens.length} selected tokens`);
                    console.log(`ðŸ’° Total value collected: ${totalCollected} tokens`);

                    let resultMessage = `Collection completed for ${selectedTokens.length} selected project(s):\n`;
                    collectionResults.forEach((result, index) => {
                        if (parseFloat(result.collected) > 0) {
                            resultMessage += `âœ… ${result.symbol}: ${result.collected} tokens collected\n`;
                        } else {
                            resultMessage += `â„¹ï¸ ${result.symbol}: ${result.status}\n`;
                        }
                    });

                    if (successfulCollections > 0) {
                        showStatus(`Success! Collected LP rewards from ${successfulCollections} selected project(s). Your wallet should now contain the collected tokens and you can now claim your ETH.`, 'success');
                        console.log(resultMessage);
                    } else if (collectionResults.length > 0) {
                        showStatus(`â„¹ï¸ Processed ${selectedTokens.length} selected project(s) but no LP rewards were available to collect.`, 'info');
                    } else {
                        showStatus('No projects found to process.', 'error');
                    }

                    // Refresh displays to show updated balances
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Creator token collection error:', error);
                    showStatus('âŒ Collection failed: ' + error.message, 'error');
                }
            }

            // Admin function to collect all platform fees and distribute them
            async function collectAllPlatformFees() {
                console.log('ðŸ”¥ Admin: Collecting ALL platform fees!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    // First check if user is platform admin
                    const platformAdmin = await CONTRACT.platformAdmin();
                    console.log('ðŸ‘‘ Platform admin address:', platformAdmin);
                    console.log('ðŸ‘¤ Current user address:', userAddress);

                    if (userAddress.toLowerCase() !== platformAdmin.toLowerCase()) {
                        showStatus('âŒ Only platform admin can collect all fees', 'error');
                        return;
                    }

                    console.log('âœ… Admin verified, proceeding with platform-wide collection...');
                    showStatus('ðŸ”¥ Admin: Starting platform-wide fee collection...', 'info');

                    // Get total token count
                    const totalTokens = await CONTRACT.getTokenCount();
                    console.log('ðŸ“Š Total tokens in platform:', totalTokens.toString());

                    if (totalTokens.eq(0)) {
                        showStatus('No tokens in platform to collect fees from', 'info');
                        return;
                    }

                    // Step 1: Use collectAllTokens function to collect from all LP positions
                    showStatus('Step 1: Collecting fees from all LP positions...', 'info');
                    try {
                        const collectAllTx = await CONTRACT.collectAllTokens();
                        console.log('â³ CollectAllTokens transaction sent:', collectAllTx.hash);

                        const collectAllReceipt = await collectAllTx.wait();
                        console.log('âœ… CollectAllTokens confirmed:', collectAllReceipt.transactionHash);

                        if (collectAllReceipt.logs && collectAllReceipt.logs.length > 0) {
                            console.log('ðŸ“‹ Collection completed with', collectAllReceipt.logs.length, 'events');
                        }

                    } catch (collectAllError) {
                        console.log('âŒ CollectAllTokens failed:', collectAllError.message);
                        showStatus('âŒ Failed to collect from all positions: ' + collectAllError.message, 'error');
                        return;
                    }

                    // Step 2: Check what we collected
                    const platformFees = await CONTRACT.getPlatformFees();
                    console.log('ðŸ¢ Platform fees after collection:', ethers.utils.formatEther(platformFees), 'ETH');

                    showStatus('Step 2: Checking collected fees and token balances...', 'info');

                    // Step 3: For each token, try to convert any stuck tokens to ETH
                    showStatus('Step 3: Converting any stuck tokens to ETH...', 'info');

                    const tokenAddresses = [];

                    // Get all token addresses for rescue operation
                    for (let i = 0; i < Math.min(totalTokens.toNumber(), 50); i++) { // Limit to 50 for gas reasons
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            tokenAddresses.push(tokenInfo.tokenAddress);
                        } catch (error) {
                            console.log(`âŒ Failed to get token ${i}:`, error.message);
                        }
                    }

                    console.log('ðŸŽ¯ Found', tokenAddresses.length, 'token addresses for rescue');

                    if (tokenAddresses.length > 0) {
                        try {
                            const rescueTx = await CONTRACT.rescueAndSellStuckTokens(tokenAddresses);
                            console.log('â³ Rescue transaction sent:', rescueTx.hash);

                            const rescueReceipt = await rescueTx.wait();
                            console.log('âœ… Rescue confirmed:', rescueReceipt.transactionHash);

                        } catch (rescueError) {
                            console.log('âŒ Rescue failed (may be no stuck tokens):', rescueError.message);
                        }
                    }

                    // Step 4: Final fee check and summary
                    const finalPlatformFees = await CONTRACT.getPlatformFees();
                    console.log('ðŸ’° Final platform fees:', ethers.utils.formatEther(finalPlatformFees), 'ETH');

                    const totalCollected = finalPlatformFees.sub(platformFees);

                    if (totalCollected.gt(0)) {
                        showStatus(`âœ… Success! Collected ${ethers.utils.formatEther(totalCollected)} ETH from all positions. Ready to withdraw platform fees.`, 'success');
                    } else {
                        showStatus('âœ… Fee collection completed. No new fees were available across all positions.', 'success');
                    }

                    // Refresh displays
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Admin fee collection error:', error);
                    showStatus('âŒ Admin collection failed: ' + error.message, 'error');
                }
            }

            // Function to collect fees for a specific token
            async function collectFeesForToken(tokenName) {
                console.log(`ðŸ’° COLLECTING FEES FOR ${tokenName}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("âŒ Provider or CONTRACT not available");
                        showStatus('Please connect your wallet first', 'error');
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("ðŸ‘¤ User address:", userAddress);

                    // Get all tokens to find the specific one
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    let targetToken = null;

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            if (tokenInfo.name && tokenInfo.name.includes(tokenName)) {
                                targetToken = tokenInfo;
                                console.log(`âœ… Found ${tokenName}:`, tokenInfo);
                                break;
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    if (!targetToken) {
                        console.log(`âŒ ${tokenName} not found!`);
                        showStatus(`âŒ ${tokenName} not found in contract`, 'error');
                        return;
                    }

                    console.log(`ðŸŽ¯ Collecting fees for ${tokenName} (${targetToken.tokenAddress})`);
                    showStatus(`ðŸ”„ Collecting fees from ${tokenName}'s liquidity pool...`, 'info');

                    // Call the contract to collect fees for this token
                    const tx = await CONTRACT.collectTokenFees(targetToken.tokenAddress);
                    console.log("ðŸ“ Transaction sent:", tx.hash);
                    showStatus(`â³ Collecting ${tokenName} fees... Transaction: ${tx.hash.substring(0, 10)}...`, 'info');

                    // Wait for confirmation
                    const receipt = await tx.wait();
                    console.log("âœ… Transaction confirmed:", receipt);

                    showStatus(`âœ… ${tokenName} fees collected successfully!`, 'success');

                    // Refresh fee displays
                    setTimeout(() => {
                        checkPlatformFees();
                        loadUserTokens();
                    }, 2000);

                } catch (error) {
                    console.error(`âŒ Error collecting ${tokenName} fees:`, error);
                    showStatus(`âŒ Failed to collect ${tokenName} fees: ${error.message}`, 'error');
                }
            }

            // Debug function to check all user tokens
            async function debugUserTokens() {
                console.log(`ðŸ” DEBUGGING ALL USER TOKENS`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("âŒ Provider or CONTRACT not available");
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("ðŸ‘¤ User address:", userAddress);
                    console.log("ðŸ­ Contract address:", CONTRACT.address);

                    // Get all tokens
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    console.log("ðŸ“Š Total tokens in contract:", totalTokenCount.toString());

                    let userTokens = [];
                    let totalUserFees = ethers.BigNumber.from("0");

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            console.log(`Token ${i}:`, tokenInfo);

                            // Check if user is the creator
                            if (tokenInfo.creator && tokenInfo.creator.toLowerCase() === userAddress.toLowerCase()) {
                                const tokenFees = ethers.BigNumber.from(tokenInfo.totalFeesETH || "0");
                                const creatorPortion = tokenFees.mul(50).div(100);

                                userTokens.push({
                                    index: i,
                                    name: tokenInfo.name,
                                    address: tokenInfo.tokenAddress,
                                    totalFees: ethers.utils.formatEther(tokenFees),
                                    creatorShare: ethers.utils.formatEther(creatorPortion)
                                });

                                totalUserFees = totalUserFees.add(creatorPortion);
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    console.log("ðŸŽ¯ USER'S TOKENS:");
                    userTokens.forEach((token, idx) => {
                        console.log(`  ${idx + 1}. ${token.name}`);
                        console.log(`     Address: ${token.address}`);
                        console.log(`     Total Fees: ${token.totalFees} ETH`);
                        console.log(`     Creator Share: ${token.creatorShare} ETH`);
                    });

                    console.log(`ðŸ’° Total lifetime earnings: ${ethers.utils.formatEther(totalUserFees)} ETH`);

                    // Check current withdrawable fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log("ðŸ’¸ Current withdrawable creator fees:", ethers.utils.formatEther(creatorFees), "ETH");

                    if (userTokens.length === 0) {
                        console.log("âŒ No tokens found for current user in this contract!");
                        console.log("This could mean:");
                        console.log("1. You haven't created any tokens with this contract");
                        console.log("2. Your tokens were created with a previous contract version");
                        console.log("3. There's a mismatch in wallet address");
                    }

                } catch (error) {
                    console.error(`âŒ Error debugging user tokens:`, error);
                }
            }

            // Enhanced debug function for specific token with detailed fee tracking
            async function debugTokenFees(tokenName) {
                console.log(`ðŸ” DEBUGGING FEES FOR ${tokenName}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("âŒ Provider or CONTRACT not available");
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("ðŸ‘¤ User address:", userAddress);
                    console.log("ðŸ­ Contract address:", CONTRACT.address);

                    // Get all tokens
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    console.log("ðŸ“Š Total tokens in contract:", totalTokenCount.toString());

                    // Find the specific token
                    let foundToken = null;
                    let tokenIndex = -1;

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            console.log(`Token ${i}:`, tokenInfo);

                            if (tokenInfo.name && tokenInfo.name.includes(tokenName)) {
                                foundToken = tokenInfo;
                                tokenIndex = i;
                                console.log(`âœ… Found ${tokenName} at index ${i}:`, tokenInfo);
                                break;
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    if (!foundToken) {
                        console.log(`âŒ ${tokenName} not found in current contract!`);
                        return;
                    }

                    console.log(`ðŸŽ¯ ${tokenName} DETAILED ANALYSIS:`);
                    console.log("  - Token Address:", foundToken.tokenAddress);
                    console.log("  - Creator:", foundToken.creator);
                    console.log("  - Total Fees (stored):", ethers.utils.formatEther(foundToken.totalFeesETH || "0"), "ETH");
                    console.log("  - Created by current user:", foundToken.creator.toLowerCase() === userAddress.toLowerCase());
                    console.log("  - Token raw data:", foundToken);

                    // Check if user is the creator
                    if (foundToken.creator.toLowerCase() === userAddress.toLowerCase()) {
                        const creatorPortion = ethers.BigNumber.from(foundToken.totalFeesETH || "0").mul(50).div(100);
                        console.log("ðŸ’° Creator's share:", ethers.utils.formatEther(creatorPortion), "ETH");
                    } else {
                        console.log("â„¹ï¸ User is not the creator of this token");
                    }

                    // Check current withdrawable fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log("ðŸ’¸ Current withdrawable creator fees:", ethers.utils.formatEther(creatorFees), "ETH");

                    // Additional debugging - check if token has any Uniswap activity
                    console.log("ðŸ” CHECKING UNISWAP ACTIVITY...");
                    try {
                        const tokenContract = new ethers.Contract(foundToken.tokenAddress, [
                            "function balanceOf(address) view returns (uint256)",
                            "function totalSupply() view returns (uint256)",
                            "function name() view returns (string)",
                            "function symbol() view returns (string)"
                        ], provider);

                        const tokenSupply = await tokenContract.totalSupply();
                        console.log("ðŸ“Š Token total supply:", ethers.utils.formatEther(tokenSupply));

                        // Check token balance in Uniswap V3 Position Manager (this is where LP tokens are held)
                        const POSITION_MANAGER = "0x03a520b32C04BF3bEEf7BF5d24FC2e9de0e4a1e7";
                        const lpBalance = await tokenContract.balanceOf(POSITION_MANAGER);
                        console.log("ðŸ’§ Tokens in Uniswap LP:", ethers.utils.formatEther(lpBalance));

                        if (lpBalance.gt(0)) {
                            console.log("âœ… Token has liquidity in Uniswap - trades should generate fees");
                            console.log("ðŸ” Fee generation requires actual trades/swaps on Uniswap");
                            console.log("ðŸ’¡ Try making a small swap on the token to generate fees");
                        } else {
                            console.log("âš ï¸ No tokens found in Uniswap LP - fees can only generate from trades");
                        }

                    } catch (tokenError) {
                        console.log("âš ï¸ Could not check token contract details:", tokenError.message);
                    }

                    console.log("ðŸŽ¯ DEBUGGING SUMMARY:");
                    console.log(`   Token exists in contract: YES`);
                    console.log(`   Creator matches user: ${foundToken.creator.toLowerCase() === userAddress.toLowerCase() ? 'YES' : 'NO'}`);
                    console.log(`   Fees stored in contract: ${ethers.utils.formatEther(foundToken.totalFeesETH || "0")} ETH`);
                    console.log(`   To generate fees: Make trades on Uniswap for this token`);

                } catch (error) {
                    console.error(`âŒ Error debugging ${tokenName}:`, error);
                }
            }

            // Function to manually collect fees for a specific token
            async function manualCollectTokenFees(tokenAddress) {
                console.log(`ðŸ”„ MANUALLY COLLECTING FEES FOR TOKEN: ${tokenAddress}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("âŒ Provider or CONTRACT not available");
                        return;
                    }

                    console.log("ðŸ“ž Calling collectTokenFees...");
                    const tx = await CONTRACT.collectTokenFees(tokenAddress);
                    console.log("ðŸ“‹ Transaction sent:", tx.hash);

                    showStatus(`ðŸ”„ Collecting fees for token... TX: ${tx.hash}`, 'info');

                    const receipt = await tx.wait();
                    console.log("âœ… Transaction confirmed:", receipt);

                    // Check fees again after collection
                    setTimeout(() => {
                        checkPlatformFees();
                    }, 3000);

                    showStatus(`âœ… Fees collected successfully!`, 'success');

                } catch (error) {
                    console.error(`âŒ Error collecting fees:`, error);
                    showStatus(`âŒ Error collecting fees: ${error.message}`, 'error');
                }
            }

            // Debug function to understand withdrawal issues
            async function debugWithdrawCreatorFees() {
                console.log('ðŸ” DEBUGGING WITHDRAW CREATOR FEES');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    showStatus('ðŸ” Debugging withdrawal issue...', 'info');

                    // Check multiple calls to see if state is changing
                    console.log('ðŸ“ž Making multiple getCreatorFees calls...');

                    const fees1 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('ðŸ” Call 1 - Creator fees:', ethers.utils.formatEther(fees1), 'ETH', '(' + fees1.toString() + ' wei)');

                    const fees2 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('ðŸ” Call 2 - Creator fees:', ethers.utils.formatEther(fees2), 'ETH', '(' + fees2.toString() + ' wei)');

                    const fees3 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('ðŸ” Call 3 - Creator fees:', ethers.utils.formatEther(fees3), 'ETH', '(' + fees3.toString() + ' wei)');

                    // Check CONTRACT ETH balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);
                    console.log('ðŸ¦ CONTRACT ETH balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH', '(' + CONTRACTBalance.toString() + ' wei)');

                    if (CONTRACTBalance.lt(fees1)) {
                        console.log('âŒ CONTRACT BALANCE TOO LOW! CONTRACT has', ethers.utils.formatEther(CONTRACTBalance), 'but needs', ethers.utils.formatEther(fees1));
                        showStatus('Insufficient balance available for withdrawal', 'error');
                        return;
                    } else {
                        console.log('âœ… CONTRACT has sufficient balance for withdrawal');
                    }

                    if (fees1.eq(fees2) && fees2.eq(fees3)) {
                        console.log('âœ… Fees are consistent across calls');
                    } else {
                        console.log('âŒ WARNING: Fees are changing between calls!');
                    }

                    // Check if amount is greater than 0
                    if (fees1.gt(0)) {
                        console.log('âœ… Amount is greater than 0, should be withdrawable');

                        // Try to estimate gas for the withdrawal
                        try {
                            console.log('ðŸ” Trying to estimate gas for withdrawal...');
                            const gasEstimate = await CONTRACT.estimateGas.withdrawCreatorFees();
                            console.log('âœ… Gas estimate successful:', gasEstimate.toString());

                            showStatus('âœ… Gas estimation passed - trying actual withdrawal...', 'info');

                            // If gas estimation works, try the actual call
                            const tx = await CONTRACT.withdrawCreatorFees();
                            console.log('âœ… Transaction submitted:', tx.hash);
                            showStatus('â³ Waiting for confirmation...', 'info');

                            const receipt = await tx.wait();
                            console.log('âœ… Transaction confirmed:', receipt.transactionHash);
                            showStatus('Withdrawal successful!', 'success');

                        } catch (gasError) {
                            console.log('âŒ Gas estimation failed:', gasError.message);
                            console.log('âŒ Full gas error:', gasError);

                            // Try to understand why gas estimation fails
                            if (gasError.message.includes('execution reverted')) {
                                console.log('ðŸ’¡ The CONTRACT is reverting - checking why...');

                                // Double-check the amount right before the call
                                const lastCheck = await CONTRACT.getCreatorFees(userAddress);
                                console.log('ðŸ” Final amount check:', ethers.utils.formatEther(lastCheck), 'ETH');

                                if (lastCheck.eq(0)) {
                                    showStatus('âŒ Amount became 0 just before withdrawal - possible race condition', 'error');
                                } else {
                                    console.log('âŒ CONTRACT is reverting even though amount > 0 - trying manual gas approach...');

                                    // Try with optimized gas limit
                                    try {
                                        console.log('ðŸ”§ Attempting withdrawal with optimized gas limit...');

                                        // Smart gas estimation for withdrawal
                                        let gasLimit;
                                        try {
                                            const estimatedGas = await CONTRACT.estimateGas.withdrawCreatorFees();
                                            gasLimit = Math.floor(estimatedGas.toNumber() * 1.2); // 20% buffer
                                            console.log(`ðŸ’¡ Withdrawal gas optimized: ${gasLimit}`);
                                        } catch (estError) {
                                            gasLimit = 80000; // Lower conservative limit
                                        }

                                        const tx = await CONTRACT.withdrawCreatorFees({
                                            gasLimit: gasLimit  // Optimized gas limit
                                        });
                                        console.log('âœ… Optimized gas transaction submitted:', tx.hash);
                                        showStatus('â³ Optimized withdrawal submitted...', 'info');

                                        const receipt = await tx.wait();
                                        console.log('âœ… Manual gas withdrawal confirmed:', receipt.transactionHash);
                                        showStatus('âœ… Manual gas withdrawal successful!', 'success');

                                    } catch (manualGasError) {
                                        console.log('âŒ Manual gas also failed:', manualGasError.message);

                                        // Check if there's a minimum threshold issue
                                        if (lastCheck.lt(ethers.utils.parseEther('0.0001'))) {
                                            console.log('âš ï¸ Amount might be below minimum threshold');
                                            showStatus('âŒ Amount too small - CONTRACT may have minimum withdrawal threshold', 'error');
                                        } else {
                                            showStatus('âŒ CONTRACT bug confirmed - withdrawal impossible even with manual gas', 'error');
                                        }
                                    }
                                }
                            } else {
                                showStatus('âŒ Gas estimation error: ' + gasError.message, 'error');
                            }
                        }

                    } else {
                        console.log('âŒ Amount is 0, cannot withdraw');
                        showStatus('No fees available for withdrawal', 'error');
                    }

                } catch (error) {
                    console.error('âŒ Debug error:', error);
                    showStatus('âŒ Debug failed: ' + error.message, 'error');
                }
            }

            // Admin panel balance check with on-page results
            async function adminCheckBalance() {
                console.log('ðŸ” ADMIN: Checking CONTRACT balance vs expected fees');

                const resultDiv = document.getElementById('balanceCheckResult');
                const CONTRACTAddress = CONTRACT?.address || TOKEN_FACTORY_ADDRESS || "0xaB4FE16F395921081bD9895359cf173a2Eaa7125";

                if (!CONTRACT || !userAddress) {
                    resultDiv.innerHTML = '<div style="background:#fee2e2; color:#dc2626; padding:8px; border-radius:4px;">âŒ Please connect your wallet first</div>';
                    resultDiv.style.display = 'block';
                    return;
                }

                try {
                    resultDiv.innerHTML = '<div style="background:#e0f2fe; color:#0369a1; padding:8px; border-radius:4px;">ðŸ” Checking CONTRACT balance...</div>';
                    resultDiv.style.display = 'block';

                    // Get expected fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalExpectedFees = creatorFees.add(platformFees);

                    // Get actual CONTRACT balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);

                    // Log to console for debugging
                    console.log('ðŸ’° Expected creator fees:', ethers.utils.formatEther(creatorFees), 'ETH');
                    console.log('ðŸ¢ Expected platform fees:', ethers.utils.formatEther(platformFees), 'ETH');
                    console.log('ðŸ“Š Total expected fees:', ethers.utils.formatEther(totalExpectedFees), 'ETH');
                    console.log('ðŸ¦ Actual CONTRACT balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH');

                    let resultHTML = '';

                    if (CONTRACTBalance.eq(0)) {
                        console.log('âŒ CONTRACT IS EMPTY! All ETH was drained.');
                        console.log('ðŸ”§ TO FIX: Send exactly', ethers.utils.formatEther(totalExpectedFees), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('ðŸŽ¯ EXACT AMOUNT IN WEI:', totalExpectedFees.toString());

                        resultHTML = `
                        <div style="background:#fee2e2; color:#dc2626; padding:12px; border-radius:6px; border-left:4px solid #dc2626;">
                            <div style="font-weight:600; margin-bottom:8px;">INSUFFICIENT BALANCE!</div>
                            <div style="margin-bottom:4px;">Expected rewards: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Current balance: <strong>0.000000 ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">TO RESOLVE:</div>
                                <div style="margin-bottom:4px;">Please contact support regarding the balance shortage</div>
                                <div style="font-weight:600; margin-bottom:2px;">Required amount:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-size:0.75rem; margin-bottom:4px;">${ethers.utils.formatEther(totalExpectedFees)} ETH</div>
                                <div style="margin-top:6px; font-size:0.7rem; color:rgba(0,0,0,0.7);">Exact wei: ${totalExpectedFees.toString()}</div>
                            </div>
                        </div>
                    `;
                    } else if (CONTRACTBalance.lt(totalExpectedFees)) {
                        const shortfall = totalExpectedFees.sub(CONTRACTBalance);
                        console.log('âš ï¸ CONTRACT UNDERFUNDED! Has', ethers.utils.formatEther(CONTRACTBalance), 'but owes', ethers.utils.formatEther(totalExpectedFees));
                        console.log('ðŸ’¸ SHORTFALL:', ethers.utils.formatEther(shortfall), 'ETH');
                        console.log('ðŸ”§ TO FIX: Send exactly', ethers.utils.formatEther(shortfall), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('ðŸŽ¯ EXACT SHORTFALL IN WEI:', shortfall.toString());

                        resultHTML = `
                        <div style="background:#fef3c7; color:#d97706; padding:12px; border-radius:6px; border-left:4px solid #d97706;">
                            <div style="font-weight:600; margin-bottom:8px;">CONTRACT UNDERFUNDED!</div>
                            <div style="margin-bottom:4px;">Expected fees: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Actual balance: <strong>${ethers.utils.formatEther(CONTRACTBalance)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Shortfall: <strong>${ethers.utils.formatEther(shortfall)} ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">TO FIX:</div>
                                <div style="margin-bottom:4px;">Send exactly <strong>${ethers.utils.formatEther(shortfall)} ETH</strong></div>
                                <div style="font-weight:600; margin-bottom:2px;">Send to this CONTRACT address:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-size:0.75rem; margin-bottom:4px; word-break:break-all;">${CONTRACTAddress}</div>
                                <div style="margin-top:6px; font-size:0.7rem; color:rgba(0,0,0,0.7);">Exact wei: ${shortfall.toString()}</div>
                            </div>
                        </div>
                    `;
                    } else {
                        const excess = CONTRACTBalance.sub(totalExpectedFees);
                        console.log('âœ… CONTRACT has sufficient balance');
                        console.log('ðŸ’° EXCESS ETH (safe to rescue):', ethers.utils.formatEther(excess), 'ETH');
                        console.log('ðŸŽ¯ EXCESS IN WEI:', excess.toString());

                        resultHTML = `
                        <div style="background:#d1fae5; color:#065f46; padding:12px; border-radius:6px; border-left:4px solid #10b981;">
                            <div style="font-weight:600; margin-bottom:8px;">CONTRACT BALANCE OK!</div>
                            <div style="margin-bottom:4px;">Expected fees: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Actual balance: <strong>${ethers.utils.formatEther(CONTRACTBalance)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Excess (safe to rescue): <strong>${ethers.utils.formatEther(excess)} ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">CONTRACT Address:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-size:0.75rem; margin-bottom:4px; word-break:break-all;">${CONTRACTAddress}</div>
                            </div>
                        </div>
                    `;
                    }

                    resultDiv.innerHTML = resultHTML;

                } catch (error) {
                    console.error('âŒ Balance check error:', error);
                    resultDiv.innerHTML = `
                    <div style="background:#fee2e2; color:#dc2626; padding:12px; border-radius:6px;">
                        <div style="font-weight:600; margin-bottom:4px;">âŒ Balance Check Failed</div>
                        <div style="font-size:0.8rem;">${error.message}</div>
                    </div>
                `;
                }
            }

            // Helper function to adjust button group layout when buttons are hidden
            function adjustButtonGroupLayout() {
                const switchBtn = document.getElementById('switchNetworkBtn');
                const buttonGroup = switchBtn?.parentElement;

                if (buttonGroup && buttonGroup.classList.contains('btn-group-2')) {
                    if (switchBtn.style.display === 'none') {
                        buttonGroup.classList.remove('btn-group-2');
                        buttonGroup.classList.add('btn-group-full');
                    } else {
                        buttonGroup.classList.remove('btn-group-full');
                        buttonGroup.classList.add('btn-group-2');
                    }
                }
            }

            // Simple function to check CONTRACT ETH balance vs expected fees
            async function checkCONTRACTBalance() {
                console.log('ðŸ” CHECKING CONTRACT BALANCE VS EXPECTED FEES');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    showStatus('ðŸ” Checking CONTRACT balance...', 'info');

                    // Get expected fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalExpectedFees = creatorFees.add(platformFees);

                    // Get actual CONTRACT balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);

                    console.log('ðŸ’° Expected creator fees:', ethers.utils.formatEther(creatorFees), 'ETH');
                    console.log('ðŸ¢ Expected platform fees:', ethers.utils.formatEther(platformFees), 'ETH');
                    console.log('ðŸ“Š Total expected fees:', ethers.utils.formatEther(totalExpectedFees), 'ETH');
                    console.log('ðŸ¦ Actual CONTRACT balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH');

                    if (CONTRACTBalance.eq(0)) {
                        console.log('âŒ CONTRACT IS EMPTY! All ETH was drained.');
                        console.log('ðŸ”§ TO FIX: Send exactly', ethers.utils.formatEther(totalExpectedFees), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('ðŸŽ¯ EXACT AMOUNT IN WEI:', totalExpectedFees.toString());
                        showStatus('âŒ CONTRACT has 0 ETH - fees were drained by rescue function!', 'error');
                    } else if (CONTRACTBalance.lt(totalExpectedFees)) {
                        const shortfall = totalExpectedFees.sub(CONTRACTBalance);
                        console.log('âš ï¸ CONTRACT UNDERFUNDED! Has', ethers.utils.formatEther(CONTRACTBalance), 'but owes', ethers.utils.formatEther(totalExpectedFees));
                        console.log('ðŸ’¸ SHORTFALL:', ethers.utils.formatEther(shortfall), 'ETH');
                        console.log('ðŸ”§ TO FIX: Send exactly', ethers.utils.formatEther(shortfall), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('ðŸŽ¯ EXACT SHORTFALL IN WEI:', shortfall.toString());
                        showStatus('âš ï¸ CONTRACT underfunded - rescue function drained some fees', 'error');
                    } else {
                        const excess = CONTRACTBalance.sub(totalExpectedFees);
                        console.log('âœ… CONTRACT has sufficient balance');
                        console.log('ðŸ’° EXCESS ETH (safe to rescue):', ethers.utils.formatEther(excess), 'ETH');
                        console.log('ðŸŽ¯ EXCESS IN WEI:', excess.toString());
                        showStatus('âœ… CONTRACT balance OK - withdrawal should work', 'success');
                    }

                } catch (error) {
                    console.error('âŒ Balance check error:', error);
                    showStatus('âŒ Balance check failed: ' + error.message, 'error');
                }
            }

            // Comprehensive rescue function for stuck tokens
            async function rescueStuckTokensComprehensive() {
                console.log('ðŸš€ Comprehensive rescue function called!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    console.log('ðŸ”„ Starting comprehensive token rescue...');

                    // Get user's tokens
                    const userTokens = await getUserTokens(userAddress);
                    console.log('ðŸ“‹ User tokens found:', userTokens.length);

                    if (userTokens.length === 0) {
                        showStatus('No tokens found to rescue', 'error');
                        return;
                    }

                    const tokenAddress = userTokens[0][0]; // First token address
                    const tokenId = userTokens[0][4]; // Token ID
                    console.log('ðŸŽ¯ Rescuing token:', tokenAddress, 'with ID:', tokenId.toString());

                    // Check CONTRACT token balance
                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function symbol() view returns (string)"
                    ];

                    const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                    const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                    const tokenSymbol = await tokenCONTRACT.symbol();

                    console.log('ðŸ¦ CONTRACT balance of', tokenSymbol + ':', ethers.utils.formatEther(CONTRACTTokenBalance));

                    if (CONTRACTTokenBalance.eq(0)) {
                        showStatus('No tokens stuck in CONTRACT to rescue', 'info');
                        return;
                    }

                    // Method 1: collectFees with tokenId
                    showStatus('Method 1: Collecting LP fees for token...', 'info');
                    try {
                        const collectTx = await CONTRACT.collectFees(tokenId);
                        console.log('â³ CollectFees transaction sent:', collectTx.hash);

                        const collectReceipt = await collectTx.wait();
                        console.log('âœ… CollectFees confirmed:', collectReceipt.transactionHash);

                        showStatus('âœ… LP fees collected successfully! Check your balances.', 'success');
                        await checkPlatformFees();
                        return;

                    } catch (collectError) {
                        console.log('âŒ collectFees failed:', collectError.message);
                    }

                    // Method 2: rescueAndSellStuckTokens
                    showStatus('Method 2: Using rescue function...', 'info');
                    try {
                        const rescueTx = await CONTRACT.rescueAndSellStuckTokens([tokenAddress]);
                        console.log('â³ Rescue transaction sent:', rescueTx.hash);

                        const rescueReceipt = await rescueTx.wait();
                        console.log('âœ… Rescue confirmed:', rescueReceipt.transactionHash);

                        showStatus('âœ… Tokens rescued and converted to ETH!', 'success');
                        await checkPlatformFees();
                        return;

                    } catch (rescueError) {
                        console.log('âŒ rescueAndSellStuckTokens failed:', rescueError.message);
                    }

                    showStatus('âŒ All rescue methods failed. Tokens may need manual intervention.', 'error');

                } catch (error) {
                    console.error('Comprehensive rescue error:', error);
                    showStatus('âŒ Rescue failed: ' + error.message, 'error');
                }
            }

            // Check if token is in dev buy window (removed - function doesn't exist in deployed CONTRACT)
            async function checkDevBuyWindow(tokenAddress) {
                try {
                    // These functions are not available in the deployed CONTRACT
                    console.log('Anti-sniper functions not available in deployed CONTRACT');
                    return { inWindow: false, remainingTime: 0 };
                } catch (error) {
                    console.error('Dev buy window check error:', error.message);
                    return { inWindow: false, remainingTime: 0 };
                }
            }

            // Helper function to format small ETH amounts properly
            function formatSmallETHAmount(ethAmount) {
                const num = parseFloat(ethAmount);
                const usdAmount = num * currentETHPrice;

                let ethDisplay = "";
                if (num === 0) {
                    ethDisplay = "0.0000 ETH";
                } else if (num > 0 && num < 0.000001) {
                    ethDisplay = num.toExponential(6) + " ETH";
                } else if (num > 0 && num < 0.0001) {
                    ethDisplay = num.toFixed(12) + " ETH";
                } else {
                    ethDisplay = num.toFixed(6) + " ETH";
                }

                // Add USD amount
                if (num === 0) {
                    return ethDisplay + " ($0.00)";
                } else if (usdAmount < 0.01) {
                    return ethDisplay + " (<$0.01)";
                } else {
                    return ethDisplay + " ($" + usdAmount.toFixed(2) + ")";
                }
            }

            // Helper function to check claimable token amounts
            async function checkClaimableTokenAmounts() {
                if (!CONTRACT || !userAddress) return;

                try {
                    const tokenAmountsList = document.getElementById('tokenAmountsList');
                    const claimableSection = document.getElementById('claimableTokenAmounts');

                    if (!tokenAmountsList || !claimableSection) return;

                    // Get user's created tokens
                    const tokens = [];
                    let tokenIndex = 0;
                    let maxAttempts = 50;

                    while (tokenIndex < maxAttempts) {
                        try {
                            const tokenInfo = await CONTRACT.createdTokens(userAddress, tokenIndex);
                            if (tokenInfo[0] && tokenInfo[0] !== '0x0000000000000000000000000000000000000000') {
                                tokens.push({
                                    address: tokenInfo[0],
                                    name: tokenInfo[2] || 'Unknown Token',
                                    tokenId: tokenInfo[4]
                                });
                                tokenIndex++;
                            } else {
                                break;
                            }
                        } catch (e) {
                            break;
                        }
                    }

                    if (tokens.length === 0) {
                        claimableSection.style.display = 'none';
                        return;
                    }

                    // Check each token for claimable amounts
                    let hasClaimableTokens = false;
                    let tokenAmountsHTML = '';

                    for (const token of tokens) {
                        try {
                            // Try to simulate batchSwapTokenFees to see if there are claimable amounts
                            const canClaim = await CONTRACT.callStatic.batchSwapTokenFees(userAddress, token.address)
                                .then(() => true)
                                .catch(() => false);

                            if (canClaim) {
                                tokenAmountsHTML += `
                                <div style="margin-bottom: 4px; padding: 4px 8px; background: #e6fffa; border-radius: 4px; border: 1px solid #81e6d9;">
                                    <span style="font-weight: 600;">${token.name}</span>
                                    <span style="color: #2c7a7b; font-size: 0.65rem; margin-left: 4px;">â€¢ Has claimable tokens</span>
                                </div>
                            `;
                                hasClaimableTokens = true;
                            }
                        } catch (e) {
                            // Ignore errors for individual tokens
                        }
                    }

                    if (hasClaimableTokens) {
                        tokenAmountsList.innerHTML = tokenAmountsHTML;
                        claimableSection.style.display = 'block';
                    } else {
                        claimableSection.style.display = 'none';
                    }

                } catch (error) {
                    console.log('Error checking claimable token amounts:', error.message);
                    document.getElementById('claimableTokenAmounts').style.display = 'none';
                }
            }

            // Helper function to update all fee displays
            function updateAllFeeDisplays(creatorFeesETH, platformFeesETH, totalLifetimeETH = "0", userLifetimeETH = "0") {
                console.log("ðŸ”„ Updating all fee displays...");

                // Update creator fees main display with lifetime total in parentheses
                const creatorFeesElement = document.getElementById('creatorFees');
                if (creatorFeesElement) {
                    const formattedCreator = formatSmallETHAmount(creatorFeesETH);
                    const formattedLifetime = formatSmallETHAmount(userLifetimeETH);

                    // Show withdrawable + lifetime total
                    if (parseFloat(userLifetimeETH) > 0) {
                        creatorFeesElement.innerHTML = `${formattedCreator}<br><small style="color:#666;">Lifetime: ${formattedLifetime}</small>`;
                    } else {
                        creatorFeesElement.textContent = formattedCreator;
                    }
                    console.log("âœ… Updated creatorFees:", formattedCreator, "| Lifetime:", formattedLifetime);
                }

                // Update withdrawable creator fees
                const withdrawableElement = document.getElementById('withdrawableCreatorFees');
                if (withdrawableElement) {
                    const formattedWithdrawable = formatSmallETHAmount(creatorFeesETH);
                    withdrawableElement.textContent = formattedWithdrawable; // Show full amount with USD
                    console.log("âœ… Updated withdrawableCreatorFees:", formattedWithdrawable);
                }

                // Update Creator Dashboard card title - keep it simple
                const dashboardTitle = document.getElementById('creatorDashboardTitle');
                if (dashboardTitle) {
                    dashboardTitle.textContent = 'Creator Dashboard';
                }

                // Update platform fees with lifetime total
                const platformFeesElement = document.getElementById('platformFeesAmount');
                if (platformFeesElement) {
                    const formattedPlatform = formatSmallETHAmount(platformFeesETH);
                    const formattedTotalLifetime = formatSmallETHAmount(totalLifetimeETH);

                    // Show withdrawable + lifetime total for platform
                    if (parseFloat(totalLifetimeETH) > 0) {
                        const platformLifetime = (parseFloat(totalLifetimeETH) * 0.5).toFixed(12); // Platform gets 50%
                        const formattedPlatformLifetime = formatSmallETHAmount(platformLifetime.toString());
                        platformFeesElement.innerHTML = `${formattedPlatform}<br><small style="color:#666;">Lifetime: ${formattedPlatformLifetime}</small>`;
                    } else {
                        platformFeesElement.textContent = formattedPlatform;
                    }
                    console.log("âœ… Updated platformFeesAmount:", formattedPlatform, "| Total lifetime:", formattedTotalLifetime);
                }

                // Check for claimable token amounts
                checkClaimableTokenAmounts().catch(e => console.log('Error checking tokens:', e.message));
            }



            // Function to withdraw all accumulated creator fees
            async function withdrawCreatorFees() {
                console.log('ðŸ’° Withdrawing all creator fees...');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    showStatus('Preparing ETH withdrawal...', 'info');

                    // First check how much the creator can withdraw
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log('ðŸ’° Creator fees to withdraw:', ethers.utils.formatEther(creatorFees), 'ETH');

                    if (creatorFees.eq(0)) {
                        showStatus('No ETH fees available for withdrawal', 'info');
                        return;
                    }

                    // Call the CONTRACT function to withdraw creator fees
                    const tx = await CONTRACT.withdrawCreatorFees();
                    console.log('â³ Withdraw transaction sent:', tx.hash);
                    showStatus(`Processing withdrawal of ${ethers.utils.formatEther(creatorFees)} ETH...`, 'info');

                    const receipt = await tx.wait();
                    console.log('âœ… Withdraw confirmed:', receipt.transactionHash);

                    // Parse the receipt for events
                    if (receipt.logs && receipt.logs.length > 0) {
                        console.log('ðŸ“‹ Withdrawal completed with', receipt.logs.length, 'events');

                        // Look for CreatorWithdraw event
                        const withdrawnAmount = ethers.utils.formatEther(creatorFees);
                        showStatus(`Successfully withdrew ${withdrawnAmount} ETH to your wallet!`, 'success');
                    } else {
                        showStatus('Withdrawal completed successfully!', 'success');
                    }

                    // Refresh fee displays after withdrawal
                    await checkPlatformFees();

                } catch (error) {
                    console.error('âŒ Withdraw error:', error);
                    if (error.message.includes('insufficient')) {
                        showStatus('Insufficient balance to complete withdrawal', 'error');
                    } else if (error.message.includes('denied')) {
                        showStatus('Transaction cancelled by user', 'error');
                    } else if (error.message.includes('gas')) {
                        showStatus('Transaction failed due to network issues', 'error');
                    } else {
                        showStatus('Withdrawal failed: ' + error.message, 'error');
                    }
                }
            }

            async function checkPlatformFees() {
                console.log("ðŸ”„ checkPlatformFees() called");
                try {
                    if (!provider || !CONTRACT) {
                        console.error("âŒ Provider or CONTRACT not available");
                        alert("Please connect your wallet first!");
                        return null;
                    }

                    console.log("ðŸ“ž Calling CONTRACT functions...");
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalTokenCount = await CONTRACT.getTokenCount();

                    // Get all tokens by iterating through the allTokens array
                    const allTokens = [];
                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            allTokens.push(tokenInfo);
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break; // Stop if we hit an error
                        }
                    }
                    let totalLifetimeFees = ethers.BigNumber.from("0");
                    let userLifetimeFees = ethers.BigNumber.from("0");

                    if (allTokens && allTokens.length > 0) {
                        const currentUser = await signer.getAddress();

                        for (const token of allTokens) {
                            const tokenTotalFees = ethers.BigNumber.from(token.totalFeesETH || "0");
                            totalLifetimeFees = totalLifetimeFees.add(tokenTotalFees);

                            // If this user created this token, add to their lifetime total
                            if (token.creator && token.creator.toLowerCase() === currentUser.toLowerCase()) {
                                // Creator gets 50% of total fees (PLATFORM_SHARE = 50%)
                                const creatorPortion = tokenTotalFees.mul(50).div(100);
                                userLifetimeFees = userLifetimeFees.add(creatorPortion);
                            }
                        }
                    }

                    // Also get current withdrawable creator fees
                    let creatorFees;
                    try {
                        const userAddress = await signer.getAddress();
                        creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    } catch (e) {
                        console.log("âš ï¸ Could not get creator fees:", e.message);
                        creatorFees = ethers.utils.parseEther("0");
                    }

                    console.log("ðŸ“Š Raw platform fees (withdrawable):", platformFees.toString());
                    console.log("ðŸ“Š Raw creator fees (withdrawable):", creatorFees.toString());
                    console.log("ðŸ“Š Total lifetime fees collected:", ethers.utils.formatEther(totalLifetimeFees));
                    console.log("ðŸ“Š User lifetime fees earned:", ethers.utils.formatEther(userLifetimeFees));
                    console.log("ðŸ“Š Token count:", totalTokenCount.toString());

                    // Format fees using ethers
                    const platformFeesFormatted = ethers.utils.formatEther(platformFees);
                    const creatorFeesFormatted = ethers.utils.formatEther(creatorFees);
                    const totalLifetimeFormatted = ethers.utils.formatEther(totalLifetimeFees);
                    const userLifetimeFormatted = ethers.utils.formatEther(userLifetimeFees);

                    console.log("ï¿½ Formatted platform fees:", platformFeesFormatted);
                    console.log("ðŸ“Š Formatted creator fees:", creatorFeesFormatted);

                    // Update all fee displays with proper formatting
                    updateAllFeeDisplays(creatorFeesFormatted, platformFeesFormatted, totalLifetimeFormatted, userLifetimeFormatted);

                    // Status messages
                    if (platformFees.eq(0) && creatorFees.eq(0)) {
                        if (totalLifetimeFees.gt(0)) {
                            console.log("âœ… Lifetime fees were collected and withdrawn!");
                            console.log("   Total fees ever collected:", formatSmallETHAmount(totalLifetimeFormatted));
                            console.log("   Platform lifetime earnings:", formatSmallETHAmount((parseFloat(totalLifetimeFormatted) * 0.5).toFixed(12)));
                            console.log("   Your lifetime earnings:", formatSmallETHAmount(userLifetimeFormatted));
                            console.log("   Current withdrawable: 0 ETH (already withdrawn)");

                            // Remove distracting lifetime fee notifications
                            // showStatus(`âœ… Lifetime fees collected: ${formatSmallETHAmount(totalLifetimeFormatted)} | Your share: ${formatSmallETHAmount(userLifetimeFormatted)}`, 'success');
                        } else {
                            console.log("ðŸ’¡ No fees collected yet. This means:");
                            console.log("   - No one has traded your tokens yet");
                            console.log("   - Or you need to call collectFees() first");
                            console.log("   - Try the 'Collect All Fees' button");
                            // showStatus('No fees collected yet - tokens may not have been traded or fees need collection', 'info');
                        }
                    } else {
                        console.log("âœ… Fees available!");
                        console.log("   Platform fees:", formatSmallETHAmount(platformFeesFormatted));
                        console.log("   Creator fees:", formatSmallETHAmount(creatorFeesFormatted));
                        console.log("ðŸ’¡ Click withdraw buttons to claim them!");

                        // Remove distracting platform fee notifications
                        // if (parseFloat(platformFeesFormatted) > 0) {
                        //     showStatus(`âœ… Platform fees ready for withdrawal: ${formatSmallETHAmount(platformFeesFormatted)}`, 'success');
                        // }
                    }

                    return {
                        platformFees: formatSmallETHAmount(platformFeesFormatted),
                        creatorFees: formatSmallETHAmount(creatorFeesFormatted),
                        tokenCount: totalTokenCount.toString()
                    };

                } catch (error) {
                    console.error("âŒ Error checking platform fees:", error);
                    alert("Error checking fees: " + error.message);
                    return null;
                }
            }

            async function collectAllTokenFees() {
                console.log("ðŸ”„ collectAllTokenFees() called");
                try {
                    if (!signer) {
                        console.error("âŒ No signer available");
                        alert("Please connect your wallet first!");
                        return;
                    }

                    console.log("ï¿½ Starting fee collection process...");

                    // Use getUserTokens helper instead of getCreatedTokens to avoid ABI issues
                    const userAddress = await signer.getAddress();
                    console.log("ðŸ‘¤ User address:", userAddress);

                    console.log("ðŸ“ž Calling getUserTokens()...");
                    const userTokens = await getUserTokens(userAddress);

                    console.log("ðŸ“Š Found", userTokens.length, "tokens created by you");

                    if (userTokens.length === 0) {
                        alert("No tokens found for your address");
                        return;
                    }

                    let successCount = 0;
                    let errorCount = 0;
                    let totalCollected = ethers.utils.parseEther("0");

                    for (let i = 0; i < userTokens.length; i++) {
                        try {
                            const tokenInfo = userTokens[i];
                            const tokenId = tokenInfo.tokenId;

                            console.log(`ðŸ“Š Token ${i}: ${tokenInfo.name} (${tokenInfo.symbol})`);
                            console.log(`ðŸŽ¯ Attempting to collect fees for tokenId: ${tokenId.toString()}`);

                            // Check platform fees before collection
                            const platformFeesBefore = await CONTRACT.getPlatformFees();
                            console.log("ðŸ’° Platform fees before:", ethers.utils.formatEther(platformFeesBefore));

                            console.log("ðŸš€ Calling CONTRACTWithSigner.collectFees()...");
                            const tx = await CONTRACTWithSigner.collectFees(tokenId);
                            console.log("âœ… Transaction sent:", tx.hash);

                            console.log("â³ Waiting for confirmation...");
                            const receipt = await tx.wait();
                            console.log("âœ… Transaction confirmed in block:", receipt.blockNumber);

                            // Check platform fees after collection
                            const platformFeesAfter = await CONTRACT.getPlatformFees();
                            console.log("ðŸ’° Platform fees after:", ethers.utils.formatEther(platformFeesAfter));

                            const collected = platformFeesAfter.sub(platformFeesBefore);

                            if (collected.gt(0)) {
                                const collectedFormatted = ethers.utils.formatEther(collected);
                                console.log(`âœ… Collected ${collectedFormatted} ETH in fees for token ${i}`);
                                totalCollected = totalCollected.add(collected);
                                successCount++;
                            } else {
                                console.log(`ðŸ“­ No fees available for token ${i} yet`);
                            }

                        } catch (error) {
                            console.log(`âš ï¸ Could not collect fees for token ${i}:`, error.message);
                            errorCount++;

                            if (error.message.includes("No fees") || error.message.includes("amount is 0")) {
                                console.log("ðŸ’¡ No fees available for this token yet");
                            } else if (error.message.includes("execution reverted")) {
                                console.log("ðŸ’¡ Transaction reverted - likely no fees to collect");
                            }
                        }
                    }

                    // Show results
                    if (successCount > 0) {
                        const totalFormatted = ethers.utils.formatEther(totalCollected);
                        const message = `âœ… Successfully collected ${totalFormatted} ETH in platform fees from ${successCount} token(s)!`;
                        console.log(message);
                        alert(message);
                    } else {
                        const message = `ðŸ“­ No fees available to collect from ${userTokens.length} token(s). Either no trading has occurred yet or fees are below the minimum threshold.`;
                        console.log(message);
                        alert(message);
                    }

                    // Refresh the display
                    console.log("ðŸ”„ Refreshing platform fees display...");
                    await checkPlatformFees();

                } catch (error) {
                    console.error("âŒ Error collecting fees:", error);
                    alert("Error collecting fees: " + error.message);
                }
            }

            async function withdrawPlatformFees() {
                try {
                    if (!signer) {
                        throw new Error("Please connect your wallet first");
                    }

                    console.log("Withdrawing platform fees...");
                    const tx = await CONTRACTWithSigner.withdrawPlatformFees();
                    await tx.wait();

                    console.log("âœ… Platform fees withdrawn!");
                    alert("Platform fees withdrawn successfully!");

                    // Refresh the display
                    await checkPlatformFees();

                } catch (error) {
                    console.error("Error withdrawing platform fees:", error);
                    alert("Error withdrawing platform fees: " + error.message);
                }
            }

            // Enhanced loadUserTokens with anti-sniper status
            async function loadUserTokensEnhanced(loadMore = false) {
                const list = document.getElementById('myTokensList');
                if (!list) return;
                if (!userAddress) {
                    list.textContent = 'Connect wallet to load your tokens...';
                    return;
                }

                if (!loadMore) userTokensPage = 0;

                try {
                    if (!loadMore) list.textContent = 'Loading your tokens...';
                    console.log('[Dashboard] Loading user tokens with anti-sniper info for', userAddress, 'page', userTokensPage);
                    const allTokens = await getUserTokens(userAddress);
                    console.log('[Dashboard] Total tokens:', allTokens.length);

                    let fees = null;
                    if (capability.creatorFees) {
                        try {
                            console.log('ðŸ’° Fetching creator fees for:', userAddress);
                            fees = await CONTRACT.getCreatorFees(userAddress);
                            const feeAmount = ethers.utils.formatEther(fees);
                            console.log('ðŸ’° Creator fees found:', feeAmount, 'ETH');
                        } catch (e) {
                            if (!capability.suppressedCreatorFeeWarn) {
                                console.warn('[Dashboard] Disabling creator aggregate fee probe after revert.');
                                capability.suppressedCreatorFeeWarn = true;
                            }
                            capability.creatorFees = false;
                            fees = null;
                        }
                    }

                    // Check for accumulated token balances
                    let tokenBalance = null;
                    try {
                        tokenBalance = await CONTRACT.getCreatorTokenBalance(userAddress);
                    } catch (e) {
                        console.log('Could not check token balance:', e.message);
                    }

                    const wd = document.getElementById('withdrawableCreatorFees');
                    if (wd) wd.textContent = fees ? fmt(fees) : '0.000000';
                    const withdrawBtn = document.getElementById('withdrawMyFeesBtn');
                    if (withdrawBtn) withdrawBtn.disabled = !fees || fees.eq(0);
                    const collectBtn = document.getElementById('collectMyFeesBtn');
                    if (collectBtn) collectBtn.disabled = allTokens.length === 0;

                    if (allTokens.length === 0) {
                        list.textContent = 'You have not launched any tokens yet.';
                        return;
                    }

                    // Pagination logic
                    const startIdx = userTokensPage * TOKENS_PER_PAGE;
                    const endIdx = startIdx + TOKENS_PER_PAGE;
                    const tokens = allTokens.slice(startIdx, endIdx);
                    const hasMore = endIdx < allTokens.length;

                    // Generate table rows with anti-sniper status
                    let tableRows = '';
                    for (const t of tokens) {
                        let raw = undefined;
                        if (t.totalFeesETH !== undefined) raw = t.totalFeesETH;
                        if (!raw && Array.isArray(t)) {
                            if (t.length > 9) raw = t[9];
                            else if (t.length > 7) raw = t[7];
                        }
                        const feeETH = fees ? sanitizeFee(raw, fees) : '0.000000';
                        const feeETHNum = parseFloat(feeETH.replace(/ ETH.*$/, ''));
                        const feeUSD = feeETHNum * currentETHPrice;
                        const fee = feeETHNum.toFixed(6) + ' ETH ($' + feeUSD.toFixed(2) + ')';
                        const name = t.name || t[2];
                        const tokenId = t.tokenId || t[4];
                        const tokenAddress = t.tokenAddress || t[0];

                        // Check anti-sniper status
                        let antiSniperStatus = 'Checking...';
                        try {
                            const devStatus = await checkDevBuyWindow(tokenAddress);
                            if (devStatus.inWindow) {
                                const minutes = Math.floor(devStatus.remainingTime / 60);
                                const seconds = devStatus.remainingTime % 60;
                                antiSniperStatus = `<span style="color:orange;">ðŸ›¡ï¸ Dev Window: ${minutes}:${seconds.toString().padStart(2, '0')}</span>`;
                            } else {
                                antiSniperStatus = '<span style="color:green;">ðŸŒ Public Trading</span>';
                            }
                        } catch {
                            antiSniperStatus = '<span style="color:gray;">â“ Unknown</span>';
                        }

                        // Check LP NFT status
                        let lpStatus = 'Checking...';
                        try {
                            const nfpm = new ethers.Contract(POSITION_MANAGER_ADDRESS, ["function ownerOf(uint256) view returns (address)"], provider);
                            const ownerAddr = await nfpm.ownerOf(tokenId);
                            const factoryAddr = TOKEN_FACTORY_ADDRESS.toLowerCase();

                            if (ownerAddr.toLowerCase() === factoryAddr) {
                                lpStatus = '<span style="color:green;">ðŸ”’ Locked</span>';
                            } else if (ownerAddr.toLowerCase() === userAddress.toLowerCase()) {
                                lpStatus = '<span style="color:red;">âš ï¸ In Wallet</span>';
                            } else {
                                lpStatus = '<span style="color:orange;">ðŸ‘¤ Other</span>';
                            }
                        } catch {
                            lpStatus = '<span style="color:gray;">â“ Unknown</span>';
                        }

                        tableRows += `<tr><td>${name}</td><td><a href="https://basescan.org/token/${tokenAddress}" target="_blank" style="color:#667eea;text-decoration:none;">${tokenAddress.slice(0, 10)}...${tokenAddress.slice(-8)}</a></td><td style="text-align:right;font-weight:600;">${fee}</td><td style="text-align:center;">${antiSniperStatus}</td><td style="text-align:center;">${lpStatus}</td></tr>`;
                    }

                    if (!loadMore) {
                        // Initial load - create full table
                        let html = '<div class="table-container"><table>';
                        html += '<thead><tr><th>Name</th><th>Token Address</th><th>Fees (ETH)</th><th>Trading Status</th><th>LP Status</th></tr></thead>';
                        html += '<tbody>' + tableRows + '</tbody>';
                        html += '</table></div>';

                        // Add token balance info if any
                        if (tokenBalance && tokenBalance.gt(0)) {
                            html += `<div style="margin-top:12px;padding:8px;background:#e3f2fd;border-radius:6px;font-size:0.8rem;">
                            ðŸ’° Accumulated Token Fees: ${ethers.utils.formatEther(tokenBalance)} tokens
                            <button onclick="batchSwapTokens()" style="margin-left:8px;padding:2px 6px;font-size:0.7rem;background:#2196f3;color:white;border:none;border-radius:3px;cursor:pointer;">Swap to ETH</button>
                        </div>`;
                        }

                        if (hasMore) {
                            html += `<div style="display:flex;justify-content:center;margin-top:12px;"><button onclick="loadMoreUserTokens()" class="btn btn-secondary">Load More (${allTokens.length - endIdx} remaining)</button></div>`;
                        }

                        list.innerHTML = html;
                    } else {
                        // Load more - append rows to existing table
                        const tbody = list.querySelector('table tbody');
                        if (tbody) {
                            tbody.insertAdjacentHTML('beforeend', tableRows);
                        }

                        // Update load more button
                        const loadMoreBtn = list.querySelector('button');
                        if (loadMoreBtn) {
                            if (hasMore) {
                                loadMoreBtn.textContent = `Load More (${allTokens.length - endIdx} remaining)`;
                            } else {
                                loadMoreBtn.remove();
                            }
                        }
                    }

                    if (!loadMore) {
                        userTokensPage = 1; // Set to 1 after first load
                    } else {
                        userTokensPage++; // Increment only for load more
                    }
                } catch (err) {
                    list.textContent = 'Failed to load';
                    console.error(err);
                }
            }

            // Override the original loadUserTokens with the enhanced version
            loadUserTokens = loadUserTokensEnhanced;
        </script>


        <!--======= HERO SECTION ===========
        ====================================
        =================================-->

        <section class="utility-hero">
            <div class="utility-hero__bg" aria-hidden="true"></div>
            <div class="utility-hero-content">
              <h1>TOKEN FURNACE</h1>
              <p>Permanantly burn tokens to a dead wallet</p>
            </div>
          </section>


        <!-- JavaScript for Parallax effect-->

        <script>
            (function () {
                const bg = document.querySelector('.utility-hero__bg');
                if (!bg) return;

                const speed = 0.6; // lower = subtler effect
                const reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

                if (reduce) return; // skip for reduced motion users

                let ticking = false;

                function onScroll() {
                    if (!ticking) {
                        requestAnimationFrame(() => {
                            const y = window.scrollY * speed;
                            bg.style.transform = `translateY(${y}px)`;
                            ticking = false;
                        });
                        ticking = true;
                    }
                }

                window.addEventListener('scroll', onScroll, { passive: true });
                onScroll();
            })();
        </script>
        
  <div class="burn-container fire-border">
      <div class="burn-title fire-reflection">Burn Any Token</div>
      <div class="burn-warning-container" style="background: #000000 !important; border: 6px solid #ff0000 !important; border-radius: 10px !important; padding: 20px !important; margin: 20px 0 !important; box-shadow: 0 0 50px #ff0000, 0 0 30px #ffae00 !important;">
        <div class="burn-warning" style="animation: none !important; transition: none !important; opacity: 1 !important; font-size: 1.5em !important; font-weight: 900 !important; color: #ffffff !important; text-align: center !important;">âš ï¸ WARNING: This will send your tokens to a dead wallet. <b style="color: #ff0000 !important; font-weight: 900 !important; font-size: 1.3em !important; text-shadow: 3px 3px 6px #000000, -2px -2px 4px #000000, 2px -2px 4px #000000, -2px 2px 4px #000000, 0 0 20px #ff0000 !important; text-transform: uppercase !important;">IRREVERSIBLE!</b> âš ï¸</div>
      </div>
      <form class="burn-form" id="burnForm" autocomplete="off">
        <div class="input-icon-group">
          <input type="text" id="tokenAddress" placeholder="Token Address (BASE or SOLANA)" required spellcheck="false" autocapitalize="off" autocomplete="off">
          <small id="addressValidation" style="position: absolute; top: 100%; left: 0; font-size: 0.8em; margin-top: 4px; display: none;"></small>
        </div>
        <div class="input-icon-group" style="position:relative;display:flex;align-items:center;gap:8px;">
          <input type="number" id="tokenAmount" placeholder="Amount to Burn" min="0" step="any" required spellcheck="false" autocapitalize="off" autocomplete="off" style="flex:1;">
          <button type="button" id="burnAllBtn" title="Burn All" style="background:linear-gradient(90deg,#ffae00 0%,#ff1a1a 100%);color:#fffbe7;border:2px solid #ffae00;border-radius:8px;padding:8px 14px;font-size:1em;font-weight:900;box-shadow:0 0 8px #ffae00,0 0 4px #ff1a1a;cursor:pointer;text-transform:uppercase;font-family:'Bangers','Ewert','Orbitron',cursive,sans-serif;letter-spacing:2.5px;transition:background 0.2s,box-shadow 0.2s;">Burn All</button>
        </div>
        <div class="burn-balance" title="Your token balance">
          <span id="tokenBalance"></span>
        </div>
        <div id="accountMismatchWarning" style="display: none; background: #2a0a0a; border: 2px solid #ff6b6b; border-radius: 8px; padding: 12px; margin: 8px 0; text-align: center;">
          <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 8px;">âš ï¸ Account Mismatch Detected</div>
          <div style="color: #ffae00; font-size: 0.9em; margin-bottom: 8px;">
            Tokens are in a different MetaMask account than currently selected
          </div>
          <button type="button" id="checkAccountBtn" style="background: linear-gradient(90deg, #ff6b6b 0%, #ffae00 100%); color: #fff; border: 1px solid #ff6b6b; border-radius: 6px; padding: 6px 12px; font-size: 0.9em; font-weight: 600; cursor: pointer; transition: all 0.2s;">
            Check MetaMask Accounts
          </button>
        </div>
        <button type="submit" class="burn-btn fire-btn" id="burnBtn">
          Burn Token
        </button>
        <div class="burn-success" id="burnSuccess" style="display:none;"></div>
      </form>
    </div>
    <!-- Dramatic ember particles -->
    <!-- Load Ethers.js for Web3 functionality -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <!-- Load Solana Web3.js for Solana functionality -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <!-- Load BN.js for large number handling -->
    <script src="https://cdn.jsdelivr.net/npm/bn.js@5.2.1/lib/bn.min.js"></script>
    
    <!-- Mark that we're handling the wallet button ourselves -->
    <script>
      window.TOKEN_FURNACE_HANDLES_WALLET_BUTTON = true;
    </script>
    
    <!-- Load multi-wallet management -->
    <script src="../js/multi-wallet-manager.js"></script>
    <!-- Load wallet functionality -->
    <script src="../js/wallet.js"></script>
    <!-- Unified wallet connection system (fixes all connection issues) -->
    <script src="../js/unified-wallet-connection.js"></script>
    <script>
      // Performance optimized ember system for wallet browsers
      function isMobileDevice() {
        return window.innerWidth <= 800 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      }

      function isWalletBrowser() {
        return /MetaMask|Trust|Coinbase|Rainbow|WalletConnect|Phantom/i.test(navigator.userAgent) || 
               window.ethereum || window.solana;
      }

      let emberInterval = null;
      let activeEmbers = [];
      const MAX_EMBERS = isMobileDevice() ? 0 : (isWalletBrowser() ? 3 : 6); // No embers on mobile, fewer in wallet browsers

      function randomColor() {
        const colors = [
          'rgba(255, 174, 0, 0.85)', // yellow
          'rgba(255, 69, 0, 0.85)',  // orange-red
          'rgba(255, 26, 26, 0.85)', // red
          'rgba(255, 140, 0, 0.85)', // orange
          'rgba(255, 215, 0, 0.85)'  // gold
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      function createEmber() {
        // Skip if mobile or too many embers active
        if (isMobileDevice() || activeEmbers.length >= MAX_EMBERS) {
          return;
        }

        const ember = document.createElement('div');
        const size = Math.random() * 14 + 6;
        const left = Math.random() * 100;
        const opacity = Math.random() * 0.4 + 0.3;
        const duration = Math.random() * 2000 + 3000; // 3-5 seconds (reduced from 3.5-6s)
        const color = randomColor();
        const blur = Math.random() * 2 + 1; // Reduced blur for performance
        const sway = Math.random() * 25 + 10;
        
        // Use CSS animations instead of requestAnimationFrame for better performance
        ember.style.cssText = `
          width: ${size}px;
          height: ${size}px;
          position: fixed;
          left: ${left}vw;
          bottom: -40px;
          opacity: 0;
          pointer-events: none;
          z-index: 9999;
          border-radius: 50%;
          background: radial-gradient(circle, ${color} 0%, #ff1a1a 60%, transparent 100%);
          filter: blur(${blur}px) brightness(1.2);
          transform: translateZ(0); /* Hardware acceleration */
          transition: transform ${duration}ms linear, opacity ${duration}ms ease-in-out;
        `;
        
        activeEmbers.push(ember);
        document.body.appendChild(ember);
        
        // Start animation with CSS transitions
        requestAnimationFrame(() => {
          const yDistance = window.innerHeight + 80;
          const xOffset = Math.sin(Date.now() * 0.001) * sway;
          ember.style.transform = `translate(${xOffset}px, -${yDistance}px) translateZ(0)`;
          ember.style.opacity = opacity;
        });
        
        // Clean up ember after animation completes
        setTimeout(() => {
          if (ember.parentNode) {
            ember.remove();
          }
          const index = activeEmbers.indexOf(ember);
          if (index > -1) {
            activeEmbers.splice(index, 1);
          }
        }, duration + 100);
      }
      
      function startEmberSystem() {
        if (emberInterval || isMobileDevice()) return;
        
        // Reduced frequency for wallet browsers
        const frequency = isWalletBrowser() ? 600 : 350; // Less frequent in wallet browsers
        emberInterval = setInterval(createEmber, frequency);
      }

      function stopEmberSystem() {
        if (emberInterval) {
          clearInterval(emberInterval);
          emberInterval = null;
        }
        // Clean up all active embers
        activeEmbers.forEach(ember => {
          if (ember.parentNode) {
            ember.remove();
          }
        });
        activeEmbers = [];
      }

      // Only start if not on mobile
      if (!isMobileDevice()) {
        startEmberSystem();
      }

      // Pause animations when page becomes hidden to save battery/performance
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          stopEmberSystem();
        } else if (!isMobileDevice()) {
          startEmberSystem();
        }
      });

      // Clean up on page unload
      window.addEventListener('beforeunload', stopEmberSystem);
    </script>
    <!-- --- Wallet Connect Logic --- -->
    <script>
// --- CONFIG: QuickNode Endpoints (Using exact working token lock pattern) ---
let SOLANA_RPC = 'https://api.mainnet-beta.solana.com'; // Default fallback
let BASE_RPC = 'https://mainnet.base.org'; // Default fallback

// Use the exact same RPC initialization pattern as working token lock pages
function initializeRPCEndpoints() {
  console.log('ðŸ”§ Initializing RPC endpoints...');
  
  // Initialize Solana RPC (same pattern as base-locking.html)
  try {
    if (window.RPC_CONFIG) {
      SOLANA_RPC = window.RPC_CONFIG.getSolanaEndpoint();
      console.log('âœ… Using QuickNode Solana endpoint');
    }
  } catch (error) {
    console.log('âš ï¸ QuickNode Solana not available, using fallback');
    SOLANA_RPC = 'https://api.mainnet-beta.solana.com';
  }
  
  // Initialize Base RPC (same pattern as base-locking.html)  
  try {
    if (window.RPC_CONFIG) {
      BASE_RPC = window.RPC_CONFIG.getBaseEndpoint();
      console.log('âœ… Using QuickNode Base endpoint');
    }
  } catch (error) {
    console.log('âš ï¸ QuickNode Base not available, using fallback');
    BASE_RPC = 'https://mainnet.base.org';
  }
  
  console.log('ðŸ”„ Final RPC endpoints:', { SOLANA_RPC, BASE_RPC });
}console.log('ðŸ”§ RPC Configuration loaded:', {
  SOLANA_RPC,
  BASE_RPC,
  hasRPCConfig: !!window.RPC_CONFIG,
  hasProductionConfig: !!window.PRODUCTION_CONFIG,
  userAgent: navigator.userAgent,
  productionRPC: {
    solana: window.PRODUCTION_CONFIG?.rpc?.solana,
    base: window.PRODUCTION_CONFIG?.rpc?.base
  }
});

// --- GLOBAL STATE ---
let currentChain = null; // 'base' or 'solana'
let currentAddress = null;
let currentProvider = null;
let currentEvmProvider = null;
let currentSolanaProvider = null;
let currentTokenDecimals = 18; // default for EVM
let currentTokenSymbol = '';
let ethersLoaded = false;
let solanaLoaded = false;
let bnLoaded = false;
let splTokenLoaded = false;

// --- DYNAMIC LIBRARY LOADERS ---
async function loadEthers() {
  if (ethersLoaded) return;
  if (!window.ethers) {
    await new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js';
      s.onload = resolve;
      s.onerror = (e) => {
        showBurnSuccess('Failed to load ethers.js library. Check your internet connection or try again later.', true);
        reject(e);
      };
      document.head.appendChild(s);
    });
  }
  ethersLoaded = true;
}
async function loadSolanaWeb3() {
  if (solanaLoaded) return;
  if (!window.solanaWeb3) {
    await new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.2/lib/index.iife.min.js';
      s.onload = resolve;
      s.onerror = (e) => {
        showBurnSuccess('Failed to load Solana web3.js library. Check your internet connection or try again later.', true);
        reject(e);
      };
      document.head.appendChild(s);
    });
  }
  solanaLoaded = true;
}
async function loadBN() {
  if (bnLoaded) return;
  if (!window.BN) {
    await new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/bn.js@5.2.1/lib/bn.js';
      s.onload = resolve;
      s.onerror = (e) => {
        showBurnSuccess('Failed to load bn.js library. Check your internet connection or try again later.', true);
        reject(e);
      };
      document.head.appendChild(s);
    });
  }
  bnLoaded = true;
}
// --- WRAPPER: Safe dynamic loader usage ---
async function safeLoad(fn) {
  try {
    await fn();
    return true;
  } catch (e) {
    console.error('Library load error:', e);
    return false;
  }
}

// --- TOKEN TYPE DETECTION ---
function detectTokenType(address) {
  if (!address || typeof address !== 'string') {
    return 'invalid';
  }
  
  const trimmedAddress = address.trim();
  
  // Base (EVM) token detection: 0x followed by 40 hex characters
  if (trimmedAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
    return 'base';
  }
  
  // Solana token detection: Base58 string, typically 32-44 characters
  // Solana addresses use Base58 (no 0, O, I, l characters)
  if (trimmedAddress.length >= 32 && trimmedAddress.length <= 44) {
    // Check if it's a valid Base58 string (no 0, O, I, l)
    if (trimmedAddress.match(/^[1-9A-HJ-NP-Za-km-z]+$/)) {
      return 'solana';
    }
  }
  
  return 'invalid';
}

// --- WALLET SELECTION HANDLERS ---
async function handleEvmTokenBurn(tokenAddress, amount) {
  console.log('ðŸ”µ Handling EVM token burn...');
  
  // Check if we already have a connected EVM wallet
  const hasConnectedEvmWallet = (
    // Check wildWestWallet state
    (window.wildWestWallet?.account && (window.wildWestWallet?.currentChain === 'base' || window.wildWestWallet?.currentChain === 'ethereum')) ||
    // Check current connection state
    (currentAddress && (currentChain === 'base' || currentChain === 'ethereum')) ||
    // Check if wallet is connected via ethereum provider
    (window.ethereum?.selectedAddress) ||
    // Check any other EVM wallet connection methods
    (window.ethereum?.isConnected && window.ethereum.isConnected())
  );

  if (hasConnectedEvmWallet) {
    const connectedAddress = window.wildWestWallet?.account || currentAddress || window.ethereum?.selectedAddress;
    console.log('âœ… Using already connected EVM wallet:', connectedAddress);
    
    // Use the specific provider that was used for connection
    let walletProvider = null;
    let walletName = 'EVM Wallet';
    let walletIcon = 'ðŸ’¼';
    
    if (window.wildWestWallet?.provider) {
      walletProvider = window.wildWestWallet.provider;
      walletName = window.wildWestWallet.provider?.isMetaMask ? 'MetaMask' : 'EVM Wallet';
      walletIcon = window.wildWestWallet.provider?.isMetaMask ? 'ðŸ¦Š' : 'ðŸ’¼';
    } else if (currentEvmProvider) {
      walletProvider = currentEvmProvider;
      walletName = currentEvmProvider?.isMetaMask ? 'MetaMask' : 'EVM Wallet';
      walletIcon = currentEvmProvider?.isMetaMask ? 'ðŸ¦Š' : 'ðŸ’¼';
    } else if (currentProvider) {
      walletProvider = currentProvider;
      walletName = currentProvider?.isMetaMask ? 'MetaMask' : 'EVM Wallet';
      walletIcon = currentProvider?.isMetaMask ? 'ðŸ¦Š' : 'ðŸ’¼';
    } else {
      walletProvider = window.ethereum;
      walletName = window.ethereum?.isMetaMask ? 'MetaMask' : 'EVM Wallet';
      walletIcon = window.ethereum?.isMetaMask ? 'ðŸ¦Š' : 'ðŸ’¼';
    }
    
    console.log('ðŸŽ¯ Using wallet provider:', {
      name: walletName,
      isMetaMask: walletProvider?.isMetaMask,
      isCoinbaseWallet: walletProvider?.isCoinbaseWallet
    });
    
    // Create wallet object from current state
    const connectedWallet = {
      name: walletName,
      icon: walletIcon,
      provider: walletProvider,
      type: 'evm'
    };
    await connectAndBurnEvm(connectedWallet, tokenAddress, amount);
    return;
  }
  
  // Detect all available EVM wallets
  const availableEvmWallets = detectAvailableEvmWallets();
  console.log('ðŸ” Available EVM wallets:', availableEvmWallets);
  
  if (availableEvmWallets.length === 0) {
    showBurnSuccess('No EVM wallets detected. Please install MetaMask, Coinbase Wallet, or another EVM wallet.', true);
    return;
  }
  
  // If only one wallet available, use it directly
  if (availableEvmWallets.length === 1) {
    const wallet = availableEvmWallets[0];
    console.log('ðŸŽ¯ Using single available EVM wallet:', wallet.name);
    await connectAndBurnEvm(wallet, tokenAddress, amount);
    return;
  }
  
  // Multiple wallets available - show selection modal
  showEvmWalletSelectionModal(availableEvmWallets, tokenAddress, amount);
}

async function handleSolanaTokenBurn(tokenAddress, amount) {
  console.log('ðŸŸ£ Handling Solana token burn...');
  
  // Check if we already have a connected Solana wallet
  if (currentChain === 'solana' && currentAddress && currentSolanaProvider) {
    console.log('âœ… Using already connected Solana wallet:', currentAddress);
    // Create wallet object from current state
    const connectedWallet = {
      name: currentSolanaProvider.isPhantom ? 'Phantom' : 'Solflare',
      icon: currentSolanaProvider.isPhantom ? 'ðŸ‘»' : 'â˜€ï¸',
      provider: currentSolanaProvider,
      type: 'solana'
    };
    await connectAndBurnSolana(connectedWallet, tokenAddress, amount);
    return;
  }
  
  // Detect all available Solana wallets
  const availableSolanaWallets = detectAvailableSolanaWallets();
  console.log('ðŸ” Available Solana wallets:', availableSolanaWallets);
  
  if (availableSolanaWallets.length === 0) {
    showBurnSuccess('No Solana wallets detected. Please install Phantom, Solflare, or another Solana wallet.', true);
    return;
  }
  
  // If only one wallet available, use it directly
  if (availableSolanaWallets.length === 1) {
    const wallet = availableSolanaWallets[0];
    console.log('ðŸŽ¯ Using single available Solana wallet:', wallet.name);
    await connectAndBurnSolana(wallet, tokenAddress, amount);
    return;
  }
  
  // Multiple wallets available - show selection modal
  showSolanaWalletSelectionModal(availableSolanaWallets, tokenAddress, amount);
}

// --- WALLET DETECTION FUNCTIONS ---
function detectAvailableEvmWallets() {
  const wallets = [];
  
  if (window.ethereum) {
    // Check for multiple providers
    if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
      window.ethereum.providers.forEach((provider, index) => {
        if (provider.isMetaMask && !provider.isPhantom) {
          wallets.push({
            name: 'MetaMask',
            icon: 'ðŸ¦Š',
            provider: provider,
            type: 'metamask'
          });
        } else if (provider.isCoinbaseWallet) {
          wallets.push({
            name: 'Coinbase Wallet',
            icon: 'ðŸ”µ',
            provider: provider,
            type: 'coinbase'
          });
        } else if (provider.isRainbow) {
          wallets.push({
            name: 'Rainbow',
            icon: 'ðŸŒˆ',
            provider: provider,
            type: 'rainbow'
          });
        } else if (provider.isTrust) {
          wallets.push({
            name: 'Trust Wallet',
            icon: 'ðŸ›¡ï¸',
            provider: provider,
            type: 'trust'
          });
        } else if (provider.isPhantom && !provider.isMetaMask) {
          wallets.push({
            name: 'Phantom (EVM)',
            icon: 'ðŸ‘»',
            provider: provider,
            type: 'phantom-evm'
          });
        }
      });
    } else {
      // Single provider
      if (window.ethereum.isMetaMask && !window.ethereum.isPhantom) {
        wallets.push({
          name: 'MetaMask',
          icon: 'ðŸ¦Š',
          provider: window.ethereum,
          type: 'metamask'
        });
      } else if (window.ethereum.isCoinbaseWallet) {
        wallets.push({
          name: 'Coinbase Wallet',
          icon: 'ðŸ”µ',
          provider: window.ethereum,
          type: 'coinbase'
        });
      } else if (window.ethereum.isPhantom) {
        wallets.push({
          name: 'Phantom (EVM)',
          icon: 'ðŸ‘»',
          provider: window.ethereum,
          type: 'phantom-evm'
        });
      } else {
        wallets.push({
          name: 'Unknown EVM Wallet',
          icon: 'ðŸ’¼',
          provider: window.ethereum,
          type: 'unknown'
        });
      }
    }
  }
  
  return wallets;
}

function detectAvailableSolanaWallets() {
  const wallets = [];
  
  // Phantom Solana
  if (window.phantom && window.phantom.solana) {
    wallets.push({
      name: 'Phantom',
      icon: 'ðŸ‘»',
      provider: window.phantom.solana,
      type: 'phantom'
    });
  } else if (window.solana && window.solana.isPhantom) {
    wallets.push({
      name: 'Phantom',
      icon: 'ðŸ‘»',
      provider: window.solana,
      type: 'phantom'
    });
  }
  
  // Solflare
  if (window.solflare && window.solflare.isSolflare) {
    wallets.push({
      name: 'Solflare',
      icon: 'â˜€ï¸',
      provider: window.solflare,
      type: 'solflare'
    });
  }
  
  // Backpack
  if (window.backpack && window.backpack.isSolana) {
    wallets.push({
      name: 'Backpack',
      icon: 'ðŸŽ’',
      provider: window.backpack,
      type: 'backpack'
    });
  }
  
  // Coin98
  if (window.coin98 && window.coin98.sol) {
    wallets.push({
      name: 'Coin98',
      icon: 'ðŸª™',
      provider: window.coin98.sol,
      type: 'coin98'
    });
  }
  
  return wallets;
}

// --- WALLET SELECTION MODALS ---
function showEvmWalletSelectionModal(wallets, tokenAddress, amount) {
  const modal = document.createElement('div');
  modal.className = 'wallet-modal-overlay';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.2s ease-out;
  `;
  
  const walletsHtml = wallets.map(wallet => `
    <button class="wallet-select-btn" data-wallet-type="${wallet.type}" style="
      display: flex;
      align-items: center;
      gap: 1rem;
      width: 100%;
      padding: 1rem;
      margin: 0.5rem 0;
      border: 2px solid #00eaff;
      border-radius: 12px;
      background: rgba(0, 234, 255, 0.1);
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 1.1rem;
    ">
      <span style="font-size: 1.5rem;">${wallet.icon}</span>
      <div style="flex: 1; text-align: left;">
        <div style="font-weight: bold;">${wallet.name}</div>
        <div style="font-size: 0.9rem; color: #ccc;">EVM Compatible</div>
      </div>
      <span style="color: #00eaff;">â†’</span>
    </button>
  `).join('');
  
  modal.innerHTML = `
    <div style="
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 2px solid #00eaff;
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(0, 234, 255, 0.3);
      max-width: 500px;
      width: 90vw;
      overflow: hidden;
    ">
      <div style="
        padding: 1.5rem;
        border-bottom: 1px solid rgba(0, 234, 255, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <div>
          <h3 style="margin: 0; color: #00eaff; font-size: 1.25rem;">Select EVM Wallet</h3>
          <p style="margin: 0.5rem 0 0 0; color: #ccc; font-size: 0.9rem;">Choose your wallet for Base network</p>
        </div>
        <button class="close-modal" style="
          background: none;
          border: none;
          color: #00eaff;
          font-size: 1.5rem;
          cursor: pointer;
        ">Ã—</button>
      </div>
      <div style="padding: 1.5rem;">
        ${walletsHtml}
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Handle wallet selection
  modal.querySelectorAll('.wallet-select-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const walletType = btn.dataset.walletType;
      const selectedWallet = wallets.find(w => w.type === walletType);
      document.body.removeChild(modal);
      
      if (selectedWallet) {
        await connectAndBurnEvm(selectedWallet, tokenAddress, amount);
      }
    });
    
    btn.addEventListener('mouseenter', () => {
      btn.style.background = 'rgba(0, 234, 255, 0.2)';
      btn.style.transform = 'translateY(-2px)';
    });
    
    btn.addEventListener('mouseleave', () => {
      btn.style.background = 'rgba(0, 234, 255, 0.1)';
      btn.style.transform = 'translateY(0)';
    });
  });
  
  // Handle close
  modal.querySelector('.close-modal').addEventListener('click', () => {
    document.body.removeChild(modal);
  });
  
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
}

function showSolanaWalletSelectionModal(wallets, tokenAddress, amount) {
  const modal = document.createElement('div');
  modal.className = 'wallet-modal-overlay';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.2s ease-out;
  `;
  
  const walletsHtml = wallets.map(wallet => `
    <button class="wallet-select-btn" data-wallet-type="${wallet.type}" style="
      display: flex;
      align-items: center;
      gap: 1rem;
      width: 100%;
      padding: 1rem;
      margin: 0.5rem 0;
      border: 2px solid #9945ff;
      border-radius: 12px;
      background: rgba(153, 69, 255, 0.1);
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 1.1rem;
    ">
      <span style="font-size: 1.5rem;">${wallet.icon}</span>
      <div style="flex: 1; text-align: left;">
        <div style="font-weight: bold;">${wallet.name}</div>
        <div style="font-size: 0.9rem; color: #ccc;">Solana Network</div>
      </div>
      <span style="color: #9945ff;">â†’</span>
    </button>
  `).join('');
  
  modal.innerHTML = `
    <div style="
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 2px solid #9945ff;
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(153, 69, 255, 0.3);
      max-width: 500px;
      width: 90vw;
      overflow: hidden;
    ">
      <div style="
        padding: 1.5rem;
        border-bottom: 1px solid rgba(153, 69, 255, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <div>
          <h3 style="margin: 0; color: #9945ff; font-size: 1.25rem;">Select Solana Wallet</h3>
          <p style="margin: 0.5rem 0 0 0; color: #ccc; font-size: 0.9rem;">Choose your wallet for Solana network</p>
        </div>
        <button class="close-modal" style="
          background: none;
          border: none;
          color: #9945ff;
          font-size: 1.5rem;
          cursor: pointer;
        ">Ã—</button>
      </div>
      <div style="padding: 1.5rem;">
        ${walletsHtml}
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Handle wallet selection
  modal.querySelectorAll('.wallet-select-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const walletType = btn.dataset.walletType;
      const selectedWallet = wallets.find(w => w.type === walletType);
      document.body.removeChild(modal);
      
      if (selectedWallet) {
        await connectAndBurnSolana(selectedWallet, tokenAddress, amount);
      }
    });
    
    btn.addEventListener('mouseenter', () => {
      btn.style.background = 'rgba(153, 69, 255, 0.2)';
      btn.style.transform = 'translateY(-2px)';
    });
    
    btn.addEventListener('mouseleave', () => {
      btn.style.background = 'rgba(153, 69, 255, 0.1)';
      btn.style.transform = 'translateY(0)';
    });
  });
  
  // Handle close
  modal.querySelector('.close-modal').addEventListener('click', () => {
    document.body.removeChild(modal);
  });
  
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
}

// --- WALLET CONNECTION AND BURN FUNCTIONS ---
async function connectAndBurnEvm(wallet, tokenAddress, amount) {
  console.log('ðŸ”µ Connecting to EVM wallet:', wallet.name);
  
  try {
    // Set the selected provider
    currentEvmProvider = wallet.provider;
    currentProvider = wallet.provider;
    currentChain = 'base';
    
    // Request connection
    const accounts = await wallet.provider.request({ method: 'eth_requestAccounts' });
    if (accounts && accounts.length > 0) {
      currentAddress = accounts[0];
      console.log('âœ… Connected to', wallet.name, 'with address:', currentAddress);
      
      // Mobile RPC validation after wallet connection
      
      
      updateTokenFurnaceUI();
      showBurnSuccess(`Connected to ${wallet.name}!`, false);
      
      // Proceed with burning
      await burnEvmToken(tokenAddress, amount);
    } else {
      showBurnSuccess('Failed to get account from ' + wallet.name, true);
    }
  } catch (error) {
    console.error('âŒ Failed to connect to', wallet.name, ':', error);
    showBurnSuccess('Failed to connect to ' + wallet.name + ': ' + error.message, true);
  }
}

async function connectAndBurnSolana(wallet, tokenAddress, amount) {
  console.log('ðŸŸ£ Connecting to Solana wallet:', wallet.name);
  
  try {
    // Set the selected provider
    currentSolanaProvider = wallet.provider;
    currentProvider = wallet.provider;
    currentChain = 'solana';
    
    // Request connection
    const resp = await wallet.provider.connect();
    let pubkey = resp && resp.publicKey ? resp.publicKey : (wallet.provider.publicKey ? wallet.provider.publicKey : null);
    if (pubkey && pubkey.toString) pubkey = pubkey.toString();
    
    if (pubkey) {
      currentAddress = pubkey;
      console.log('âœ… Connected to', wallet.name, 'with address:', currentAddress);
      
      // Mobile RPC validation after wallet connection
      
      updateTokenFurnaceUI();
      showBurnSuccess(`Connected to ${wallet.name}!`, false);
      
      // Proceed with burning
      await burnSolanaToken(tokenAddress, amount);
    } else {
      showBurnSuccess('Failed to get public key from ' + wallet.name, true);
    }
  } catch (error) {
    console.error('âŒ Failed to connect to', wallet.name, ':', error);
    showBurnSuccess('Failed to connect to ' + wallet.name + ': ' + error.message, true);
  }
}

// --- WALLET INTEGRATION WITH BOTH BASE AND SOLANA ---
// Use existing global variables, no need to redeclare

// Wait for wallet.js to initialize
document.addEventListener('DOMContentLoaded', function() {
  // Initialize RPC endpoints first
  console.log('ðŸ”§ Initializing RPC endpoints on page load...');
  initializeRPCEndpoints();
  
  // Performance optimization for wallet browsers
  function optimizeForWalletBrowser() {
    const isWalletBrowser = /MetaMask|Trust|Coinbase|Rainbow|WalletConnect|Phantom/i.test(navigator.userAgent) || 
                           window.ethereum || window.solana;
    
    if (isWalletBrowser) {
      console.log('ðŸ”§ Wallet browser detected - applying performance optimizations');
      
      // Reduce CSS animation frequency
      const style = document.createElement('style');
      style.textContent = `
        body::before, body::after {
          animation-duration: 12s !important;
          filter: blur(0.5px) brightness(1.02) !important;
        }
        .header {
          box-shadow: 0 0 24px 6px #ff1a1a55, 0 0 12px #ffae0088 !important;
        }
      `;
      document.head.appendChild(style);
      
      // Limit ember count further if wallet browser
      if (window.MAX_EMBERS) {
        window.MAX_EMBERS = Math.min(window.MAX_EMBERS, 2);
      }
    }
  }
  
  optimizeForWalletBrowser();
  
  // RPC configuration is handled by initial load
  
  // Completely independent wallet connection for Token Furnace
  setupTokenFurnaceWallet();
  
  // Make functions globally accessible for debugging
  window.showChainSelectionModal = showChainSelectionModal;
  window.setupTokenFurnaceWallet = setupTokenFurnaceWallet;
  
  // Define functions immediately
  function showChainSelectionModal() {
    console.log('ðŸš€ showChainSelectionModal called!');
    
    // Detect available wallets
    const availableWallets = {
      ethereum: [],
      solana: []
    };
    
    // Detect Ethereum/Base wallets
    if (window.ethereum) {
      // Check for multiple providers
      const providers = window.ethereum.providers || [window.ethereum];
      
      providers.forEach(provider => {
        if (provider.isMetaMask) {
          availableWallets.ethereum.push({name: 'MetaMask', provider: provider});
        }
        if (provider.isCoinbaseWallet) {
          availableWallets.ethereum.push({name: 'Coinbase Wallet', provider: provider});
        }
        if (provider.isRabby) {
          availableWallets.ethereum.push({name: 'Rabby Wallet', provider: provider});
        }
        if (provider.isTrust) {
          availableWallets.ethereum.push({name: 'Trust Wallet', provider: provider});
        }
      });
      
      // If no specific wallet detected but ethereum exists, add as generic
      if (availableWallets.ethereum.length === 0) {
        availableWallets.ethereum.push({name: 'Ethereum Wallet', provider: window.ethereum});
      }
    }
    
    // Detect Solana wallets - be very specific about providers
    const solanaWallets = [];
    
    // Phantom - check multiple locations
    if (window.phantom?.solana?.isPhantom) {
      solanaWallets.push({name: 'Phantom', provider: window.phantom.solana});
    } else if (window.solana?.isPhantom) {
      solanaWallets.push({name: 'Phantom', provider: window.solana});
    }
    
    // Other Solana wallets
    if (window.solflare && !solanaWallets.find(w => w.name === 'Solflare')) {
      solanaWallets.push({name: 'Solflare', provider: window.solflare});
    }
    if (window.backpack && !solanaWallets.find(w => w.name === 'Backpack')) {
      solanaWallets.push({name: 'Backpack', provider: window.backpack});
    }
    if (window.glow && !solanaWallets.find(w => w.name === 'Glow')) {
      solanaWallets.push({name: 'Glow', provider: window.glow});
    }
    if (window.slope && !solanaWallets.find(w => w.name === 'Slope')) {
      solanaWallets.push({name: 'Slope', provider: window.slope});
    }
    
    availableWallets.solana = solanaWallets;
    
    console.log('ðŸ” Detected wallets:', availableWallets);
    
    // Create modal with consistent styling
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center;
      z-index: 10000; animation: fadeIn 0.2s ease-out;
    `;
    
    // Generate wallet options HTML
    let walletOptionsHTML = '';
    
    if (availableWallets.ethereum.length > 0) {
      walletOptionsHTML += '<h4 style="color: #00eaff; margin: 1rem 0 0.5rem 0; font-size: 1rem;">Base Network (Ethereum)</h4>';
      availableWallets.ethereum.forEach((wallet, index) => {
        walletOptionsHTML += `
          <button onclick="connectSpecificWallet('ethereum', ${index})" style="
            display: block; width: 100%; margin: 8px 0; padding: 12px 16px;
            background: linear-gradient(135deg, #0052ff, #0041cc);
            color: white; border: 1px solid rgba(0, 234, 255, 0.3); border-radius: 8px;
            cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 0.9rem;
            transition: all 0.3s ease; text-align: center;
          " onmouseover="this.style.background='linear-gradient(135deg, #0066ff, #0052ff)'; this.style.borderColor='#00eaff'; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='linear-gradient(135deg, #0052ff, #0041cc)'; this.style.borderColor='rgba(0, 234, 255, 0.3)'; this.style.transform='translateY(0)'">
            Connect ${wallet.name}
          </button>
        `;
      });
    }
    
    if (availableWallets.solana.length > 0) {
      walletOptionsHTML += '<h4 style="color: #00eaff; margin: 1rem 0 0.5rem 0; font-size: 1rem;">Solana Network</h4>';
      availableWallets.solana.forEach((wallet, index) => {
        walletOptionsHTML += `
          <button onclick="connectSpecificWallet('solana', ${index})" style="
            display: block; width: 100%; margin: 8px 0; padding: 12px 16px;
            background: linear-gradient(135deg, #9945ff, #7c3aed);
            color: white; border: 1px solid rgba(0, 234, 255, 0.3); border-radius: 8px;
            cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 0.9rem;
            transition: all 0.3s ease; text-align: center;
          " onmouseover="this.style.background='linear-gradient(135deg, #a855f7, #9945ff)'; this.style.borderColor='#00eaff'; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='linear-gradient(135deg, #9945ff, #7c3aed)'; this.style.borderColor='rgba(0, 234, 255, 0.3)'; this.style.transform='translateY(0)'">
            Connect ${wallet.name}
          </button>
        `;
      });
    }
    
    if (availableWallets.ethereum.length === 0 && availableWallets.solana.length === 0) {
      // Check if user is on mobile
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      walletOptionsHTML = `
        <div style="text-align: center; padding: 2rem; color: #ff6b6b;">
          <h4 style="color: #ff6b6b; margin-bottom: 1rem;">No Wallets Detected</h4>
          ${isMobile ? `
            <div style="
              background: rgba(0, 234, 255, 0.1);
              border: 1px solid #00eaff;
              border-radius: 8px;
              padding: 1rem;
              margin-bottom: 1rem;
              text-align: center;
            ">
              <p style="margin: 0; color: #00eaff; font-weight: 600;">ðŸ“± Mobile User?</p>
              <p style="margin: 0.5rem 0 0 0; color: #c0c0c0; font-size: 0.9rem;">
                Open this site inside your wallet browser (MetaMask, Phantom, etc.) instead of your regular browser.
              </p>
            </div>
          ` : ''}
          <p style="margin-bottom: 1rem; color: #c0c0c0;">Please install a wallet to continue:</p>
          <div style="text-align: left;">
            <p style="margin: 0.5rem 0; color: #c0c0c0;"><a href="https://metamask.io" target="_blank" style="color: #00eaff;">MetaMask</a> (for Base/Ethereum)</p>
            <p style="margin: 0.5rem 0; color: #c0c0c0;"><a href="https://phantom.app" target="_blank" style="color: #00eaff;">Phantom</a> (for Solana + Ethereum)</p>
            <p style="margin: 0.5rem 0; color: #c0c0c0;"><a href="https://wallet.coinbase.com" target="_blank" style="color: #00eaff;">Coinbase Wallet</a> (for Base/Ethereum)</p>
          </div>
        </div>
      `;
    }
    
    modal.innerHTML = `
      <div style="
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #00eaff;
        border-radius: 16px;
        box-shadow: 0 0 30px rgba(0, 234, 255, 0.3);
        max-width: 400px;
        width: 90vw;
        max-height: 80vh;
        overflow-y: auto;
        animation: slideUp 0.3s ease-out;
        font-family: 'Orbitron', sans-serif;
      ">
        <div style="
          padding: 1.5rem;
          border-bottom: 1px solid rgba(0, 234, 255, 0.2);
          display: flex;
          justify-content: space-between;
          align-items: center;
        ">
          <h3 style="margin: 0; color: #00eaff; font-size: 1.25rem; font-weight: 600;">Connect Wallet</h3>
          <button class="close-modal-btn" style="
            background: none;
            border: none;
            color: #00eaff;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
          " onmouseover="this.style.backgroundColor='rgba(0, 234, 255, 0.1)'" onmouseout="this.style.backgroundColor='transparent'">Ã—</button>
        </div>
        <div style="padding: 1.5rem;">
          ${walletOptionsHTML}
          <button class="cancel-modal-btn" style="
            display: block; width: 100%; margin-top: 1rem; padding: 10px;
            background: rgba(102, 102, 102, 0.8); color: white;
            border: 1px solid rgba(0, 234, 255, 0.2); border-radius: 8px;
            cursor: pointer; font-family: 'Orbitron', sans-serif;
            transition: all 0.3s ease;
          " onmouseover="this.style.background='rgba(102, 102, 102, 1)'; this.style.borderColor='rgba(0, 234, 255, 0.4)'" onmouseout="this.style.background='rgba(102, 102, 102, 0.8)'; this.style.borderColor='rgba(0, 234, 255, 0.2)'">
            Cancel
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Add close functionality after modal is added to DOM
    const closeBtn = modal.querySelector('.close-modal-btn');
    const cancelBtn = modal.querySelector('.cancel-modal-btn');
    
    function closeModal() {
      modal.remove();
    }
    
    if (closeBtn) {
      closeBtn.addEventListener('click', closeModal);
    }
    if (cancelBtn) {
      cancelBtn.addEventListener('click', closeModal);
    }
    
    // Close when clicking outside the modal
    modal.addEventListener('click', function(e) {
      if (e.target === modal) {
        closeModal();
      }
    });
    
    // Store available wallets for connection functions
    window.availableWallets = availableWallets;
  }
  
  // Specific wallet connection function
  window.connectSpecificWallet = async function(network, walletIndex) {
    console.log(`ðŸ”— Connecting to wallet ${walletIndex} on ${network} network`);
    
    try {
      if (network === 'ethereum') {
        const wallet = window.availableWallets.ethereum[walletIndex];
        if (!wallet) {
          throw new Error(`Wallet not found at index ${walletIndex}`);
        }
        
        console.log(`ðŸ“‹ Connecting to ${wallet.name} with provider:`, wallet.provider);
        
        // Use the specific provider for this wallet
        const accounts = await wallet.provider.request({ method: 'eth_requestAccounts' });
        if (accounts.length > 0) {
          // Switch to Base network if not already on it
          try {
            await wallet.provider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: '0x2105' }], // Base mainnet
            });
          } catch (switchError) {
            // If the chain doesn't exist, add it
            if (switchError.code === 4902) {
              await wallet.provider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: '0x2105',
                  chainName: 'Base',
                  nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                  rpcUrls: ['https://mainnet.base.org'],
                  blockExplorerUrls: ['https://basescan.org']
                }]
              });
            }
          }
          
          // Update global state
          currentAddress = accounts[0];
          currentChain = 'base';
          currentProvider = wallet.provider;
          currentEvmProvider = wallet.provider;
          currentSolanaProvider = null;
          
          
          updateTokenFurnaceUI();
          updateBalance();
          
          // Close modal
          document.querySelector('[style*="position: fixed"]').remove();
          
          showBurnSuccess(`${wallet.name} connected successfully!`, false);
        }
      } else if (network === 'solana') {
        const wallet = window.availableWallets.solana[walletIndex];
        if (!wallet) {
          throw new Error(`Wallet not found at index ${walletIndex}`);
        }
        
        console.log(`ðŸ“‹ Connecting to ${wallet.name} with provider:`, wallet.provider);
        
        // Use the specific provider for this wallet
        const response = await wallet.provider.connect();
        
        // Update global state - handle different wallet response formats
        if (response && response.publicKey) {
          currentAddress = response.publicKey.toString();
        } else if (wallet.provider.publicKey) {
          currentAddress = wallet.provider.publicKey.toString();
        } else {
          throw new Error('No public key received from wallet');
        }
        
        currentChain = 'solana';
        currentProvider = wallet.provider;
        currentSolanaProvider = wallet.provider;
        currentEvmProvider = null;
        
        updateTokenFurnaceUI();
        updateBalance();
        
        // Close modal
        document.querySelector('[style*="position: fixed"]').remove();
        
        showBurnSuccess(`${wallet.name} connected successfully!`, false);
      }
    } catch (error) {
      const walletName = network === 'ethereum' ? 
        window.availableWallets.ethereum[walletIndex]?.name : 
        window.availableWallets.solana[walletIndex]?.name;
      console.error(`âŒ ${walletName} connection failed:`, error);
      showBurnSuccess(`${walletName} connection failed: ${error.message}`, true);
    }
  };
  
  function setupTokenFurnaceWallet() {
    console.log('ðŸ”§ Setting up token furnace wallet connection');
    
    // Wait a moment for DOM to be fully ready and wallet.js to load
    setTimeout(() => {
      const connectBtn = document.getElementById('connectWalletBtn');
      if (!connectBtn) {
        console.error('âŒ Connect wallet button not found');
        return;
      }
      
      // Force remove any event listeners from main wallet system
      const newButton = connectBtn.cloneNode(true);
      connectBtn.parentNode.replaceChild(newButton, connectBtn);
      
      // Add our simple click handler
      newButton.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        console.log('ðŸ”˜ Token Furnace wallet button clicked');
        
        if (currentAddress && currentChain) {
          console.log('Already connected, showing wallet details');
          showWalletDetails();
        } else {
          console.log('Not connected, showing wallet selection modal');
          window.showChainSelectionModal();
        }
      });
      
      console.log('âœ… Token furnace wallet setup complete');
      
      // Update UI based on current state
      updateTokenFurnaceUI();
    }, 500); // Give time for wallet.js to load but then take over
  }
  
  // Check for existing connections on page load
  // DISABLED: Don't auto-connect, let user choose
  // checkExistingConnections();
  
  function checkExistingConnections() {
    console.log('ðŸ” Checking for existing wallet connections (but not auto-connecting)');
    
    // We can check if wallets are available but don't auto-connect
    // This prevents the page from automatically connecting to wallets in new tabs
    
    // Check for existing Base connection (but don't auto-connect)
    if (window.ethereum) {
      window.ethereum.request({ method: 'eth_accounts' }).then(accounts => {
        if (accounts && accounts.length > 0) {
          console.log('ðŸ”— Base wallet available but not auto-connecting:', accounts[0]);
          // Don't auto-connect - let user choose
        }
      }).catch(e => {
        console.log('No existing Base connection');
      });
    }
    
    // Check for existing Solana connection (but don't auto-connect)
    if (window.solana && window.solana.isConnected) {
      console.log('ðŸ”— Solana wallet available but not auto-connecting:', window.solana.publicKey?.toString());
      // Don't auto-connect - let user choose
    }
  }
});

function showChainSelectionModal() {
  console.log('showChainSelectionModal() called'); // Debug
  
  const modal = document.createElement('div');
  modal.className = 'wallet-modal-overlay';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.2s ease-out;
  `;
  
  modal.innerHTML = `
    <div class="chain-selection-modal" style="
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 2px solid #00eaff;
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(0, 234, 255, 0.3);
      max-width: 400px;
      width: 90vw;
      max-height: 80vh;
      overflow: hidden;
      animation: slideUp 0.3s ease-out;
    ">
      <div class="modal-header" style="
        padding: 1.5rem;
        border-bottom: 1px solid rgba(0, 234, 255, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <h3 style="margin: 0; color: #00eaff; font-size: 1.25rem;">Connect Wallet</h3>
        <button class="close-modal" style="
          background: none;
          border: none;
          color: #00eaff;
          font-size: 1.5rem;
          cursor: pointer;
          padding: 0;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          transition: background-color 0.2s;
        ">Ã—</button>
      </div>
      <div class="chain-options" style="padding: 1rem; display: flex; flex-direction: column; gap: 0.75rem;">
        <button class="chain-option" data-chain="base" style="
          display: flex;
          align-items: center;
          padding: 1rem;
          background: rgba(0, 122, 255, 0.1);
          border: 1px solid rgba(0, 122, 255, 0.3);
          border-radius: 12px;
          cursor: pointer;
          transition: all 0.2s;
          color: white;
          text-decoration: none;
        ">
          <div style="
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #0052FF, #00D4FF);
            border-radius: 8px;
            margin-right: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 12px;
          ">B</div>
          <div style="flex: 1; display: flex; flex-direction: column; align-items: flex-start;">
            <span style="font-weight: 600; font-size: 1.1rem;">BASE NETWORK</span>
            <span style="font-size: 0.85rem; color: #888; margin-top: 2px;">Connect to Base Mainnet</span>
          </div>
          <div style="color: #00eaff; font-weight: bold; margin-left: 1rem;">â†’</div>
        </button>
        <button class="chain-option" data-chain="solana" style="
          display: flex;
          align-items: center;
          padding: 1rem;
          background: rgba(156, 39, 176, 0.1);
          border: 1px solid rgba(156, 39, 176, 0.3);
          border-radius: 12px;
          cursor: pointer;
          transition: all 0.2s;
          color: white;
          text-decoration: none;
        ">
          <div style="
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #9C27B0, #E91E63);
            border-radius: 8px;
            margin-right: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 12px;
          ">S</div>
          <div style="flex: 1; display: flex; flex-direction: column; align-items: flex-start;">
            <span style="font-weight: 600; font-size: 1.1rem;">SOLANA NETWORK</span>
            <span style="font-size: 0.85rem; color: #888; margin-top: 2px;">Connect to Solana Mainnet</span>
          </div>
          <div style="color: #00eaff; font-weight: bold; margin-left: 1rem;">â†’</div>
        </button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Handle chain selection
  modal.querySelectorAll('.chain-option').forEach(btn => {
    btn.addEventListener('click', async () => {
      const chain = btn.dataset.chain;
      document.body.removeChild(modal);
      
      if (chain === 'base') {
        console.log('Base chain selected'); // Debug
        // Direct Base connection - no dependency on wildWestWallet
        if (window.ethereum) {
          try {
            console.log('ðŸ”µ Connecting directly to Base wallet...');
            
            // Request account access
            const accounts = await window.ethereum.request({ 
              method: 'eth_requestAccounts' 
            });
            
            if (accounts && accounts.length > 0) {
              console.log('ðŸ”µ Accounts received:', accounts);
              
              // Set up provider
              const provider = new window.ethers.providers.Web3Provider(window.ethereum);
              
              // Switch to Base network first
              try {
                await window.ethereum.request({
                  method: 'wallet_switchEthereumChain',
                  params: [{ chainId: '0x2105' }], // Base mainnet
                });
                console.log('âœ… Switched to Base network');
              } catch (switchError) {
                if (switchError.code === 4902) {
                  console.log('ðŸ”µ Base network not found, adding it...');
                  // Add Base network if it doesn't exist
                  await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                      chainId: '0x2105',
                      chainName: 'Base',
                      nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                      rpcUrls: ['https://mainnet.base.org'],
                      blockExplorerUrls: ['https://basescan.org']
                    }]
                  });
                  console.log('âœ… Base network added');
                } else {
                  console.log('âš ï¸ Network switch error:', switchError);
                }
              }
              
              // Get the connected account
              const signer = provider.getSigner();
              const address = await signer.getAddress();
              
              console.log('âœ… Base wallet connected:', address);
              
              // Update Token Furnace state
              currentChain = 'base';
              currentAddress = address;
              currentProvider = provider;
              currentEvmProvider = provider;
              currentSolanaProvider = null;
              
              console.log('ðŸ”„ Token furnace state updated:', {
                chain: currentChain,
                address: currentAddress,
                hasProvider: !!currentProvider
              });
              
              // Update UI and balance
              updateTokenFurnaceUI();
              setTimeout(updateBalance, 200);
              
              showBurnSuccess('Base wallet connected successfully!', false);
            } else {
              console.log('âŒ No accounts returned from wallet');
              showBurnSuccess('Failed to get wallet accounts. Please try again.', true);
            }
          } catch (error) {
            console.error('âŒ Direct Base wallet connection error:', error);
            showBurnSuccess('Base wallet connection error: ' + (error.message || error), true);
          }
        } else {
          console.log('âŒ No Ethereum provider found');
          showBurnSuccess('No Ethereum wallet detected. Please install MetaMask or another Web3 wallet.', true);
        }
      } else if (chain === 'solana') {
        console.log('Solana chain selected');
        await connectSolanaWallet();
      }
    });
    
    btn.addEventListener('mouseenter', () => {
      if (btn.dataset.chain === 'base') {
        btn.style.background = 'rgba(0, 122, 255, 0.2)';
        btn.style.borderColor = 'rgba(0, 122, 255, 0.5)';
      } else {
        btn.style.background = 'rgba(156, 39, 176, 0.2)';
        btn.style.borderColor = 'rgba(156, 39, 176, 0.5)';
      }
      btn.style.transform = 'translateY(-1px)';
      btn.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
    });
    
    btn.addEventListener('mouseleave', () => {
      if (btn.dataset.chain === 'base') {
        btn.style.background = 'rgba(0, 122, 255, 0.1)';
        btn.style.borderColor = 'rgba(0, 122, 255, 0.3)';
      } else {
        btn.style.background = 'rgba(156, 39, 176, 0.1)';
        btn.style.borderColor = 'rgba(156, 39, 176, 0.3)';
      }
      btn.style.transform = 'translateY(0)';
      btn.style.boxShadow = 'none';
    });
  });
  
  // Handle close
  modal.querySelector('.close-modal').addEventListener('click', () => {
    document.body.removeChild(modal);
  });
  
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
  
  console.log('Chain selection modal created and added to page'); // Debug
}

async function connectSolanaWallet() {
  if (!await safeLoad(loadSolanaWeb3)) return;
  if (!await safeLoad(loadBN)) return;
  
  // Use the centralized wallet system for Solana connection
  if (window.wildWestWallet) {
    try {
      const connected = await window.wildWestWallet.connectSolanaWallet();
      if (connected) {
        currentChain = 'solana';
        currentAddress = window.wildWestWallet.account;
        currentProvider = window.wildWestWallet.provider;
        currentSolanaProvider = window.wildWestWallet.provider;
        currentEvmProvider = null;
        
        updateTokenFurnaceUI();
        updateBalance();
        showBurnSuccess('Solana wallet connected successfully!', false);
      } else {
        console.log('Solana wallet connection failed');
      }
    } catch (error) {
      console.error('Error connecting Solana wallet:', error);
      showBurnError('Failed to connect Solana wallet: ' + error.message);
    }
  } else {
    // Fallback to old logic if wallet system not available
    let provider = null;
    // Try Phantom first
    if (window.solana && window.solana.isPhantom) {
      provider = window.solana;
    } else if (window.phantom && window.phantom.solana && window.phantom.solana.isPhantom) {
      provider = window.phantom.solana;
    } else if (window.solflare && window.solflare.isSolflare) {
      provider = window.solflare;
    }
    
    if (provider) {
      try {
        const resp = await provider.connect();
        let pubkey = resp && resp.publicKey ? resp.publicKey : (provider.publicKey ? provider.publicKey : null);
        if (pubkey && pubkey.toString) pubkey = pubkey.toString();
        
        if (pubkey) {
          currentChain = 'solana';
          currentAddress = pubkey;
          currentProvider = provider;
          currentSolanaProvider = provider;
          currentEvmProvider = null;
          
          updateTokenFurnaceUI();
          updateBalance();
          showBurnSuccess('Solana wallet connected successfully!', false);
        } else {
          alert('Solana wallet connected, but no public key found.');
        }
      } catch (e) {
        console.error('Solana wallet error:', e);
        showBurnError('Failed to connect Solana wallet: ' + e.message);
      }
    } else {
      // Check if mobile
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      if (isMobile) {
        alert('No Solana wallet detected. Please open this page in a Solana wallet app like Phantom or Solflare.');
      } else {
        alert('No Solana wallet found. Please install Phantom, Solflare, or another Solana wallet.');
      }
    }
  }
}

function updateTokenFurnaceUI() {
  console.log('ðŸ”„ Updating token furnace UI:', { currentAddress, currentChain });
  
  // Wait a moment for DOM to be ready if needed
  setTimeout(() => {
    const walletBtnText = document.getElementById('walletBtnText');
    const connectBtn = document.getElementById('connectWalletBtn');
    const chainIndicator = document.getElementById('chainIndicator');
    
    console.log('ðŸ” UI Elements found:', {
      walletBtnText: !!walletBtnText,
      connectBtn: !!connectBtn,
      chainIndicator: !!chainIndicator
    });
    
    if (!walletBtnText || !connectBtn) {
      console.error('âŒ Required wallet UI elements not found');
      return;
    }
    
    if (currentAddress && currentChain) {
      const shortAddress = `${currentAddress.slice(0, 6)}...${currentAddress.slice(-4)}`;
      walletBtnText.textContent = shortAddress;
      
      // Update button state
      connectBtn.classList.remove('disconnected');
      connectBtn.classList.add('connected');
      
      // Update chain indicator
      if (chainIndicator) {
        if (currentChain === 'base') {
          chainIndicator.textContent = 'BASE';
          chainIndicator.style.background = '#0052ff';
          chainIndicator.style.display = 'inline-block';
        } else if (currentChain === 'solana') {
          chainIndicator.textContent = 'SOL';
          chainIndicator.style.background = '#9945ff';
          chainIndicator.style.display = 'inline-block';
        }
      }
      
      console.log('âœ… UI updated for connected wallet:', shortAddress);
    } else {
      walletBtnText.textContent = 'CONNECT WALLET';
      connectBtn.classList.remove('connected');
      connectBtn.classList.add('disconnected');
      
      if (chainIndicator) {
        chainIndicator.textContent = '';
        chainIndicator.style.display = 'none';
      }
      
      console.log('ðŸ”Œ UI updated for disconnected state');
    }
  }, 100);
}

function showWalletDetails() {
  if (!currentAddress || !currentChain) return;
  
  const modal = document.createElement('div');
  modal.className = 'wallet-modal-overlay';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.2s ease-out;
  `;
  
  const chainName = currentChain === 'base' ? 'Base Network' : 'Solana Network';
  
  modal.innerHTML = `
    <div class="wallet-details-modal" style="
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 2px solid #00eaff;
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(0, 234, 255, 0.3);
      max-width: 400px;
      width: 90vw;
      overflow: hidden;
    ">
      <div class="modal-header" style="
        padding: 1.5rem;
        border-bottom: 1px solid rgba(0, 234, 255, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <h3 style="margin: 0; color: #00eaff; font-size: 1.25rem;">Wallet Connected</h3>
        <button class="close-modal" style="
          background: none;
          border: none;
          color: #00eaff;
          font-size: 1.5rem;
          cursor: pointer;
        ">Ã—</button>
      </div>
      <div class="wallet-details" style="padding: 1.5rem;">
        <div style="display: flex; align-items: center; margin-bottom: 1.5rem;">
          <div style="
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00eaff, #0077ff);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            margin-right: 1rem;
          "></div>
          <div style="flex: 1;">
            <div style="color: white; font-family: monospace; margin-bottom: 0.25rem;">
              ${currentAddress.slice(0, 8)}...${currentAddress.slice(-8)}
            </div>
            <div style="color: #00eaff; font-size: 0.9rem;">${chainName}</div>
          </div>
          <button onclick="navigator.clipboard.writeText('${currentAddress}')" style="
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            font-size: 1.2rem;
          ">ðŸ“‹</button>
        </div>
        
        <div style="display: flex; gap: 0.75rem;">
          <button class="switch-chain-btn" style="
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #00eaff;
            border-radius: 8px;
            background: transparent;
            color: #00eaff;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
          ">Switch Chain</button>
          <button class="disconnect-btn" style="
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #ff6b6b;
            border-radius: 8px;
            background: transparent;
            color: #ff6b6b;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
          ">Disconnect</button>
        </div>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Handle actions
  modal.querySelector('.switch-chain-btn').addEventListener('click', () => {
    document.body.removeChild(modal);
    showChainSelectionModal();
  });
  
  modal.querySelector('.disconnect-btn').addEventListener('click', () => {
    disconnectWallet();
    document.body.removeChild(modal);
  });
  
  modal.querySelector('.close-modal').addEventListener('click', () => {
    document.body.removeChild(modal);
  });
  
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
}

function disconnectWallet() {
  console.log('ðŸ”Œ Disconnecting wallet...');
  
  if (currentChain === 'base' && window.wildWestWallet) {
    console.log('ðŸ”Œ Disconnecting Base wallet via wildWestWallet');
    window.wildWestWallet.disconnectWallet();
  }
  
  // Clear all wallet state
  currentChain = null;
  currentAddress = null;
  currentProvider = null;
  currentEvmProvider = null;
  currentSolanaProvider = null;
  
  // Clear token state
  currentTokenDecimals = 18;
  currentTokenSymbol = '';
  
  // Clear UI
  document.getElementById('tokenBalance').textContent = '';
  const tokenAddressInput = document.getElementById('tokenAddress');
  if (tokenAddressInput) {
    tokenAddressInput.value = '';
  }
  const tokenAmountInput = document.getElementById('tokenAmount');
  if (tokenAmountInput) {
    tokenAmountInput.value = '';
  }
  
  updateTokenFurnaceUI();
  showBurnSuccess('Wallet disconnected', false);
  
  console.log('âœ… Wallet disconnection complete');
}

// --- BURN FORM LOGIC ---
document.getElementById('burnForm').addEventListener('submit', async function(e) {
  e.preventDefault();
  const tokenAddress = document.getElementById('tokenAddress').value.trim();
  const amount = document.getElementById('tokenAmount').value.trim();
  
  if (!tokenAddress || !amount || isNaN(amount) || Number(amount) <= 0) {
    showBurnSuccess('Enter a valid token address and amount.', true);
    return;
  }
  
  // Automatically detect token type
  const tokenType = detectTokenType(tokenAddress);
  console.log('ðŸ” Detected token type:', tokenType, 'for address:', tokenAddress);
  
  if (tokenType === 'base') {
    // Base (EVM) token detected - show EVM wallet selection
    await handleEvmTokenBurn(tokenAddress, amount);
    
  } else if (tokenType === 'solana') {
    // Solana token detected - show Solana wallet selection
    await handleSolanaTokenBurn(tokenAddress, amount);
    
  } else {
    showBurnSuccess('Invalid token address. Please enter a valid Base (0x...) or Solana token address.', true);
    return;
  }
});

// --- BALANCE DISPLAY ---
// Throttle updateBalance to prevent excessive calls that can cause lag
let updateBalanceTimeout = null;
function throttledUpdateBalance() {
  if (updateBalanceTimeout) {
    clearTimeout(updateBalanceTimeout);
  }
  updateBalanceTimeout = setTimeout(updateBalance, 300); // Wait 300ms before updating
}

document.getElementById('tokenAddress').addEventListener('input', throttledUpdateBalance);
document.getElementById('tokenAddress').addEventListener('change', updateBalance); // Immediate update on change

async function updateBalance() {
  const tokenAddress = document.getElementById('tokenAddress').value.trim();
  console.log('ðŸ” updateBalance called with:', { tokenAddress });
  
  if (!tokenAddress) {
    document.getElementById('tokenBalance').textContent = '';
    console.log('âŒ No token address provided');
    return;
  }
  
  // Auto-detect token type
  const tokenType = detectTokenType(tokenAddress);
  console.log('ðŸ” Detected token type for balance fetch:', tokenType);
  
  if (tokenType === 'base') {
    // Base (EVM) token - fetch EVM balance
    if (!await safeLoad(loadEthers)) return;
    
    // Check if we have EVM wallet connection
    let addressToUse = null;
    if (window.wildWestWallet?.account) {
      addressToUse = window.wildWestWallet.account;
    } else if (currentAddress && (currentChain === 'base' || currentChain === 'ethereum')) {
      addressToUse = currentAddress;
    } else if (window.ethereum?.selectedAddress) {
      addressToUse = window.ethereum.selectedAddress;
    }
    
    if (!addressToUse) {
      document.getElementById('tokenBalance').textContent = 'Connect EVM wallet to see balance';
      return;
    }
    
    try {
      console.log('ðŸ” Fetching Base token balance for:', { 
        tokenAddress, 
        wallet: addressToUse,
        currentChain,
        BASE_RPC: BASE_RPC,
        hasEthereum: !!window.ethereum,
        hasRPCConfig: !!window.RPC_CONFIG,
        usingFallbackRPC: BASE_RPC === 'https://mainnet.base.org',
        productionConfigBase: window.PRODUCTION_CONFIG?.rpc?.base
      });
      
      // Always use QuickNode endpoint for balance checking (more reliable than wallet RPC)
      const provider = new window.ethers.providers.JsonRpcProvider(BASE_RPC);
      console.log('ðŸ“¡ Using QuickNode JsonRpcProvider for balance check:', BASE_RPC);
      
      // First, check if this address is actually a contract
      try {
        const code = await provider.getCode(tokenAddress);
        console.log('ðŸ“‹ Contract code check:', { 
          address: tokenAddress, 
          hasCode: code !== '0x', 
          codeLength: code.length,
          provider: provider.connection?.url || 'unknown',
          rpcEndpoint: BASE_RPC
        });
        
        if (code === '0x') {
          console.log('âŒ No contract code found - could be RPC issue or wrong address');
          
          // Try with a different RPC endpoint as fallback
          console.log('ðŸ”„ Trying backup RPC endpoint...');
          const backupProvider = new window.ethers.providers.JsonRpcProvider('https://base.blockpi.network/v1/rpc/public');
          const backupCode = await backupProvider.getCode(tokenAddress);
          
          if (backupCode === '0x') {
            console.log('âŒ Backup RPC also shows no contract code - this is likely an EOA wallet address');
            document.getElementById('tokenBalance').textContent = 'This address is not a contract (EOA wallet address).';
            return;
          } else {
            console.log('âœ… Contract found with backup RPC - switching provider');
            provider = backupProvider;
          }
        } else {
          console.log('âœ… Contract code found with primary RPC - proceeding with token calls');
        }
      } catch (e) {
        console.log('âš ï¸ Could not check contract code:', e);
        console.log('ðŸ”„ Continuing anyway - might still be a valid token...');
      }
      
      console.log('ðŸ“‹ Creating ERC20 contract instance...');
      console.log('ðŸ” About to create contract with address:', tokenAddress);
      console.log('ðŸ” Provider details:', {
        url: provider.connection?.url,
        isConnected: !!provider.connection
      });
      
      let erc20;
      try {
        erc20 = new window.ethers.Contract(tokenAddress, [
          'function balanceOf(address) view returns (uint256)',
          'function decimals() view returns (uint8)',
          'function symbol() view returns (string)'
        ], provider);
        console.log('âœ… ERC20 contract instance created successfully');
      } catch (contractError) {
        console.error('âŒ Failed to create contract instance:', contractError);
        throw new Error('Failed to create contract instance: ' + contractError.message);
      }
      
      console.log('ðŸ“‹ Contract instance created successfully. Calling contract methods...');
      
      // Test contract responsiveness first
      console.log('ðŸ§ª Testing contract responsiveness...');
      try {
        const testCall = await Promise.race([
          erc20.decimals(),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Test timeout')), 5000))
        ]);
        console.log('âœ… Contract responsive - decimals test successful:', testCall);
      } catch (testError) {
        console.error('âŒ Contract responsiveness test failed:', testError);
        console.log('ðŸ”„ Proceeding anyway in case it was a timeout...');
      }
      
      // Try each method individually with timeout protection
      let bal, dec, sym;
      
      try {
        console.log('ðŸ”¢ Fetching decimals...');
        dec = await Promise.race([
          erc20.decimals(),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
        ]);
        console.log('âœ… Decimals fetched successfully:', dec);
      } catch (e) {
        console.error('âŒ Decimals failed:', e.message);
        console.error('âŒ Full error:', e);
        throw new Error('Failed to get token decimals: ' + e.message);
      }
      
      try {
        console.log('ðŸ·ï¸ Fetching symbol...');
        sym = await Promise.race([
          erc20.symbol(),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
        ]);
        console.log('âœ… Symbol fetched successfully:', sym);
      } catch (e) {
        console.log('âš ï¸ Symbol failed, using empty string:', e.message);
        sym = '';
      }
      
      try {
        console.log('ðŸ’° Fetching balance for wallet:', addressToUse);
        bal = await Promise.race([
          erc20.balanceOf(addressToUse),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
        ]);
        console.log('âœ… Balance fetched successfully:', bal.toString());
      } catch (e) {
        console.error('âŒ Balance fetch failed:', e.message);
        console.error('âŒ Full error:', e);
        throw new Error('Failed to get token balance: ' + e.message);
      }
      
      console.log('ðŸ“Š Raw balance data:', { rawBalance: bal.toString(), decimals: dec, symbol: sym });
      
      currentTokenDecimals = dec;
      currentTokenSymbol = sym || '';
      const display = window.ethers.utils.formatUnits(bal, dec) + (sym ? ' ' + sym : '');
      
      console.log('ðŸ’° Base token balance fetched:', { balance: display, decimals: dec, symbol: sym });
      
      // Update the balance display with debug info
      const balanceElement = document.getElementById('tokenBalance');
      if (balanceElement) {
        balanceElement.textContent = display;
        console.log('âœ… Balance display updated in DOM:', display);
      } else {
        console.error('âŒ tokenBalance element not found in DOM');
      }
      
      // Check for account mismatch
      checkAccountMismatch();
    } catch (e) {
      console.error('âŒ Error fetching Base token balance:', e);
      console.error('âŒ Error details:', {
        message: e.message,
        code: e.code,
        stack: e.stack,
        name: e.name
      });
      
      let errorMsg = 'Unable to fetch balance.';
      if (e && e.message) {
        if (e.message.includes('call revert exception') || e.message.includes('execution reverted')) {
          errorMsg = 'Invalid token contract. This address is not an ERC20 token.';
        } else if (e.message.includes('invalid address')) {
          errorMsg = 'Invalid token address.';
        } else if (e.message.includes('network') || e.message.includes('timeout') || e.message.includes('Timeout')) {
          errorMsg = 'Network error or timeout. Please try again.';
        } else if (e.message.includes('Failed to get token decimals')) {
          errorMsg = 'Cannot read token decimals. Not a valid ERC20 token.';
        } else if (e.message.includes('Failed to get token balance')) {
          errorMsg = 'Cannot read token balance. Check wallet connection.';
        } else {
          errorMsg = 'Error: ' + e.message;
        }
      }
      
      document.getElementById('tokenBalance').textContent = errorMsg;
    }
    
  } else if (tokenType === 'solana') {
    // Solana token - fetch Solana balance
    if (!await safeLoad(loadSolanaWeb3)) return;
    if (!await safeLoad(loadBN)) return;
    
    // Check if we have Solana wallet connection
    let addressToUse = null;
    if (currentChain === 'solana' && currentAddress) {
      addressToUse = currentAddress;
    } else if (window.solana?.publicKey) {
      addressToUse = window.solana.publicKey.toString();
    } else if (window.phantom?.solana?.publicKey) {
      addressToUse = window.phantom.solana.publicKey.toString();
    }
    
    if (!addressToUse) {
      document.getElementById('tokenBalance').textContent = 'Connect Solana wallet to see balance';
      return;
    }
    
    try {
      console.log('ðŸ” Fetching Solana token balance for:', { tokenAddress, wallet: addressToUse });
      
      // Get the current RPC endpoint - using initialized endpoint
      const connection = new window.solanaWeb3.Connection(SOLANA_RPC);
      const mintPubkey = new window.solanaWeb3.PublicKey(tokenAddress);
      const ownerPubkey = new window.solanaWeb3.PublicKey(addressToUse);
      const tokenAccounts = await connection.getTokenAccountsByOwner(ownerPubkey, { mint: mintPubkey });
      
      if (tokenAccounts.value.length === 0) {
        document.getElementById('tokenBalance').textContent = '0';
        return;
      }
      
      const accountInfo = await connection.getParsedAccountInfo(tokenAccounts.value[0].pubkey);
      const bal = accountInfo.value.data.parsed.info.tokenAmount.uiAmountString;
      const dec = accountInfo.value.data.parsed.info.tokenAmount.decimals;
      
      currentTokenDecimals = dec;
      console.log('ðŸ’° Solana token balance fetched:', bal);
      document.getElementById('tokenBalance').textContent = bal;
    } catch (e) {
      console.error('âŒ Error fetching Solana token balance:', e);
      document.getElementById('tokenBalance').textContent = 'Unable to fetch balance.';
    }
    
  } else {
    // Invalid token type
    document.getElementById('tokenBalance').textContent = '';
  }
}

// --- BURN LOGIC ---

// Extracted burn logic for already connected wallets
async function performEvmBurn(provider, signer, tokenAddress, amount, signerAddress) {
  console.log('ðŸ”¥ Performing EVM burn with connected wallet:', signerAddress);
  
  const dead = '0x000000000000000000000000000000000000dEaD';
  
  // Create ERC20 contract
  const erc20 = new window.ethers.Contract(tokenAddress, [
    'function transfer(address to, uint256 amount) returns (bool)',
    'function decimals() view returns (uint8)',
    'function balanceOf(address) view returns (uint256)',
    'function name() view returns (string)',
    'function symbol() view returns (string)',
    'function burn(uint256 amount)',
    'function totalSupply() view returns (uint256)'
  ], signer);
  
  // Get token decimals
  let decimals = currentTokenDecimals;
  if (!decimals) {
    console.log('ðŸ”¢ Fetching token decimals...');
    decimals = await erc20.decimals();
    console.log('ðŸ”¢ Token decimals:', decimals);
  }
  
  // Check balance
  const balance = await erc20.balanceOf(signerAddress);
  const balanceFormatted = window.ethers.utils.formatUnits(balance, decimals);
  console.log('ðŸ’° Current balance:', balanceFormatted);
  
  if (parseFloat(amount) > parseFloat(balanceFormatted)) {
    showBurnSuccess(`Insufficient balance. You have ${balanceFormatted} tokens in the connected account.`, true);
    return;
  }
  
  // Check network
  const network = await provider.getNetwork();
  if (network.chainId !== 8453) {
    showBurnSuccess('Wrong network! Please switch to Base network (Chain ID: 8453)', true);
    return;
  }
  
  // Convert amount to proper units
  const value = window.ethers.utils.parseUnits(amount.toString(), decimals);
  
  console.log('ðŸ”¥ Executing burn transaction...', {
    to: dead,
    amount: value.toString(),
    from: signerAddress
  });
  
  try {
    // Estimate gas
    const gasEstimate = await erc20.estimateGas.transfer(dead, value);
    console.log('â›½ Gas estimate:', gasEstimate.toString());
    
    // Execute transaction
    const tx = await erc20.transfer(dead, value, {
      gasLimit: gasEstimate.mul(120).div(100) // Add 20% buffer
    });
    console.log('âœ… Transaction submitted:', tx.hash);
    
    console.log('â³ Waiting for transaction confirmation...');
    await tx.wait();
    console.log('âœ… Transaction confirmed!');
    
    // Show success
    showTransactionHashModal(tx.hash, 'base');
    updateBalance();
  } catch (error) {
    console.error('âŒ Burn transaction failed:', error);
    showBurnSuccess('Transaction failed: ' + error.message, true);
  }
}

async function burnEvmToken(tokenAddress, amount) {
  if (!await safeLoad(loadEthers)) {
    showBurnSuccess('Failed to load Ethers library.', true);
    return;
  }
  
  console.log('ðŸ”¥ Starting Base token burn:', { tokenAddress, amount, currentAddress });
  
  // Check if we already have a connected wallet - SKIP WALLET DETECTION
  const hasConnectedWallet = (
    currentAddress || 
    window.wildWestWallet?.account || 
    window.ethereum?.selectedAddress ||
    (window.ethereum?.isConnected && window.ethereum.isConnected())
  );
  
  if (hasConnectedWallet) {
    console.log('âœ… Using already connected wallet, skipping detection');
    
    // Use the specific provider that was used for connection
    let walletProvider = null;
    
    if (window.wildWestWallet?.provider) {
      console.log('ðŸŽ¯ Using wildWestWallet provider');
      walletProvider = window.wildWestWallet.provider;
    } else if (currentEvmProvider) {
      console.log('ðŸŽ¯ Using currentEvmProvider');
      walletProvider = currentEvmProvider;
    } else if (currentProvider) {
      console.log('ðŸŽ¯ Using currentProvider');
      walletProvider = currentProvider;
    } else {
      console.log('ðŸŽ¯ Falling back to window.ethereum');
      walletProvider = window.ethereum;
    }
    
    try {
      const provider = new window.ethers.providers.Web3Provider(walletProvider);
      const signer = provider.getSigner();
      const signerAddress = await signer.getAddress();
      
      console.log('ðŸ”’ Using connected wallet address:', signerAddress);
      console.log('ðŸ”’ Wallet provider info:', {
        isMetaMask: walletProvider?.isMetaMask,
        isCoinbaseWallet: walletProvider?.isCoinbaseWallet,
        isPhantom: walletProvider?.isPhantom
      });
      
      // Proceed with burn using the correct wallet provider
      await performEvmBurn(provider, signer, tokenAddress, amount, signerAddress);
      return;
    } catch (error) {
      console.error('âŒ Error using connected wallet:', error);
      // Fall through to wallet detection if connected wallet fails
    }
  }
  
  // COMPREHENSIVE WALLET ISOLATION SYSTEM (only if no wallet connected)
  console.log('ðŸ”’ No connected wallet found, initializing wallet detection...');
  
  let evmProvider = null;
  let isolatedPhantomProvider = null;
  
  // Step 1: Catalog all available wallet providers
  const walletCatalog = {
    metamask: [],
    phantom: [],
    other: []
  };
  
  if (window.ethereum) {
    if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
      console.log('ðŸ“‹ Multiple providers detected, cataloging...');
      window.ethereum.providers.forEach((provider, index) => {
        console.log(`ðŸ” Provider ${index}:`, {
          isMetaMask: provider.isMetaMask,
          isPhantom: provider.isPhantom,
          isCoinbaseWallet: provider.isCoinbaseWallet,
          isRainbow: provider.isRainbow,
          isTrust: provider.isTrust
        });
        
        if (provider.isMetaMask && !provider.isPhantom) {
          walletCatalog.metamask.push(provider);
        } else if (provider.isPhantom && !provider.isMetaMask) {
          walletCatalog.phantom.push(provider);
        } else if (provider.isMetaMask && provider.isPhantom) {
          // Handle edge case where both are detected
          console.log('âš ï¸ Provider claims to be both MetaMask and Phantom');
          if (provider._metamask) {
            walletCatalog.metamask.push(provider);
          } else if (provider._phantom) {
            walletCatalog.phantom.push(provider);
          } else {
            walletCatalog.other.push(provider);
          }
        } else {
          walletCatalog.other.push(provider);
        }
      });
    } else {
      // Single provider object
      console.log('ðŸ“‹ Single provider detected, analyzing...');
      if (window.ethereum.isMetaMask && !window.ethereum.isPhantom) {
        walletCatalog.metamask.push(window.ethereum);
      } else if (window.ethereum.isPhantom && !window.ethereum.isMetaMask) {
        walletCatalog.phantom.push(window.ethereum);
      } else if (window.ethereum.isMetaMask && window.ethereum.isPhantom) {
        // Both detected in single object - try to isolate
        if (window.ethereum._metamask) {
          walletCatalog.metamask.push(window.ethereum);
        } else {
          console.log('âš ï¸ Cannot isolate MetaMask from mixed provider');
          walletCatalog.other.push(window.ethereum);
        }
      }
    }
  }
  
  console.log('ðŸ“Š Wallet catalog complete:', {
    metamask: walletCatalog.metamask.length,
    phantom: walletCatalog.phantom.length,
    other: walletCatalog.other.length
  });
  
  // Step 2: Select ANY available EVM provider for Base transactions
  
  if (walletCatalog.metamask.length > 0) {
    evmProvider = walletCatalog.metamask[0];
    console.log('âœ… Using MetaMask provider');
  } else if (walletCatalog.other.length > 0) {
    // Use any EVM wallet (Coinbase, Trust, etc.)
    evmProvider = walletCatalog.other[0];
    console.log('âœ… Using EVM wallet provider');
  }
  
  if (!evmProvider) {
    console.error('ðŸš¨ NO EVM WALLET PROVIDER FOUND');
    showWalletManagementModal(walletCatalog);
    return;
  }
  
  console.log('ðŸ”’ Wallet selection complete - EVM wallet ready for Base transactions');
  
  try {
    let provider, signer;
    if (window.ethereum) {
      // Debug wallet provider information
      console.log('ðŸ” Wallet provider debug info:', {
        isMetaMask: window.ethereum.isMetaMask,
        isPhantom: window.ethereum.isPhantom,
        providers: window.ethereum.providers?.length || 0,
        selectedAddress: window.ethereum.selectedAddress
      });
      
      // USE ISOLATED METAMASK PROVIDER ONLY
      let ethProvider = evmProvider;
      
      console.log('ðŸŽ¯ Using isolated MetaMask provider:', {
        isMetaMask: ethProvider.isMetaMask,
        isPhantom: ethProvider.isPhantom,
        hasRequest: !!ethProvider.request,
        hasMetaMaskProperty: !!ethProvider._metamask
      });
      
      // Final safety check on isolated provider
      if (!ethProvider.isMetaMask) {
        console.error('ï¿½ ISOLATED PROVIDER IS NOT METAMASK');
        showBurnSuccess('ERROR: Failed to isolate MetaMask provider. Please disable other wallet extensions and refresh the page.', true);
        return;
      }
      
      if (ethProvider.isPhantom && !ethProvider._metamask) {
        console.error('ðŸš¨ ISOLATED PROVIDER CONTAMINATED WITH PHANTOM');
        showBurnSuccess('ERROR: MetaMask provider contaminated with Phantom. Please disable Phantom extension and refresh the page.', true);
        return;
      }
      
      provider = new window.ethers.providers.Web3Provider(ethProvider);
      signer = provider.getSigner();
      console.log('ðŸ”— Using Web3Provider with MetaMask signer');
      
      // IMMEDIATELY verify this is the correct provider
      try {
        const testAddress = await signer.getAddress();
        console.log('ðŸ§ª Test signer address from selected provider:', testAddress);
        
        // Double-check that we're using MetaMask and not Phantom
        if (ethProvider.isPhantom && !ethProvider.isMetaMask) {
          console.error('âŒ PHANTOM DETECTED - This should not happen!');
          showBurnSuccess('Error: System is trying to use Phantom instead of MetaMask. Please disable Phantom temporarily and refresh the page.', true);
          return;
        }
        
        console.log('âœ… Confirmed using MetaMask provider');
      } catch (providerError) {
        console.error('âŒ Provider verification failed:', providerError);
        showBurnSuccess('Wallet provider error. Please refresh the page and try again.', true);
        return;
      }
      
      // Verify the signer address matches our current address
      const signerAddress = await signer.getAddress();
      console.log('ðŸ” Signer address:', signerAddress);
      console.log('ðŸ” Current address:', currentAddress);
      console.log('ðŸ” WildWest wallet account:', window.wildWestWallet?.account);
      
      // Always use wildWestWallet account if available, as it's the authoritative source
      const correctAddress = window.wildWestWallet?.account || currentAddress;
      
      if (correctAddress.toLowerCase() !== signerAddress.toLowerCase()) {
        console.log('ðŸ”„ Address mismatch detected, requesting wallet to switch account...');
        console.log('  Token holder address:', correctAddress);
        console.log('  Current signer address:', signerAddress);
        
        // Try to request the specific provider to switch accounts
        try {
          console.log('ðŸ”„ Requesting wallet to switch to account:', correctAddress);
          
          // First try to request accounts from the specific provider
          const accounts = await ethProvider.request({ method: 'eth_requestAccounts' });
          console.log('ðŸ” Available accounts from provider:', accounts);
          
          // Check if the correct address is in the available accounts
          const correctAddressLower = correctAddress.toLowerCase();
          if (accounts.some(acc => acc.toLowerCase() === correctAddressLower)) {
            console.log('âœ… Correct address is available in wallet accounts');
            
            // Try to switch to the correct account
            await ethProvider.request({
              method: 'wallet_requestPermissions',
              params: [{ eth_accounts: {} }]
            });
            
            // Get updated signer
            signer = provider.getSigner();
            const newSignerAddress = await signer.getAddress();
            console.log('ðŸ” New signer address after permission request:', newSignerAddress);
            
            if (newSignerAddress.toLowerCase() !== correctAddressLower) {
              showBurnSuccess(`Wallet is connected to ${newSignerAddress} but tokens are in ${correctAddress}. Please manually switch to the correct account in your wallet and try again.`, true);
              return;
            }
          } else {
            console.log('âŒ Correct address not found in wallet accounts');
            console.log('ðŸ”„ Attempting to request access to the correct account...');
            
            // Try multiple approaches to get the correct account
            try {
              // Method 1: Request specific account access
              const newAccounts = await ethProvider.request({
                method: 'eth_requestAccounts',
                params: []
              });
              console.log('ðŸ” New accounts after request:', newAccounts);
              
              if (newAccounts.some(acc => acc.toLowerCase() === correctAddressLower)) {
                console.log('âœ… Correct address now available after request');
                // Recreate provider and signer
                provider = new window.ethers.providers.Web3Provider(ethProvider);
                signer = provider.getSigner();
                const finalAddress = await signer.getAddress();
                console.log('ðŸ” Final signer address:', finalAddress);
                
                if (finalAddress.toLowerCase() !== correctAddressLower) {
                  showBurnSuccess(`Please manually switch to account ${correctAddress} in your wallet and try burning again.`, true);
                  return;
                }
              } else {
                showBurnSuccess(`The account ${correctAddress} is not available in your current wallet. Please switch to MetaMask or add this account to your wallet.`, true);
                return;
              }
            } catch (accountError) {
              console.log('âŒ Failed to request correct account:', accountError);
              
              // Final fallback: Show user instructions for manual account switching
              console.log('ðŸ”„ Showing user manual account switching instructions...');
              
              const switchAccountModal = document.createElement('div');
              switchAccountModal.className = 'wallet-modal-overlay';
              switchAccountModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.2s ease-out;
              `;
              
              switchAccountModal.innerHTML = `
                <div style="
                  background: linear-gradient(135deg, #1a1a2e, #16213e);
                  border: 2px solid #ff6b6b;
                  border-radius: 16px;
                  box-shadow: 0 0 30px rgba(255, 107, 107, 0.3);
                  max-width: 500px;
                  width: 90vw;
                  overflow: hidden;
                ">
                  <div style="
                    padding: 1.5rem;
                    border-bottom: 1px solid rgba(255, 107, 107, 0.2);
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                  ">
                    <h3 style="margin: 0; color: #ff6b6b; font-size: 1.25rem;">Account Switch Required</h3>
                    <button class="close-modal" style="
                      background: none;
                      border: none;
                      color: #ff6b6b;
                      font-size: 1.5rem;
                      cursor: pointer;
                    ">Ã—</button>
                  </div>
                  <div style="padding: 1.5rem; color: white;">
                    <p style="margin: 0 0 1rem 0; font-size: 1.1rem; color: #ffae00;">
                      ðŸ”„ <strong>Manual Account Switch Needed</strong>
                    </p>
                    <p style="margin: 0 0 1rem 0;">
                      Your tokens are in account: <br>
                      <code style="background: #333; padding: 4px 8px; border-radius: 4px; color: #ffae00; word-break: break-all;">${correctAddress}</code>
                    </p>
                    <p style="margin: 0 0 1rem 0;">
                      But MetaMask is currently using: <br>
                      <code style="background: #333; padding: 4px 8px; border-radius: 4px; color: #ff6b6b; word-break: break-all;">${await signer.getAddress()}</code>
                    </p>
                    <div style="background: #2a2a2a; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                      <p style="margin: 0 0 0.5rem 0; font-weight: bold; color: #00eaff;">Follow these steps:</p>
                      <ol style="margin: 0; padding-left: 1.2rem;">
                        <li>Open MetaMask extension</li>
                        <li>Click on the account dropdown at the top</li>
                        <li>Select the account ending in <strong style="color: #ffae00;">...${correctAddress.slice(-4)}</strong></li>
                        <li>Come back and try burning again</li>
                      </ol>
                    </div>
                    <div style="display: flex; gap: 0.75rem; margin-top: 1rem;">
                      <button class="retry-btn" style="
                        flex: 1;
                        padding: 0.75rem;
                        border: 1px solid #00eaff;
                        border-radius: 8px;
                        background: transparent;
                        color: #00eaff;
                        cursor: pointer;
                        font-weight: 500;
                      ">Try Again</button>
                      <button class="close-modal" style="
                        flex: 1;
                        padding: 0.75rem;
                        border: 1px solid #666;
                        border-radius: 8px;
                        background: transparent;
                        color: #ccc;
                        cursor: pointer;
                        font-weight: 500;
                      ">Cancel</button>
                    </div>
                  </div>
                </div>
              `;
              
              document.body.appendChild(switchAccountModal);
              
              // Handle modal interactions
              switchAccountModal.querySelectorAll('.close-modal').forEach(btn => {
                btn.addEventListener('click', () => {
                  document.body.removeChild(switchAccountModal);
                });
              });
              
              switchAccountModal.querySelector('.retry-btn').addEventListener('click', () => {
                document.body.removeChild(switchAccountModal);
                // Retry the burn operation
                setTimeout(() => burnEvmToken(tokenAddress, amount), 500);
              });
              
              switchAccountModal.addEventListener('click', (e) => {
                if (e.target === switchAccountModal) {
                  document.body.removeChild(switchAccountModal);
                }
              });
              
              return;
            }
          }
        } catch (permissionError) {
          console.log('âš ï¸ Could not request account switch:', permissionError);
          showBurnSuccess(`Wallet address mismatch. Please manually switch to account ${correctAddress} in your wallet to burn these tokens.`, true);
          return;
        }
      }
      
      // Update our state to match the verified signer
      currentAddress = await signer.getAddress();
      console.log('âœ… Verified transaction will be sent from:', currentAddress);
    } else {
      provider = new window.ethers.providers.JsonRpcProvider(BASE_RPC);
      console.log('ðŸ”— Using JsonRpcProvider (read-only)');
      // No signer, can't send txs
      showBurnSuccess('No wallet connected. Cannot burn tokens in read-only mode.', true);
      return;
    }
    
    console.log('ðŸ“‹ Creating ERC20 contract for:', tokenAddress);
    const erc20 = new window.ethers.Contract(tokenAddress, [
      'function transfer(address to, uint256 amount) returns (bool)',
      'function decimals() view returns (uint8)',
      'function balanceOf(address) view returns (uint256)',
      'function name() view returns (string)',
      'function symbol() view returns (string)',
      'function burn(uint256 amount)', // Optional burn function
      'function totalSupply() view returns (uint256)' // For additional checks
    ], signer);
    
    // Get token info for better debugging
    try {
      const [name, symbol, totalSupply] = await Promise.all([
        erc20.name().catch(() => 'Unknown'),
        erc20.symbol().catch(() => 'Unknown'), 
        erc20.totalSupply().catch(() => '0')
      ]);
      console.log('ðŸª™ Token info:', { name, symbol, totalSupply: totalSupply.toString() });
    } catch (e) {
      console.log('âš ï¸ Could not fetch token info, proceeding anyway...');
    }
    
    let decimals = currentTokenDecimals;
    if (!decimals) {
      console.log('ðŸ”¢ Fetching token decimals...');
      decimals = await erc20.decimals();
      console.log('ðŸ”¢ Token decimals:', decimals);
    }
    
    // Check balance before burning
    console.log('ðŸ’° Checking token balance...');
    let balanceFormatted;
    try {
      // Always use the current signer address for balance check
      const currentSignerAddress = await signer.getAddress();
      const balance = await erc20.balanceOf(currentSignerAddress);
      balanceFormatted = window.ethers.utils.formatUnits(balance, decimals);
      console.log('ðŸ’° Current balance for signer address:', balanceFormatted, 'Raw:', balance.toString());
      
      if (parseFloat(amount) > parseFloat(balanceFormatted)) {
        showBurnSuccess(`Insufficient balance. You have ${balanceFormatted} tokens in the connected account.`, true);
        return;
      }
    } catch (balanceError) {
      console.error('âŒ Failed to check balance:', balanceError);
      showBurnSuccess('Cannot read token balance. This token may have access restrictions or be paused.', true);
      return;
    }
    
    const value = window.ethers.utils.parseUnits(amount, decimals);
    const dead = '0x000000000000000000000000000000000000dEaD';
    
    console.log('ðŸ”¥ Burn parameters:', {
      tokenAddress,
      amount,
      decimals,
      value: value.toString(),
      deadAddress: dead,
      userBalance: balanceFormatted
    });
    
    // Check if we're on the right network
    const network = await provider.getNetwork();
    console.log('ðŸŒ Network info:', {
      chainId: network.chainId,
      name: network.name,
      isBase: network.chainId === 8453
    });
    
    if (network.chainId !== 8453) {
      showBurnSuccess('Wrong network! Please switch to Base network (Chain ID: 8453)', true);
      return;
    }
    
    console.log('ðŸ”¥ Executing burn transaction...', {
      to: dead,
      amount: value.toString(),
      from: currentAddress
    });
    
    // Try to estimate gas first to catch issues early
    try {
      console.log('â›½ Estimating gas for transaction...');
      const gasEstimate = await erc20.estimateGas.transfer(dead, value);
      console.log('â›½ Gas estimate:', gasEstimate.toString());
      
      // Execute the transaction with the estimated gas
      const tx = await erc20.transfer(dead, value, {
        gasLimit: gasEstimate.mul(120).div(100) // Add 20% buffer
      });
      console.log('âœ… Transaction submitted:', tx.hash);
      
      console.log('â³ Waiting for transaction confirmation...');
      await tx.wait();
      console.log('âœ… Transaction confirmed!');
      
      // Show transaction hash copy modal instead of simple success message
      showTransactionHashModal(tx.hash, 'base');
      
      updateBalance();
    } catch (gasError) {
      console.error('â›½ Gas estimation failed:', gasError);
      
      // If gas estimation fails, try without gas estimation (let wallet handle it)
      console.log('ðŸ”„ Trying simple transfer without gas estimation...');
      
      try {
        const tx = await erc20.transfer(dead, value);
        console.log('âœ… Simple transaction submitted:', tx.hash);
        
        await tx.wait();
        
        // Show transaction hash copy modal for fallback transaction too
        showTransactionHashModal(tx.hash, 'base');
        
        updateBalance();
      } catch (simpleError) {
        console.error('âŒ Simple transfer also failed:', simpleError);
        
        // Try transferring to yourself first to test if transfers work at all
        console.log('ðŸ”„ Testing if token allows any transfers...');
        try {
          const testAmount = window.ethers.utils.parseUnits('0.000001', decimals);
          const testTx = await erc20.transfer(currentAddress, testAmount);
          console.log('âœ… Self-transfer test successful:', testTx.hash);
          await testTx.wait();
          
          // If self-transfer works, the issue is specifically with the dead address
          showBurnSuccess('This token does not allow transfers to the burn address. Try contacting the token developer for burning instructions.', true);
        } catch (testError) {
          console.error('âŒ Token does not allow transfers at all:', testError);
          showBurnSuccess('This token appears to be non-transferable or has severe transfer restrictions.', true);
        }
      }
    }
  } catch (e) {
    console.error('âŒ Burn failed:', e);
    
    let errorMsg = 'Unknown error occurred';
    if (e && e.message) {
      if (e.message.includes('user rejected')) {
        errorMsg = 'Transaction was rejected by user';
      } else if (e.message.includes('insufficient funds')) {
        errorMsg = 'Insufficient funds for gas or tokens';
      } else if (e.message.includes('execution reverted')) {
        errorMsg = 'Token burning failed - this token may have transfer restrictions, anti-bot protection, or does not allow transfers to burn addresses. Try a different amount or contact the token developer.';
      } else if (e.message.includes('invalid address')) {
        errorMsg = 'Invalid token address';
      } else if (e.message.includes('UNPREDICTABLE_GAS_LIMIT')) {
        errorMsg = 'This token cannot be burned using the standard transfer method. It may have special burn mechanics or transfer restrictions.';
      } else {
        errorMsg = e.message;
      }
    }
    
    showBurnSuccess('Burn failed: ' + errorMsg, true);
  }
}
async function burnSolanaToken(tokenAddress, amount) {
  if (!await safeLoad(loadSolanaWeb3)) {
    showBurnSuccess('Failed to load Solana Web3 library.', true);
    return;
  }
  if (!await safeLoad(loadBN)) {
    showBurnSuccess('Failed to load BN library.', true);
    return;
  }
  
  console.log('ðŸ”¥ Starting Solana token burn:', { tokenAddress, amount, currentAddress });
  
  // COMPREHENSIVE WALLET ISOLATION SYSTEM FOR SOLANA
  console.log('ðŸ”’ Initializing Solana wallet isolation system...');
  
  let isolatedPhantomProvider = null;
  let isolatedSolflareProvider = null;
  let selectedSolanaProvider = null;
  
  // Step 1: Catalog all available Solana wallet providers
  const solanaWalletCatalog = {
    phantom: [],
    solflare: [],
    backpack: [],
    glow: [],
    other: []
  };
  
  // Check for Phantom
  if (window.phantom?.solana) {
    solanaWalletCatalog.phantom.push(window.phantom.solana);
    console.log('âœ… Phantom Solana wallet detected');
  }
  
  // Check for Solflare
  if (window.solflare) {
    solanaWalletCatalog.solflare.push(window.solflare);
    console.log('âœ… Solflare wallet detected');
  }
  
  // Check for Backpack
  if (window.backpack) {
    solanaWalletCatalog.backpack.push(window.backpack);
    console.log('âœ… Backpack wallet detected');
  }
  
  // Check for Glow
  if (window.glow) {
    solanaWalletCatalog.glow.push(window.glow);
    console.log('âœ… Glow wallet detected');
  }
  
  // Check for generic Solana provider
  if (window.solana && !window.phantom?.solana) {
    solanaWalletCatalog.other.push(window.solana);
    console.log('âœ… Generic Solana wallet detected');
  }
  
  console.log('ðŸ“Š Solana wallet catalog complete:', {
    phantom: solanaWalletCatalog.phantom.length,
    solflare: solanaWalletCatalog.solflare.length,
    backpack: solanaWalletCatalog.backpack.length,
    glow: solanaWalletCatalog.glow.length,
    other: solanaWalletCatalog.other.length
  });
  
  // Step 2: Select the appropriate Solana provider (prefer current provider)
  if (currentSolanaProvider) {
    selectedSolanaProvider = currentSolanaProvider;
    console.log('âœ… Using current Solana provider');
  } else if (solanaWalletCatalog.phantom.length > 0) {
    selectedSolanaProvider = solanaWalletCatalog.phantom[0];
    console.log('âœ… Using Phantom provider');
  } else if (solanaWalletCatalog.solflare.length > 0) {
    selectedSolanaProvider = solanaWalletCatalog.solflare[0];
    console.log('âœ… Using Solflare provider');
  } else if (solanaWalletCatalog.other.length > 0) {
    selectedSolanaProvider = solanaWalletCatalog.other[0];
    console.log('âœ… Using generic Solana provider');
  }
  
  if (!selectedSolanaProvider) {
    console.error('ðŸš¨ NO SOLANA PROVIDER FOUND');
    showBurnSuccess('No Solana wallet detected. Please install Phantom, Solflare, or another Solana wallet.', true);
    return;
  }
  
  console.log('ðŸ”’ Solana wallet isolation complete');
  
  try {
    // Use the initialized RPC endpoint
    console.log('ðŸ”§ Using initialized Solana RPC endpoint');
    
    const connection = new window.solanaWeb3.Connection(SOLANA_RPC, 'confirmed');
    console.log('âœ… Solana connection established');
    
    // Verify current address matches wallet
    let walletPublicKey = null;
    if (selectedSolanaProvider.publicKey) {
      walletPublicKey = selectedSolanaProvider.publicKey.toString();
    } else {
      console.log('ðŸ”„ Wallet not connected, attempting connection...');
      try {
        const connectResponse = await selectedSolanaProvider.connect();
        walletPublicKey = connectResponse.publicKey ? connectResponse.publicKey.toString() : selectedSolanaProvider.publicKey?.toString();
      } catch (connectError) {
        console.error('âŒ Failed to connect to Solana wallet:', connectError);
        showBurnSuccess('Failed to connect to Solana wallet: ' + connectError.message, true);
        return;
      }
    }
    
    if (!walletPublicKey) {
      console.error('âŒ No public key available from wallet');
      showBurnSuccess('Unable to get public key from Solana wallet. Please check your wallet connection.', true);
      return;
    }
    
    console.log('ðŸ” Wallet public key:', walletPublicKey);
    console.log('ðŸ” Current address:', currentAddress);
    
    // Use the authoritative address (wildWestWallet if available, otherwise current)
    const correctAddress = currentAddress || walletPublicKey;
    
    if (correctAddress.toLowerCase() !== walletPublicKey.toLowerCase()) {
      console.log('ðŸ”„ Address mismatch detected:', {
        correctAddress,
        walletAddress: walletPublicKey
      });
      showBurnSuccess(`Address mismatch. Tokens are in ${correctAddress} but wallet is connected to ${walletPublicKey}. Please switch accounts in your wallet.`, true);
      return;
    }
    
    console.log('âœ… Address verification passed');
    
    // Create public key objects
    const mintPubkey = new window.solanaWeb3.PublicKey(tokenAddress);
    const ownerPubkey = new window.solanaWeb3.PublicKey(correctAddress);
    
    console.log('ðŸ” Searching for token accounts...');
    
    // Find token accounts using QuickNode endpoint
    const tokenAccounts = await connection.getTokenAccountsByOwner(ownerPubkey, { mint: mintPubkey });
    
    console.log('ðŸ“‹ Token account search results:', {
      accountsFound: tokenAccounts.value.length,
      accounts: tokenAccounts.value.map(acc => acc.pubkey.toString())
    });
    
    if (tokenAccounts.value.length === 0) {
      console.error('âŒ No token account found for this mint');
      showBurnSuccess('No token account found for this mint address in your wallet.', true);
      return;
    }
    
    const tokenAccountPubkey = tokenAccounts.value[0].pubkey;
    console.log('âœ… Using token account:', tokenAccountPubkey.toString());
    
    // Get token decimals and current balance
    console.log('ðŸ” Fetching token metadata...');
    let decimals = currentTokenDecimals;
    let currentBalance = null;
    
    try {
      const mintInfo = await connection.getParsedAccountInfo(mintPubkey);
      if (mintInfo.value && mintInfo.value.data.parsed) {
        decimals = mintInfo.value.data.parsed.info.decimals;
        console.log('âœ… Token decimals from mint:', decimals);
      }
      
      const tokenAccountInfo = await connection.getParsedAccountInfo(tokenAccountPubkey);
      if (tokenAccountInfo.value && tokenAccountInfo.value.data.parsed) {
        currentBalance = tokenAccountInfo.value.data.parsed.info.tokenAmount.uiAmountString;
        console.log('âœ… Current token balance:', currentBalance);
      }
    } catch (metadataError) {
      console.error('âš ï¸ Error fetching token metadata:', metadataError);
      console.log('ðŸ”„ Continuing with default decimals...');
    }
    
    if (!decimals) {
      console.log('âš ï¸ Using default decimals (9) for Solana token');
      decimals = 9;
    }
    
    // Validate burn amount
    const burnAmountNum = parseFloat(amount);
    const balanceNum = parseFloat(currentBalance || '0');
    
    if (burnAmountNum <= 0) {
      showBurnSuccess('Burn amount must be greater than 0.', true);
      return;
    }
    
    if (currentBalance && burnAmountNum > balanceNum) {
      showBurnSuccess(`Insufficient balance. You have ${currentBalance} tokens but trying to burn ${amount}.`, true);
      return;
    }
    
    console.log('âœ… Burn amount validation passed:', {
      burnAmount: burnAmountNum,
      currentBalance: balanceNum,
      decimals
    });
    
    // Calculate amount in base units
    const bnAmount = new window.BN(amount).mul(new window.BN(10).pow(new window.BN(decimals)));
    console.log('ðŸ§® Calculated burn amount in base units:', bnAmount.toString());
    
    // Create SPL Token burn instruction
    console.log('ðŸ”¨ Creating SPL Token burn instruction...');
    
    // Hand-craft SPL Token burn instruction (instruction 8)
    // Layout: [8, ...amount(8 bytes LE)]
    const data = new Uint8Array(9);
    data[0] = 8; // Burn instruction
    const amountLE = bnAmount.toArray('le', 8);
    for (let i = 0; i < 8; ++i) data[i + 1] = amountLE[i];
    
    const splTokenProgramId = new window.solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
    
    const keys = [
      { pubkey: tokenAccountPubkey, isSigner: false, isWritable: true },
      { pubkey: mintPubkey, isSigner: false, isWritable: true },
      { pubkey: ownerPubkey, isSigner: true, isWritable: false },
    ];
    
    const burnIx = new window.solanaWeb3.TransactionInstruction({
      keys,
      programId: splTokenProgramId,
      data,
    });
    
    console.log('âœ… Burn instruction created');
    
    // Create and prepare transaction
    console.log('ðŸ“‹ Creating transaction...');
    const transaction = new window.solanaWeb3.Transaction().add(burnIx);
    transaction.feePayer = ownerPubkey;
    
    // Get latest blockhash using QuickNode endpoint
    console.log('ðŸ” Fetching latest blockhash...');
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
    transaction.recentBlockhash = blockhash;
    
    console.log('âœ… Transaction prepared:', {
      feePayer: transaction.feePayer.toString(),
      blockhash: blockhash.substring(0, 8) + '...',
      lastValidBlockHeight
    });
    
    // Sign transaction with wallet
    console.log('âœï¸ Requesting wallet signature...');
    let signedTransaction;
    try {
      signedTransaction = await selectedSolanaProvider.signTransaction(transaction);
      console.log('âœ… Transaction signed successfully');
    } catch (signError) {
      console.error('âŒ Transaction signing failed:', signError);
      if (signError.message?.includes('User rejected')) {
        showBurnSuccess('Transaction was cancelled by user.', true);
      } else {
        showBurnSuccess('Failed to sign transaction: ' + signError.message, true);
      }
      return;
    }
    
    // Send transaction using QuickNode endpoint
    console.log('ðŸ“¡ Sending transaction to Solana network...');
    let txid;
    try {
      txid = await connection.sendRawTransaction(signedTransaction.serialize(), {
        skipPreflight: false,
        preflightCommitment: 'confirmed',
        maxRetries: 3
      });
      console.log('âœ… Transaction sent successfully:', txid);
    } catch (sendError) {
      console.error('âŒ Transaction send failed:', sendError);
      showBurnSuccess('Failed to send transaction: ' + sendError.message, true);
      return;
    }
    
    // Show transaction hash copy modal instead of simple success message
    showTransactionHashModal(txid, 'solana');
    
    console.log('ðŸŽ‰ Solana token burn completed successfully:', {
      transaction: txid,
      amount: amount,
      tokenAddress: tokenAddress,
      fromAddress: correctAddress
    });
    
    // Update balance after successful burn
    setTimeout(() => {
      updateBalance();
    }, 2000);
    
  } catch (error) {
    console.error('âŒ Solana token burn failed:', error);
    console.error('âŒ Error details:', {
      message: error.message,
      code: error.code,
      stack: error.stack,
      name: error.name
    });
    
    let errorMsg = 'Burn failed: ';
    if (error && error.message) {
      if (error.message.includes('Insufficient funds')) {
        errorMsg += 'Insufficient SOL for transaction fees.';
      } else if (error.message.includes('Invalid public key')) {
        errorMsg += 'Invalid token or wallet address.';
      } else if (error.message.includes('User rejected')) {
        errorMsg += 'Transaction was cancelled by user.';
      } else if (error.message.includes('Network')) {
        errorMsg += 'Network error. Please try again.';
      } else {
        errorMsg += error.message;
      }
    } else {
      errorMsg += 'Unknown error occurred.';
    }
    
    showBurnSuccess(errorMsg, true);
  }
}

function showWalletManagementModal(walletCatalog) {
  const modal = document.createElement('div');
  modal.className = 'wallet-modal-overlay';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.2s ease-out;
  `;
  
  const metamaskCount = walletCatalog.metamask.length;
  const phantomCount = walletCatalog.phantom.length;
  const otherCount = walletCatalog.other.length;
  
  modal.innerHTML = `
    <div style="
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 2px solid #ff6b6b;
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(255, 107, 107, 0.3);
      max-width: 500px;
      width: 90vw;
      overflow: hidden;
    ">
      <div style="
        padding: 1.5rem;
        border-bottom: 1px solid rgba(255, 107, 107, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <h3 style="margin: 0; color: #ff6b6b; font-size: 1.25rem;">ðŸ”§ Wallet Management</h3>
        <button class="close-modal" style="
          background: none;
          border: none;
          color: #ff6b6b;
          font-size: 1.5rem;
          cursor: pointer;
        ">Ã—</button>
      </div>
      <div style="padding: 1.5rem; color: white;">
        <div style="margin-bottom: 1.5rem;">
          <h4 style="color: #00eaff; margin: 0 0 1rem 0;">ðŸ” Detected Wallets:</h4>
          <div style="background: #2a2a2a; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
            <p style="margin: 0.5rem 0;">
              ðŸ¦Š <strong>MetaMask:</strong> ${metamaskCount} provider${metamaskCount !== 1 ? 's' : ''} 
              ${metamaskCount > 0 ? 'âœ…' : 'âŒ'}
            </p>
            <p style="margin: 0.5rem 0;">
              ðŸ‘» <strong>Phantom:</strong> ${phantomCount} provider${phantomCount !== 1 ? 's' : ''} 
              ${phantomCount > 0 ? 'âš ï¸' : 'âœ…'}
            </p>
            <p style="margin: 0.5rem 0;">
              ðŸ”§ <strong>Other Wallets:</strong> ${otherCount} provider${otherCount !== 1 ? 's' : ''}
            </p>
          </div>
        </div>
        
        ${metamaskCount === 0 && otherCount === 0 ? `
          <div style="background: #3a1a1a; border: 1px solid #ff6b6b; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
            <p style="margin: 0 0 1rem 0; color: #ff6b6b; font-weight: bold;">
              âŒ No EVM Wallet Found
            </p>
            <p style="margin: 0 0 1rem 0;">
              Base token burning requires an EVM-compatible wallet. Please:
            </p>
            <ol style="margin: 0; padding-left: 1.2rem; color: #ffae00;">
              <li>Install a wallet (MetaMask, Coinbase Wallet, Trust Wallet, etc.)</li>
              <li>Refresh this page</li>
              <li>Try burning again</li>
            </ol>
          </div>
        ` : `
          <div style="background: #1a3a1a; border: 1px solid #00ff00; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
            <p style="margin: 0; color: #00ff00; font-weight: bold;">
              âœ… EVM Wallet Ready for Base Token Burning
            </p>
            <p style="margin: 0.5rem 0 0 0; font-size: 0.9em; color: #cccccc;">
              ${metamaskCount > 0 ? 'MetaMask detected' : otherCount > 0 ? 'EVM wallet detected' : 'Wallet ready'}
            </p>
          </div>
        `}
        
        ${phantomCount > 0 ? `
          <div style="background: #3a2a1a; border: 1px solid #ffae00; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
            <p style="margin: 0 0 1rem 0; color: #ffae00; font-weight: bold;">
              âš ï¸ Multiple Wallets Detected
            </p>
            <p style="margin: 0 0 1rem 0;">
              For best results with Base tokens:
            </p>
            <ol style="margin: 0; padding-left: 1.2rem;">
              <li>Temporarily disable Phantom extension</li>
              <li>Keep only your EVM wallet enabled (MetaMask, Coinbase, Trust Wallet, etc.)</li>
              <li>Refresh this page</li>
            </ol>
          </div>
        ` : ''}
        
        <div style="display: flex; gap: 0.75rem; margin-top: 1rem;">
          ${metamaskCount > 0 ? `
            <button class="continue-btn" style="
              flex: 1;
              padding: 0.75rem;
              border: 1px solid #00eaff;
              border-radius: 8px;
              background: transparent;
              color: #00eaff;
              cursor: pointer;
              font-weight: 500;
            ">Continue Anyway</button>
          ` : ''}
          <button class="refresh-btn" style="
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #ffae00;
            border-radius: 8px;
            background: transparent;
            color: #ffae00;
            cursor: pointer;
            font-weight: 500;
          ">Refresh Page</button>
          <button class="close-modal" style="
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #666;
            border-radius: 8px;
            background: transparent;
            color: #ccc;
            cursor: pointer;
            font-weight: 500;
          ">Cancel</button>
        </div>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Handle modal interactions
  modal.querySelectorAll('.close-modal').forEach(btn => {
    btn.addEventListener('click', () => {
      document.body.removeChild(modal);
    });
  });
  
  const continueBtn = modal.querySelector('.continue-btn');
  if (continueBtn) {
    continueBtn.addEventListener('click', () => {
      document.body.removeChild(modal);
      // Force proceed with available MetaMask (if any)
      console.log('ðŸ”„ User chose to continue with available wallets');
    });
  }
  
  modal.querySelector('.refresh-btn').addEventListener('click', () => {
    window.location.reload();
  });
  
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
}

// --- BURN SUCCESS/ERROR UI ---
function showBurnSuccess(msg, isError) {
  const el = document.getElementById('burnSuccess');
  el.innerHTML = msg;
  el.style.display = 'block';
  el.style.color = isError ? '#ff1a1a' : '#fffbe7';
  el.style.borderColor = isError ? '#ff1a1a' : '#ffae00';
  setTimeout(() => { el.style.display = 'none'; }, 6000);
}

function showBurnError(msg) {
  showBurnSuccess(msg, true);
}

// Show transaction hash copy modal
function showTransactionHashModal(txHash, network) {
  const modal = document.createElement('div');
  modal.className = 'wallet-modal-overlay';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.2s ease-out;
  `;
  
  const explorerUrl = network === 'solana' 
    ? `https://solscan.io/tx/${txHash}`
    : `https://basescan.org/tx/${txHash}`;
  
  const networkName = network === 'solana' ? 'Solana' : 'Base';
  
  modal.innerHTML = `
    <div class="modal-content" style="
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 2px solid #00ff00;
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
      max-width: 600px;
      width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      overflow: hidden;
      animation: bounceIn 0.4s ease-out;
    ">
      <div class="modal-header" style="
        padding: 1.5rem;
        border-bottom: 1px solid rgba(0, 255, 0, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <h3 style="margin: 0; color: #00ff00; font-size: 1.25rem;">ðŸ”¥ Token Burn Successful!</h3>
        <button class="close-modal" style="
          background: none;
          border: none;
          color: #00ff00;
          font-size: 1.5rem;
          cursor: pointer;
          transition: transform 0.2s;
        ">Ã—</button>
      </div>
      <div class="modal-body" style="padding: 1.5rem; color: white;">
        <div style="text-align: center; margin-bottom: 1.5rem;">
          <div class="success-icon" style="font-size: 3rem; margin-bottom: 0.5rem; animation: bounce 1s;">âœ…</div>
          <div style="color: #00ff00; font-size: 1.1rem; font-weight: bold; margin-bottom: 0.5rem;">
            Transaction Confirmed on ${networkName}
          </div>
          <div style="color: #ccc; font-size: 0.9rem;">
            Your tokens have been permanently burned
          </div>
        </div>
        
        <div class="tx-hash-container" style="background: #2a2a2a; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
          <div style="color: #ffae00; font-weight: bold; margin-bottom: 0.5rem;">Transaction Hash:</div>
          <div class="tx-hash-text" style="
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            word-break: break-all;
            line-height: 1.4;
            background: #1a1a1a;
            padding: 0.75rem;
            border-radius: 4px;
            border: 1px solid #444;
          ">${txHash}</div>
        </div>
        
        <div class="button-row" style="display: flex; gap: 0.75rem;">
          <button class="copy-hash-btn modal-button" style="
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #ffae00;
            border-radius: 8px;
            background: #ffae00;
            color: #000;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
          ">ðŸ“‹ Copy Transaction Hash</button>
          <button class="view-explorer-btn modal-button" style="
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #00eaff;
            border-radius: 8px;
            background: transparent;
            color: #00eaff;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
          ">ðŸ” View on Explorer</button>
        </div>
        
        <div style="text-align: center; margin-top: 1rem;">
          <button class="close-modal modal-button" style="
            padding: 0.5rem 1.5rem;
            border: 1px solid #666;
            border-radius: 8px;
            background: transparent;
            color: #ccc;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
          ">Close</button>
        </div>
      </div>
    </div>
    <style>
      @keyframes bounceIn {
        0% { opacity: 0; transform: scale(0.3); }
        50% { opacity: 1; transform: scale(1.05); }
        70% { transform: scale(0.9); }
        100% { opacity: 1; transform: scale(1); }
      }
      @keyframes bounce {
        0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
        40% { transform: translateY(-10px); }
        60% { transform: translateY(-5px); }
      }
      .close-modal:hover { transform: scale(1.1); }
      .copy-hash-btn:hover { background: #fff; transform: translateY(-2px); }
      .view-explorer-btn:hover { background: #00eaff; color: #000; transform: translateY(-2px); }
      
      /* Mobile-specific styles for better fit */
      @media (max-width: 768px) {
        .modal-content {
          width: 95vw !important;
          max-height: 80vh !important;
          margin: 10vh auto !important;
        }
        .modal-header {
          padding: 0.75rem !important;
        }
        .modal-header h3 {
          font-size: 1rem !important;
        }
        .modal-body {
          padding: 0.75rem !important;
        }
        .success-icon {
          font-size: 1.8rem !important;
          margin-bottom: 0.25rem !important;
        }
        .tx-hash-container {
          margin-bottom: 0.75rem !important;
          padding: 0.75rem !important;
        }
        .tx-hash-text {
          font-size: 0.7rem !important;
          padding: 0.5rem !important;
          line-height: 1.2 !important;
        }
        .button-row {
          flex-direction: column !important;
          gap: 0.5rem !important;
          margin-bottom: 0.5rem !important;
        }
        .modal-button {
          padding: 0.6rem !important;
          font-size: 0.85rem !important;
        }
      }
      
      /* Extra small screens */
      @media (max-width: 480px) {
        .modal-content {
          width: 98vw !important;
          max-height: 75vh !important;
          margin: 12.5vh auto !important;
        }
        .modal-header {
          padding: 0.5rem !important;
        }
        .modal-header h3 {
          font-size: 0.9rem !important;
        }
        .modal-body {
          padding: 0.5rem !important;
        }
        .success-icon {
          font-size: 1.5rem !important;
        }
        .tx-hash-container {
          padding: 0.5rem !important;
          margin-bottom: 0.5rem !important;
        }
        .tx-hash-text {
          font-size: 0.65rem !important;
          padding: 0.4rem !important;
        }
        .modal-button {
          padding: 0.5rem !important;
          font-size: 0.8rem !important;
        }
      }
    </style>
  `;
  
  document.body.appendChild(modal);
  
  // Handle copy hash button
  modal.querySelector('.copy-hash-btn').addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(txHash);
      const btn = modal.querySelector('.copy-hash-btn');
      const originalText = btn.textContent;
      btn.textContent = 'âœ… Copied!';
      btn.style.background = '#00ff00';
      setTimeout(() => {
        btn.textContent = originalText;
        btn.style.background = '#ffae00';
      }, 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
      // Fallback: select the text
      const hashElement = modal.querySelector('div[style*="font-family: \'Courier New\'"]');
      const range = document.createRange();
      range.selectNodeContents(hashElement);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    }
  });
  
  // Handle view explorer button
  modal.querySelector('.view-explorer-btn').addEventListener('click', () => {
    window.open(explorerUrl, '_blank');
  });
  
  // Handle close buttons
  modal.querySelectorAll('.close-modal').forEach(btn => {
    btn.addEventListener('click', () => {
      document.body.removeChild(modal);
    });
  });
  
  // Handle click outside to close
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
}

// --- ACCOUNT CHECK FUNCTIONALITY ---
function checkAccountMismatch() {
  if (currentChain === 'base' && currentAddress && window.wildWestWallet?.account) {
    const walletAccount = window.wildWestWallet.account.toLowerCase();
    const currentAccount = currentAddress.toLowerCase();
    
    const mismatchWarning = document.getElementById('accountMismatchWarning');
    if (walletAccount !== currentAccount && mismatchWarning) {
      mismatchWarning.style.display = 'block';
      
      // Add click handler for the check account button
      const checkBtn = document.getElementById('checkAccountBtn');
      if (checkBtn) {
        checkBtn.onclick = () => showAccountCheckModal();
      }
    } else if (mismatchWarning) {
      mismatchWarning.style.display = 'none';
    }
  }
}

function showAccountCheckModal() {
  const modal = document.createElement('div');
  modal.className = 'wallet-modal-overlay';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.2s ease-out;
  `;
  
  modal.innerHTML = `
    <div style="
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 2px solid #ffae00;
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(255, 174, 0, 0.3);
      max-width: 600px;
      width: 90vw;
      overflow: hidden;
    ">
      <div style="
        padding: 1.5rem;
        border-bottom: 1px solid rgba(255, 174, 0, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <h3 style="margin: 0; color: #ffae00; font-size: 1.25rem;">MetaMask Account Check</h3>
        <button class="close-modal" style="
          background: none;
          border: none;
          color: #ffae00;
          font-size: 1.5rem;
          cursor: pointer;
        ">Ã—</button>
      </div>
      <div style="padding: 1.5rem; color: white;">
        <div style="background: #2a2a2a; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
          <p style="margin: 0 0 0.5rem 0; font-weight: bold; color: #00eaff;">ðŸ” Account Status:</p>
          <div style="margin: 0.5rem 0;">
            <strong style="color: #ffae00;">Tokens found in:</strong><br>
            <code style="background: #333; padding: 4px 8px; border-radius: 4px; color: #00ff00; word-break: break-all; font-size: 0.9em;">${window.wildWestWallet?.account || 'Unknown'}</code>
          </div>
          <div style="margin: 0.5rem 0;">
            <strong style="color: #ff6b6b;">Currently selected:</strong><br>
            <code style="background: #333; padding: 4px 8px; border-radius: 4px; color: #ff9999; word-break: break-all; font-size: 0.9em;">${currentAddress || 'Unknown'}</code>
          </div>
        </div>
        
        <div style="background: #1a2a1a; padding: 1rem; border-radius: 8px; border: 1px solid #ffae00; margin: 1rem 0;">
          <p style="margin: 0 0 0.5rem 0; font-weight: bold; color: #ffae00;">ðŸ“‹ How to switch accounts in MetaMask:</p>
          <ol style="margin: 0.5rem 0; padding-left: 1.2rem; line-height: 1.6;">
            <li><strong>Open MetaMask extension</strong> (click the fox icon)</li>
            <li><strong>Click the account circle/name</strong> at the top center</li>
            <li><strong>Select the account</strong> ending in <strong style="color: #ffae00;">...${(window.wildWestWallet?.account || '').slice(-4)}</strong></li>
            <li><strong>Refresh this page</strong> and reconnect</li>
          </ol>
        </div>
        
        <div style="display: flex; gap: 0.75rem; margin-top: 1rem;">
          <button class="refresh-btn" style="
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #00eaff;
            border-radius: 8px;
            background: transparent;
            color: #00eaff;
            cursor: pointer;
            font-weight: 500;
          ">Refresh Page</button>
          <button class="close-modal" style="
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #666;
            border-radius: 8px;
            background: transparent;
            color: #ccc;
            cursor: pointer;
            font-weight: 500;
          ">Close</button>
        </div>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Handle modal interactions
  modal.querySelectorAll('.close-modal').forEach(btn => {
    btn.addEventListener('click', () => {
      document.body.removeChild(modal);
    });
  });
  
  modal.querySelector('.refresh-btn').addEventListener('click', () => {
    window.location.reload();
  });
  
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
}

// --- INIT: clear state on load ---
window.addEventListener('DOMContentLoaded', function() {
  currentChain = null;
  currentAddress = null;
  currentProvider = null;
  document.getElementById('walletBtnText').textContent = 'Connect Wallet';
  document.getElementById('connectWalletBtn').classList.remove('connected');
  document.getElementById('tokenBalance').textContent = '';
  
  // Add real-time token address validation
  const tokenAddressInput = document.getElementById('tokenAddress');
  const validationElement = document.getElementById('addressValidation');
  
  if (tokenAddressInput && validationElement) {
    tokenAddressInput.addEventListener('input', function() {
      const address = this.value.trim();
      
      if (!address) {
        validationElement.style.display = 'none';
        this.style.borderColor = '';
        return;
      }
      
      // Auto-detect token type and show appropriate validation
      const detectedType = detectTokenType(address);
      
      if (detectedType === 'base') {
        // Valid Base (EVM) token address
        validationElement.textContent = 'ðŸ”µ Base Network Token Detected';
        validationElement.style.color = '#00eaff';
        validationElement.style.display = 'block';
        this.style.borderColor = '#00eaff';
      } else if (detectedType === 'solana') {
        // Valid Solana token address
        validationElement.textContent = 'ðŸŸ£ Solana Network Token Detected';
        validationElement.style.color = '#9945ff';
        validationElement.style.display = 'block';
        this.style.borderColor = '#9945ff';
      } else {
        // Invalid address - show specific error
        if (address.length === 0) {
          validationElement.style.display = 'none';
          this.style.borderColor = '';
        } else if (address.match(/^0x/) && address.length < 42) {
          validationElement.textContent = `âŒ Base address too short (${address.length}/42 characters)`;
          validationElement.style.color = '#ff0000';
          validationElement.style.display = 'block';
          this.style.borderColor = '#ff0000';
        } else if (address.match(/^0x/) && address.length > 42) {
          validationElement.textContent = `âŒ Base address too long (${address.length}/42 characters)`;
          validationElement.style.color = '#ff0000';
          validationElement.style.display = 'block';
          this.style.borderColor = '#ff0000';
        } else if (address.match(/^0x/) && !address.match(/^0x[a-fA-F0-9]{40}$/)) {
          validationElement.textContent = 'âŒ Invalid Base address (use 0-9, a-f, A-F only)';
          validationElement.style.color = '#ff0000';
          validationElement.style.display = 'block';
          this.style.borderColor = '#ff0000';
        } else if (address.length < 32 || address.length > 44) {
          validationElement.textContent = 'âŒ Invalid address length (Base: 42 chars, Solana: 32-44 chars)';
          validationElement.style.color = '#ff0000';
          validationElement.style.display = 'block';
          this.style.borderColor = '#ff0000';
        } else {
          validationElement.textContent = 'âŒ Invalid address format';
          validationElement.style.color = '#ff0000';
          validationElement.style.display = 'block';
          this.style.borderColor = '#ff0000';
        }
      }
    });
  }
});
    </script>
    <!-- --- BURN ALL BUTTON LOGIC --- -->
    <script>
document.getElementById('burnAllBtn').addEventListener('click', async function() {
  const tokenAddress = document.getElementById('tokenAddress').value.trim();
  
  if (!tokenAddress) {
    showBurnSuccess('Enter a token address first.', true);
    return;
  }
  
  // Auto-detect token type
  const tokenType = detectTokenType(tokenAddress);
  console.log('ðŸ” Burn All - Detected token type:', tokenType);
  
  if (tokenType === 'base') {
    // Base (EVM) token
    if (!await safeLoad(loadEthers)) return;
    
    // Check if we have EVM wallet connection
    let addressToUse = null;
    if (window.wildWestWallet?.account) {
      addressToUse = window.wildWestWallet.account;
    } else if (currentAddress && (currentChain === 'base' || currentChain === 'ethereum')) {
      addressToUse = currentAddress;
    } else if (window.ethereum?.selectedAddress) {
      addressToUse = window.ethereum.selectedAddress;
    }
    
    if (!addressToUse) {
      showBurnSuccess('Connect EVM wallet to burn Base tokens.', true);
      return;
    }
    
    try {
      // Always use QuickNode endpoint for better reliability
      const provider = new window.ethers.providers.JsonRpcProvider(BASE_RPC);
      const erc20 = new window.ethers.Contract(tokenAddress, [
        'function balanceOf(address) view returns (uint256)',
        'function decimals() view returns (uint8)'
      ], provider);
      const [bal, dec] = await Promise.all([
        erc20.balanceOf(addressToUse),
        erc20.decimals()
      ]);
      const display = window.ethers.utils.formatUnits(bal, dec);
      document.getElementById('tokenAmount').value = display;
    } catch (e) {
      showBurnSuccess('Unable to fetch balance for Burn All.', true);
    }
    
  } else if (tokenType === 'solana') {
    // Solana token
    if (!await safeLoad(loadSolanaWeb3)) return;
    if (!await safeLoad(loadBN)) return;
    
    // Check if we have Solana wallet connection
    let addressToUse = null;
    if (currentChain === 'solana' && currentAddress) {
      addressToUse = currentAddress;
    } else if (window.solana?.publicKey) {
      addressToUse = window.solana.publicKey.toString();
    } else if (window.phantom?.solana?.publicKey) {
      addressToUse = window.phantom.solana.publicKey.toString();
    }
    
    if (!addressToUse) {
      showBurnSuccess('Connect Solana wallet to burn Solana tokens.', true);
      return;
    }
    
    try {
      // Use the initialized RPC endpoint
      const connection = new window.solanaWeb3.Connection(SOLANA_RPC);
      const mintPubkey = new window.solanaWeb3.PublicKey(tokenAddress);
      const ownerPubkey = new window.solanaWeb3.PublicKey(addressToUse);
      const tokenAccounts = await connection.getTokenAccountsByOwner(ownerPubkey, { mint: mintPubkey });
      if (tokenAccounts.value.length === 0) {
        document.getElementById('tokenAmount').value = '0';
        return;
      }
      const accountInfo = await connection.getParsedAccountInfo(tokenAccounts.value[0].pubkey);
      const bal = accountInfo.value.data.parsed.info.tokenAmount.uiAmountString;
      document.getElementById('tokenAmount').value = bal;
    } catch (e) {
      showBurnSuccess('Unable to fetch balance for Burn All.', true);
    }
    
  } else {
    showBurnSuccess('Invalid token address. Please enter a valid Base (0x...) or Solana token address.', true);
  }
});

// Debug function to force reload production config from deployed site
window.forceLoadProductionConfig = async function() {
  console.log('ðŸ”„ Force loading production config from deployed site...');
  try {
    const response = await fetch('https://wildwestlaunch.xyz/js/production-config.js?t=' + Date.now());
    const configScript = await response.text();
    
    // Clear existing config
    delete window.PRODUCTION_CONFIG;
    
    // Execute the fresh config
    eval(configScript);
    
    console.log('âœ… Production config force loaded:', window.PRODUCTION_CONFIG);
    
    // Re-initialize RPC endpoints
    initializeRPCEndpoints();
    
    return window.PRODUCTION_CONFIG;
  } catch (error) {
    console.error('âŒ Failed to force load production config:', error);
    return null;
  }
};

// Development QuickNode override function
window.useQuickNodeForDev = function() {
  console.log('ï¿½ Setting up QuickNode endpoints for development testing...');
  
  // Temporarily inject QuickNode endpoints for development
  window.PRODUCTION_CONFIG = {
    rpc: {
      solana: 'https://withered-divine-spring.solana-mainnet.quiknode.pro/0ac83d6b4ecf2a8fa8d0a6894210ede33b1b7495/',
      base: 'https://responsive-omniscient-model.base-mainnet.quiknode.pro/d9b8b93b1b8b7cc6b8993c4ef5c6e7a70a6e9ad8/'
    },
    source: 'development-override'
  };
  
  console.log('âœ… QuickNode endpoints injected for development:', window.PRODUCTION_CONFIG);
  
  // Reinitialize RPC endpoints
  initializeRPCEndpoints();
  
  console.log('ðŸ’¡ Now try your token operations - they will use QuickNode endpoints!');
  
  // Update balance if there's a token address
  const tokenAddress = document.getElementById('tokenAddress')?.value;
  if (tokenAddress) {
    updateBalance();
  }
};

console.log('ï¿½ðŸ’¡ Token Furnace Debug functions available:');
console.log('â€¢ forceLoadProductionConfig() - Force reload config from deployed site');
console.log('â€¢ useQuickNodeForDev() - Use QuickNode endpoints in development mode');
    </script>

    <!-- Copyright Footer -->
    <footer style="
      background: linear-gradient(135deg, rgba(255, 26, 26, 0.1) 0%, rgba(0, 0, 0, 0.8) 100%);
      border-top: 1px solid rgba(255, 174, 0, 0.3);
      padding: 2rem 1rem;
      text-align: center;
      margin-top: 4rem;
      color: #fffbe7;
      font-family: 'Orbitron', Arial, sans-serif;
      font-size: 0.9rem;
      text-shadow: 0 0 4px #000, 0 0 2px #ffae00;
    ">
      <div style="max-width: 1200px; margin: 0 auto;">
        <div style="margin-bottom: 1rem;">
          <span style="color: #ffae00; font-weight: 600; font-size: 1.1rem; text-shadow: 0 0 8px #ffae00;">WILDWEST LAUNCHPAD</span>
        </div>
        
        <!-- Social Media Links -->
        <div style="margin-bottom: 1rem;">
          <a href="https://t.me/wildwestlaunchpad" target="_blank" style="
            background: linear-gradient(135deg, #0088cc, #00aaff);
            color: #ffffff;
            text-decoration: none;
            margin: 0 0.5rem;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            display: inline-block;
            border: 1px solid rgba(255,255,255,0.2);
          ">
            TELEGRAM
          </a>
          <a href="https://x.com/WILDWESTLP?t=RI3IQU3KASjN3Ak-yrfZnw&s=09" target="_blank" style="
            background: linear-gradient(135deg, #1da1f2, #0d8bd9);
            color: #ffffff;
            text-decoration: none;
            margin: 0 0.5rem;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            display: inline-block;
            border: 1px solid rgba(255,255,255,0.2);
          ">
            X
          </a>
        </div>
        
        <!-- $WILDW Token Contract Address -->
        <div style="margin-bottom: 1rem; font-size: 0.85rem;">
          <div style="margin-bottom: 0.5rem;">
            <span style="color: #ff6b35; font-weight: 600; text-shadow: 0 0 4px #ff6b35;">$WILDW TOKEN (BASE):</span>
          </div>
          <span style="color: #fffbe7; font-family: 'Courier New', monospace; word-break: break-all; background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 4px;">
            0x8129609E5303910464FCe3022a809fA44455Fe9A
          </span>
        </div>
        
        <div style="margin-bottom: 0.5rem;">
          Â© 2025 Wild West Launchpad. All rights reserved.
        </div>
      </div>
    </footer>
  </body>
</html>
