<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BASE TOKEN LOCKING</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

    <link rel="stylesheet" href="../css/styles.css">


    <!-- Mark that we're handling the wallet button ourselves -->
    <script>
        window.BASE_LAUNCH_HANDLES_WALLET_BUTTON = true;

        // AGGRESSIVE ANTI-AUTO-CONNECTION: Block all wallet property access until user clicks connect
        window.WALLET_AUTO_CONNECTION_BLOCKED = true;
        console.log('🚫 Base launch page: Wallet auto-connection globally blocked until user interaction');
    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            background: var(--panel);
            min-height: 100vh;
            color: #f8fafc;
            margin: 0;
            padding: 16px;
            line-height: 1.6;
            text-align: center;
            font-weight: 400;
            background-attachment: fixed;
        }


        /* Tweak these if you like */
        :root {
            --panel-max-width: 420px;
            /* overall width of the vertical panel */
            --wallet-strip-gap: 1.5rem;
            /* vertical spacing between items */
            --wallet-strip-radius: 12px;
            /* corner radius on images */
            --wallet-strip-hover-scale: 1.03;
            /* how much they grow on hover/focus */
            --shadow: 0 2px 8px rgba(0, 0, 0, .25);
            --shadow-hover: 0 8px 20px rgba(0, 0, 0, .35);
        }

        /* Vertical panel container */
        .link-panel {
            max-width: var(--panel-max-width);
            margin-inline: auto;
            /* center horizontally on the page */
            display: flex;
            flex-direction: column;
            gap: var(--wallet-strip-gap);
        }

        /* Each clickable image */
        .panel-item {
            display: block;
            width: 100%;
            border-radius: var(--wallet-strip-radius);
            border: 0px solid var(--light-blue-60);
            background-color: var(--panel);
            overflow: hidden;
            box-shadow: var(--shadow);
            transform: translateZ(0);
            /* prevents hover jank on some GPUs */
            transition: transform 160ms ease, box-shadow 160ms ease, filter 160ms ease;
            box-shadow: 0 0 4px var(--light-blue-60);
        }

        /* Keep all items the same visual height with cropping */
        .panel-item img {
            display: block;
            width: 100%;
            aspect-ratio: 35 / 10;
            /* uniform landscape slot */
            object-fit: cover;
        }

        /* Feedback on hover & keyboard focus */
        .panel-item:hover,
        .panel-item:focus-visible {
            transform: scale(var(--wallet-strip-hover-scale));
            box-shadow: var(--shadow-hover);
            box-shadow: 0 0 8px var(--light-blue);
        }

        /* Respect reduced motion preferences */
        @media (prefers-reduced-motion: reduce) {
            .panel-item {
                transition: none;
            }
        }




        /* Override centering for specific elements that need left alignment */
        .form-input,
        input,
        textarea,
        select {
            text-align: left;
        }

        .page-wrapper {
            max-width: 1200px;
            margin: 0 auto;
            padding-top: 60px;
        }

        .main-header {
            text-align: center;
            margin-bottom: 48px;
            position: relative;
        }

        .main-header::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 4px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #06b6d4);
            border-radius: 2px;
            animation: headerGlow 3s ease-in-out infinite alternate;
        }

        @keyframes headerGlow {
            from {
                box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            }

            to {
                box-shadow: 0 0 40px rgba(139, 92, 246, 0.8);
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes cardPulse {

            0%,
            100% {
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08), 0 4px 8px rgba(0, 0, 0, 0.12);
            }

            50% {
                box-shadow: 0 12px 35px rgba(102, 126, 234, 0.15), 0 6px 12px rgba(118, 75, 162, 0.2);
            }
        }

        .main-header h1 {
            font-size: 2.75rem;
            font-weight: 800;
            margin: 0 0 12px 0;
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 50%, #06b6d4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 30px rgba(59, 130, 246, 0.3);
        }

        .main-header p {
            font-size: 1.1rem;
            color: #94a3b8;
            margin: 0;
            font-weight: 500;
            opacity: 0.9;
        }

        .card {
            background: var(--dark-violet-60);
            border: 1px solid rgba(148, 163, 184, 0.15);
            border-radius: 20px;
            padding: 32px;
            margin-bottom: 32px;
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            width: 100%;
            max-width: none;
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--pink), var(--violet), var(--mid-blue));
            opacity: 0.8;
        }

        :root {
            --neon: #00eaff;
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--pink) 0%, var(--mid-blue) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            position: relative;
            padding-bottom: 12px;
        }

        .card-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 2px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            border-radius: 1px;
        }

        /* Token Card Specific Styles */
        .token-card {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform;
        }

        .token-card:hover {
            transform: translateY(-4px) scale(1.02);
        }

        .token-icon {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            animation: iconPulse 2s ease-in-out infinite alternate;
        }

        @keyframes iconPulse {
            from {
                box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.3);
            }

            to {
                box-shadow: 0 0 0 8px rgba(102, 126, 234, 0.1);
            }
        }

        .status-badge {
            animation: statusBadgeGlow 3s ease-in-out infinite;
        }

        @keyframes statusBadgeGlow {

            0%,
            100% {
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            50% {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2), 0 0 8px rgba(255, 255, 255, 0.1);
            }
        }

        .contract-address {
            transition: all 0.2s ease;
        }

        .contract-address:hover {
            transform: scale(1.05);
            background: #f0f4ff !important;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        @media (max-width: 768px) {
            .info-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .token-card {
                padding: 16px;
                margin-bottom: 12px;
            }
        }

        .form-group {
            margin-bottom: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .form-label {
            display: block;
            font-size: 0.9rem;
            font-weight: 600;
            color: #a0a8b8;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            text-align: center;
        }

        .form-input {
            width: 100%;
            padding: 16px 20px;
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            color: #f8fafc;
            font-size: 1rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            position: relative;
        }

        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            background: rgba(15, 23, 42, 0.95);
            box-shadow:
                0 0 0 4px rgba(59, 130, 246, 0.1),
                0 8px 25px rgba(59, 130, 246, 0.15);
            transform: translateY(-1px);
        }

        .form-input::placeholder {
            color: #6b7280;
        }

        /* Breathtaking Button Animation System */
        .btn {
            background: linear-gradient(135deg, #0070f3, #0051cc, #003d99);
            background-size: 300% 300%;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 14px 20px;
            font-family: var(--font-ui);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-transform: uppercase;
            width: 100%;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
            animation: gradientShift 4s ease infinite;
            box-shadow: 0 4px 15px rgba(0, 112, 243, 0.3);
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.01);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #0080ff, #0066e6, #004db3);
            background-size: 300% 300%;
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 12px 35px rgba(0, 112, 243, 0.5), 0 0 30px rgba(0, 112, 243, 0.3);
            animation: gradientShift 2s ease infinite, pulse 1.5s ease infinite;
        }

        .btn:hover:not(:disabled)::before {
            left: 100%;
        }

        .btn:active:not(:disabled) {
            transform: translateY(-1px) scale(0.98);
            transition: all 0.1s ease;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            animation: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #1e40af, #1e3a8a, #1d4ed8);
            background-size: 300% 300%;
            box-shadow: 0 4px 15px rgba(30, 64, 175, 0.3);
        }

        .btn-secondary:hover:not(:disabled) {
            background: linear-gradient(135deg, #3b82f6, #2563eb, #1d4ed8);
            background-size: 300% 300%;
            box-shadow: 0 12px 35px rgba(30, 64, 175, 0.5), 0 0 30px rgba(30, 64, 175, 0.3);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #0070f3;
            color: #0070f3;
            box-shadow: 0 4px 15px rgba(0, 112, 243, 0.2);
            animation: none;
        }

        .btn-outline:hover:not(:disabled) {
            background: linear-gradient(135deg, #0070f3, #0051cc);
            background-size: 300% 300%;
            color: white;
            border-color: transparent;
            animation: gradientShift 3s ease infinite;
            box-shadow: 0 12px 35px rgba(0, 112, 243, 0.4);
        }

        /* Subtle animations for connected wallet button */
        .btn[style*="00c851"] {
            background: linear-gradient(135deg, #0070f3, #00c851, #0051cc) !important;
            background-size: 200% 200% !important;
            animation: gradientShift 8s ease infinite !important;
        }

        .btn-group {
            display: flex;
            gap: 12px;
            margin: 16px 0;
            flex-wrap: wrap;
            align-items: stretch;
        }

        .btn-group .btn {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            letter-spacing: 0.2rem;
        }

        /* Two-column button layout */
        .btn-group-2 .btn {
            flex: 0 0 calc(50% - 6px);
        }

        /* When a button in a 2-group is hidden, make the visible one full width */
        .btn-group-2 .btn:only-child {
            flex: 0 0 100%;
        }

        /* Three-column button layout */
        .btn-group-3 .btn {
            flex: 0 0 calc(33.333% - 8px);
        }

        /* Full-width button layout */
        .btn-group-full .btn {
            flex: 0 0 100%;
        }

        .status {
            padding: 12px 16px;
            border-radius: 10px;
            margin: 12px 0;
            font-weight: 500;
            text-align: center;
            font-size: 0.9rem;
        }

        .status-info {
            border: 0px solid rgba(255, 0, 0, 0.745);
            color: var(--panel);
            font-weight: bold;
            background: var(--yellow);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);

        }

        .status-success {
            background: rgba(34, 197, 94, 0.1);
            border: 1px var(--yellow-60);
            color: var(--yellow);
        }

        .status-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
        }

        .balance-display {
            background: rgba(15, 19, 24, 0.6);
            padding: 16px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(108, 140, 255, 0.2);
        }

        .balance-amount {
            font-size: 1.2rem;
            font-weight: 600;
            color: #6c8cff;
            margin-bottom: 4px;
        }

        .balance-label {
            font-size: 0.8rem;
            color: #a0a8b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 16px 0;
        }

        .info-item {
            background: rgba(15, 19, 24, 0.4);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid rgba(108, 140, 255, 0.1);
            text-align: center;
        }

        .info-label {
            font-size: 0.75rem;
            color: #a0a8b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 0.9rem;
            color: #e6eaf3;
            font-weight: 500;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 16px;
        }

        th,
        td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid rgba(108, 140, 255, 0.1);
            font-size: 0.85rem;
        }

        th {
            background: rgba(15, 19, 24, 0.6);
            color: #6c8cff;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            body {
                padding: 16px;
                font-size: 14px;
            }

            .page-wrapper {
                padding-top: 60px;
                max-width: none;
            }

            .main-header {
                margin-bottom: 32px;
            }

            .main-header h1 {
                font-size: 1.6rem;
                line-height: 1.3;
                word-break: normal;
                margin-bottom: 16px;
            }

            .main-header p {
                font-size: 0.9rem;
                line-height: 1.4;
            }

            .card {
                padding: 20px;
                border-radius: 16px;
                margin-bottom: 24px;
            }

            .card-title {
                font-size: 1rem;
                line-height: 1.4;
                word-break: normal;
                margin-bottom: 20px;
            }

            .btn-group {
                gap: 12px;
                margin: 20px 0;
            }

            .btn-group-2 .btn,
            .btn-group-3 .btn {
                flex: 0 0 100%;
                margin-bottom: 12px;
            }

            .btn-group-2 .btn:last-child,
            .btn-group-3 .btn:last-child {
                margin-bottom: 0;
            }

            .btn-group .btn {
                min-height: 48px;
                font-size: 0.85rem;
                padding: 14px 18px;
                line-height: 1.3;
            }

            .btn {
                font-size: 0.85rem;
                padding: 14px 18px;
                line-height: 1.3;
                min-height: 48px;
            }

            /* Stack cards vertically on mobile */
            .grid-2 {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            #backToMainBtn {
                top: 12px;
                right: 12px;
                font-size: 0.75rem;
                padding: 6px 10px;
                white-space: nowrap;
            }

            .form-input {
                font-size: 16px;
                /* Prevents zoom on iOS */
                line-height: 1.4;
                padding: 14px 16px;
                margin-bottom: 4px;
                font-family: var(--font-ui);
            }

            .form-label {
                font-size: 0.85rem;
                margin-bottom: 8px;
                font-family: var(--font-ui);
            }

            .form-group {
                margin-bottom: 24px;
                font-family: var(--font-ui);
            }

            .status {
                font-size: 0.85rem;
                line-height: 1.4;
                text-align: left;
                word-break: normal;
                padding: 14px 16px;
                margin: 16px 0;
            }

            .balance-display {
                padding: 16px;
                margin: 16px 0;
            }

            .balance-amount {
                font-size: 1.1rem;
                margin-bottom: 6px;
            }

            .balance-label {
                font-size: 0.75rem;
            }

            /* Better text handling */
            p,
            div,
            span {
                word-break: normal;
                overflow-wrap: break-word;
                hyphens: auto;
            }

            /* Address and hash specific styling */
            .address-text,
            .hash-text {
                font-size: 0.65rem;
                word-break: break-all;
                overflow-wrap: anywhere;
            }

            /* Specific mobile sizing for token lists */
            #myTokensList,
            #allTokensList {
                font-size: 0.75rem;
                line-height: 1.3;
                padding: 8px;
                max-height: 350px;
            }

            table {
                font-size: 0.75rem;
                margin: 12px 0;
            }

            th,
            td {
                padding: 8px 6px;
                font-size: 0.75rem;
            }

            /* Mobile price status */
            #priceStatus {
                font-size: 0.8rem;
            }

            /* Mobile notification adjustments */
            #statusContainer {
                top: 10px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                width: 95% !important;
                max-width: 350px !important;
            }

            /* Creator Token Cards Mobile Styling */
            .token-card {
                margin-bottom: 16px !important;
                padding: 20px !important;
                border-radius: 12px !important;
            }

            /* Contract Address Section Mobile Centering */
            .token-card .contract-address {
                text-align: center !important;
                margin: 0 auto !important;
                min-width: unset !important;
                word-break: break-all !important;
                font-size: 0.75rem !important;
                padding: 10px 12px !important;
            }

            /* Mobile Contract Address Container */
            .token-card div[style*="flex-wrap: wrap"] {
                flex-direction: column !important;
                align-items: center !important;
                gap: 12px !important;
            }

            /* Explore Button Mobile */
            .token-card a[href*="basescan.org"] {
                align-self: center !important;
                font-size: 0.75rem !important;
                padding: 10px 20px !important;
            }

            /* Info Grid Mobile - Stack Vertically */
            .info-grid {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
                margin: 16px 0 !important;
            }

            /* Token Card Header Mobile */
            .token-card div[style*="display: flex; justify-content: space-between"] {
                flex-direction: column !important;
                align-items: center !important;
                text-align: center !important;
                gap: 12px !important;
                margin-bottom: 16px !important;
            }

            /* Status Badge Mobile */
            .token-card .status-badge {
                font-size: 0.75rem !important;
                padding: 6px 12px !important;
            }

            /* Token Name Mobile */
            .token-card div[style*="font-weight: 800"] {
                font-size: 1.1rem !important;
                text-align: center !important;
            }

            /* Token Symbol Mobile */
            .token-card div[style*="color: #718096"] {
                text-align: center !important;
                font-size: 0.85rem !important;
            }
        }

        /* Additional mobile optimizations for smaller screens */
        @media (max-width: 480px) {
            .token-card {
                padding: 16px !important;
                margin-bottom: 12px !important;
            }

            .token-card .contract-address {
                font-size: 0.7rem !important;
                padding: 8px 10px !important;
            }

            .token-card a[href*="basescan.org"] {
                font-size: 0.7rem !important;
                padding: 8px 16px !important;
            }

            .info-grid>div {
                padding: 16px !important;
            }

            .token-card div[id*="fees-section"] {
                padding: 18px !important;
            }
        }

        /* Mobile token management section spacing */
        @media (max-width: 768px) {
            #tokenManagementSection {
                margin-top: 30px !important;
                gap: 24px !important;
            }

            /* Mobile token cards improvements */
            #myTokensCard,
            #adminTokensCard {
                padding: 20px !important;
            }

            /* Mobile token list container */
            #myTokensList {
                padding: 12px !important;
                border-radius: 12px;
                background: rgba(15, 19, 24, 0.3);
                border: 1px solid rgba(108, 140, 255, 0.1);
            }
        }

        /* Professional Enhancement Styles */
        .page-wrapper {
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Enhanced Loading States */
        .loading-shimmer {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            background-size: 200% 100%;
            animation: shimmerEffect 1.5s infinite;
        }

        @keyframes shimmerEffect {
            0% {
                background-position: -200% 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        /* Premium Status Indicators */
        .status-success {
            background: linear-gradient(135deg, #10b981, #059669);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .status-error {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }

        /* Elegant Balance Display */
        .balance-display {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .balance-display::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
            transition: left 0.5s;
        }

        .balance-display:hover::before {
            left: 100%;
        }

        .balance-display:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .balance-amount {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f8fafc;
            margin-bottom: 4px;
        }

        .balance-label {
            font-size: 0.85rem;
            color: #94a3b8;
            font-weight: 500;
        }

        /* Refined Grid Layouts */
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 32px;
            margin-bottom: 32px;
        }

        @media (max-width: 968px) {
            .grid-2 {
                grid-template-columns: 1fr;
                gap: 24px;
            }
        }

        /* Premium Form Labels */
        .form-label {
            display: block;
            font-size: 0.9rem;
            font-weight: 600;
            color: #94a3b8;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
            position: relative;
        }

        /* Enhanced Back Button */
        #backToMainBtn {
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #backToMainBtn:hover {
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        /* Tablet and larger */
        @media (min-width: 769px) {
            .page-wrapper {
                padding: 100px 32px 40px 32px;
            }

            .main-header h1 {
                font-size: 2.5rem;
            }

            .btn-group {
                flex-direction: row;
            }

            .info-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }

            .layout-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 32px;
                align-items: start;
            }
        }

        /* Desktop */
        @media (min-width: 1024px) {
            .main-header h1 {
                font-size: 2.8rem;
            }

            .card {
                padding: 28px;
            }
        }

        /* Hide elements initially */
        [style*="display:none"],
        [style*="display: none"] {
            display: none !important;
        }

        /* Content containment fixes */
        .card-content {
            overflow: hidden;
            word-wrap: break-word;
            max-width: 100%;
        }

        #myTokensList,
        #allTokensList {
            overflow-x: auto;
            overflow-y: auto;
            max-height: 400px;
            word-wrap: break-word;
            word-break: break-all;
            white-space: normal;
            line-height: 1.4;
            scrollbar-width: thin;
            scrollbar-color: rgba(108, 140, 255, 0.3) transparent;
        }

        #myTokensList::-webkit-scrollbar,
        #allTokensList::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        #myTokensList::-webkit-scrollbar-track,
        #allTokensList::-webkit-scrollbar-track {
            background: rgba(15, 19, 24, 0.4);
            border-radius: 3px;
        }

        #myTokensList::-webkit-scrollbar-thumb,
        #allTokensList::-webkit-scrollbar-thumb {
            background: rgba(108, 140, 255, 0.3);
            border-radius: 3px;
        }

        #myTokensList::-webkit-scrollbar-thumb:hover,
        #allTokensList::-webkit-scrollbar-thumb:hover {
            background: rgba(108, 140, 255, 0.5);
        }

        /* Loading spinner animation */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e2e8f0;
            border-top: 2px solid #0ea5e9;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Table containment */
        .token-table {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            margin: 8px 0;
        }

        .token-table th,
        .token-table td {
            padding: 8px 6px;
            text-align: left;
            border-bottom: 1px solid rgba(108, 140, 255, 0.1);
            font-size: 0.75rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .token-table th {
            background: rgba(15, 19, 24, 0.6);
            color: #6c8cff;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* Mobile table adjustments */
        @media (max-width: 768px) {

            #myTokensList,
            #allTokensList {
                max-height: 280px;
                font-size: 0.7rem;
                line-height: 1.2;
                word-break: break-all;
                overflow-wrap: anywhere;
            }

            .token-table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }

            .token-table thead,
            .token-table tbody,
            .token-table th,
            .token-table td,
            .token-table tr {
                display: block;
            }

            .token-table thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }

            .token-table tr {
                border: 1px solid rgba(108, 140, 255, 0.1);
                margin-bottom: 8px;
                padding: 6px;
                border-radius: 6px;
                background: rgba(15, 19, 24, 0.3);
            }

            .token-table td {
                border: none;
                padding: 3px 0;
                text-align: left;
                white-space: normal;
                word-break: break-all;
                overflow-wrap: anywhere;
                font-size: 0.7rem;
            }

            .token-table td:before {
                content: attr(data-label) ": ";
                font-weight: 600;
                color: #6c8cff;
                display: inline-block;
                width: 70px;
                margin-right: 6px;
                flex-shrink: 0;
                font-size: 0.65rem;
            }
        }

        /* Token Selection Modal Styling */
        .token-selection-modal button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            opacity: 0.9;
        }

        .token-selection-modal button:active {
            transform: translateY(0);
        }

        .token-selection-modal label:hover {
            background-color: #e6f7e6 !important;
            border-color: #20c997 !important;
            transition: all 0.2s ease;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .token-selection-modal input[type="checkbox"] {
            transform: scale(1.3);
        }

        .token-selection-modal label {
            transition: all 0.2s ease;
        }

        .token-selection-modal label[disabled] {
            opacity: 0.6;
            cursor: not-allowed !important;
        }
    </style>
</head>

<body>
    <!-- Top chrome: fixed wrapper that always stays above the page -->
    <div class="site-chrome">
        <!-- Transaction Ticker Widget -->
        <iframe id="transaction-ticker-iframe" src="../transaction-ticker-widget.html" scrolling="no"
            title="Transaction Ticker">
        </iframe>

        <!-- Nav Bar-->
        <nav class="navbar">

            <!-- Left: Logo -->
            <div class="navlogo">WILD WEST</div>

            <!-- Center: Main Links -->
            <ul class="nav-links">
                <li><a href="../index.html">Home</a></li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Launch Token ▾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <!-- NOTE: from /pages/ use same-folder path, not ./pages/... -->
                        <li><a href="launch-base.html" role="menuitem" aria-current="page">Base</a></li>
                        <li><a href="launch-solana.html" role="menuitem">Solana (Coming soon!)</a></li>
                    </ul>
                </li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Staking ▾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <li><a href="staking-base.html" role="menuitem">Base</a></li>
                        <li><a href="staking-solana.html" role="menuitem">Solana (Coming soon!)</a></li>
                    </ul>
                </li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Token Locking ▾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <li><a href="locking-base.html" role="menuitem">Base</a></li>
                        <li><a href="locking-solana.html" role="menuitem">Solana</a></li>
                    </ul>
                </li>

                <li><a href="furnace.html">Token Furnace</a></li>
                <li><a href="the-team.html">The Team</a></li>
                <li><a href="/arcade.html">Arcade</a></li> <!-- (double-check: both go to team.html) -->
            </ul>

            <!-- Right: Icons -->
            <div class="nav-actions">
                <a href="https://t.me/wildwestlaunchpad" target="_blank" rel="noopener">
                    <img src="../images/icons/icons8-telegram-app-240_WHITE.png" alt="Telegram" class="nav-icon">
                </a>
                <a href="https://x.com/WILDWESTLP?t=wmcDfvCKnkAaLCtJbmAxgA" target="_blank" rel="noopener">
                    <img src="../images/icons/icons8-twitterx-240_WHITE.png" alt="Twitter/X" class="nav-icon">
                </a>
                <a href="https://dexscreener.com/base/0x8129609e5303910464fce3022a809fa44455fe9a" target="_blank"
                    rel="noopener">
                    <img src="../images/icons/661375b92a7e161501f4b5e5_dexscreener.322a5a2d_WHITE.png" alt="DEXScreener"
                        class="nav-icon">
                </a>
                <div class="connect-wallet-btn">
                    <a>Connect Wallet</a>
                </div>
            </div>
        </nav>

        <!-- Token Furnace Style Wallet Modal System -->
        <script>
            // Utility function for mobile detection
            function isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
            }

            // Get mobile-aware wallet message
            function getMobileAwareWalletMessage() {
                if (isMobileDevice()) {
                    return 'Please open this website in your EVM wallet browser (MetaMask, Trust Wallet, Coinbase Wallet, etc.)';
                } else {
                    return 'Please install MetaMask or another compatible EVM wallet to use this application';
                }
            }

            // Token Furnace Style Wallet Modal Implementation for Base Launch
            document.addEventListener('DOMContentLoaded', function () {
                console.log('🚀 Base Launch: Setting up token furnace style wallet');
                setupBaseLaunchWallet();
            });

            function showChainSelectionModal() {
                console.log('🚀 Base Launch: showChainSelectionModal called!');

                // Focus on Ethereum/Base wallets only for base launch page
                const availableWallets = {
                    ethereum: []
                };

                // Detect Ethereum/Base wallets
                if (window.ethereum) {
                    const providers = window.ethereum.providers || [window.ethereum];

                    providers.forEach(provider => {
                        if (provider.isMetaMask) {
                            availableWallets.ethereum.push({ name: 'MetaMask', provider: provider });
                        }
                        if (provider.isCoinbaseWallet) {
                            availableWallets.ethereum.push({ name: 'Coinbase Wallet', provider: provider });
                        }
                        if (provider.isRabby) {
                            availableWallets.ethereum.push({ name: 'Rabby Wallet', provider: provider });
                        }
                        if (provider.isTrust) {
                            availableWallets.ethereum.push({ name: 'Trust Wallet', provider: provider });
                        }
                    });

                    if (availableWallets.ethereum.length === 0) {
                        availableWallets.ethereum.push({ name: 'Ethereum Wallet', provider: window.ethereum });
                    }
                }

                console.log('🔍 Base Launch: Detected wallets:', availableWallets);

                const modal = document.createElement('div');
                modal.id = 'walletConnectionModal'; // Add ID for easier reference
                modal.className = 'wallet-modal';
                modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center;
                z-index: 10000; animation: fadeIn 0.2s ease-out;
            `;

                let walletOptionsHTML = '';

                if (availableWallets.ethereum.length > 0) {
                    walletOptionsHTML += '<h4 style="color: #00eaff; margin: 1rem 0 0.5rem 0; font-size: 1rem; text-align: center;">Base Network (Ethereum)</h4>';
                    availableWallets.ethereum.forEach((wallet, index) => {
                        walletOptionsHTML += `
                        <button onclick="connectSpecificWallet('ethereum', ${index})" style="
                            display: block; width: 100%; margin: 8px 0; padding: 12px 16px;
                            background: linear-gradient(135deg, #0052ff, #0041cc);
                            color: white; border: 1px solid rgba(0, 234, 255, 0.3); border-radius: 8px;
                            cursor: pointer;
                            transition: all 0.3s ease; text-align: center;
                        " onmouseover="this.style.background='linear-gradient(135deg, #0066ff, #0052ff)'; this.style.borderColor='#00eaff'; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='linear-gradient(135deg, #0052ff, #0041cc)'; this.style.borderColor='rgba(0, 234, 255, 0.3)'; this.style.transform='translateY(0)'">
                            Connect ${wallet.name}
                        </button>
                    `;
                    });
                } else {
                    // Mobile-aware messaging when no wallets detected
                    if (isMobileDevice()) {
                        walletOptionsHTML = `
                        <div style="text-align: center; padding: 1rem; color: #ff6b6b;">
                            <h4 style="color: #ff6b6b; margin-bottom: 1rem; text-align: center;">Open in Wallet Browser</h4>
                            <p style="margin-bottom: 1.5rem; color: #c0c0c0; text-align: center; line-height: 1.5;">To use this application on mobile, please open this website in your EVM wallet's built-in browser:</p>
                            <div style="text-align: center; margin-bottom: 1.5rem;">
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">📱 MetaMask Mobile</span> → Browser Tab → Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">📱 Trust Wallet</span> → Browser Tab → Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">📱 Coinbase Wallet</span> → Browser Tab → Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">📱 Other EVM Wallets</span> → In-App Browser</p>
                            </div>
                            <div style="background: rgba(0, 234, 255, 0.1); border: 1px solid rgba(0, 234, 255, 0.3); border-radius: 8px; padding: 1rem; margin-top: 1rem;">
                                <p style="margin: 0; color: #00eaff; font-size: 0.85rem; font-weight: 500;">💡 Tip: Copy this URL and paste it in your mobile wallet's browser</p>
                            </div>
                        </div>
                    `;
                    } else {
                        walletOptionsHTML = `
                        <div style="text-align: center; padding: 1rem; color: #ff6b6b;">
                            <h4 style="color: #ff6b6b; margin-bottom: 1rem; text-align: center;">No Base Wallets Detected</h4>
                            <p style="margin-bottom: 1rem; color: #c0c0c0; text-align: center;">Please install a Base-compatible wallet:</p>
                            <section class="link-panel link-panel--center-vertically">
                              <a class="panel-item" href="https://metamask.io/" target="_blank" rel="noopener">
                                <img src="../images/metamask-strip-white.webp" alt="Project One" loading="lazy">
                              </a>

                              <a class="panel-item" href="https://www.coinbase.com/wallet" target="_blank" rel="noopener">
                                <img src="../images/coinbase-strip-white.webp" alt="Project Two" loading="lazy">
                              </a>

                              <a class="panel-item" href="https://trustwallet.com/" target="_blank" rel="noopener">
                                <img src="../images/trustwallet-strip-white.webp" alt="Project Three" loading="lazy">
                              </a>
                            </section>
                        </div>
                    `;
                    }
                }

                modal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #1a1a2e, #16213e);
                    border: 2px solid #00eaff;
                    border-radius: 16px;
                    box-shadow: 0 0 30px rgba(0, 234, 255, 0.3);
                    max-width: 400px;
                    width: 90vw;
                    max-height: 80vh;
                    overflow-y: auto;
                ">
                    <div style="
                        padding: 1.5rem;
                        border-bottom: 1px solid rgba(0, 234, 255, 0.2);
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <h3 style="margin: 0; color: #00eaff; font-size: 1.25rem; text-align: center;">Connect Base Wallet</h3>
                        <button class="close-modal-btn" style="
                            background: none; border: none; color: #00eaff; font-size: 1.5rem;
                            cursor: pointer; padding: 0; width: 30px; height: 30px;
                            display: flex; align-items: center; justify-content: center;
                            border-radius: 50%; transition: background-color 0.2s;
                        ">×</button>
                    </div>
                    <div style="padding: 1.5rem;">
                        ${walletOptionsHTML}
                        <button class="cancel-modal-btn" style="
                            display: block; width: 100%; margin-top: 1rem; padding: 10px;
                            background: rgba(102, 102, 102, 0.8); color: white;
                            border: 1px solid rgba(0, 234, 255, 0.2); border-radius: 8px;
                            cursor: pointer;
                            font-family: var(--font-ui);
                        ">Cancel</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);

                const closeBtn = modal.querySelector('.close-modal-btn');
                const cancelBtn = modal.querySelector('.cancel-modal-btn');

                function closeModal() {
                    modal.remove();
                }

                closeBtn.addEventListener('click', closeModal);
                cancelBtn.addEventListener('click', closeModal);
                modal.addEventListener('click', function (e) {
                    if (e.target === modal) closeModal();
                });

                // Store modal reference globally for easy closing
                window.currentWalletModal = modal;
                window.availableWallets = availableWallets;
            }

            window.connectSpecificWallet = async function (network, walletIndex) {
                console.log(`🔗 Base Launch: Connecting to wallet ${walletIndex} on ${network} network`);

                try {
                    if (network === 'ethereum') {
                        const wallet = window.availableWallets.ethereum[walletIndex];
                        if (!wallet) {
                            throw new Error(`Wallet not found at index ${walletIndex}`);
                        }

                        console.log(`📋 Base Launch: Connecting to ${wallet.name}`);

                        const accounts = await wallet.provider.request({ method: 'eth_requestAccounts' });
                        if (accounts.length > 0) {
                            try {
                                await wallet.provider.request({
                                    method: 'wallet_switchEthereumChain',
                                    params: [{ chainId: '0x2105' }], // Base mainnet
                                });
                            } catch (switchError) {
                                if (switchError.code === 4902) {
                                    await wallet.provider.request({
                                        method: 'wallet_addEthereumChain',
                                        params: [{
                                            chainId: '0x2105',
                                            chainName: 'Base',
                                            nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                                            rpcUrls: [BASE_RPC_URL],
                                            blockExplorerUrls: ['https://basescan.org']
                                        }]
                                    });
                                }
                            }

                            // Update global state for launch page
                            window.currentAddress = accounts[0];
                            window.currentChain = 'base';
                            window.currentProvider = wallet.provider;

                            // CRITICAL: Set the main script variables immediately
                            provider = new ethers.providers.Web3Provider(wallet.provider);
                            signer = provider.getSigner();
                            userAddress = accounts[0];

                            // Initialize CONTRACT
                            CONTRACT = new ethers.Contract(TOKEN_FACTORY_ADDRESS, TOKEN_FACTORY_ABI, signer);

                            console.log('🔧 Base Launch: FIXED - Set provider:', !!provider);
                            console.log('🔧 Base Launch: FIXED - Set userAddress:', userAddress);

                            // Close modal IMMEDIATELY after successful connection
                            if (window.currentWalletModal) {
                                console.log('🔄 Base Launch: Closing wallet modal immediately');
                                window.currentWalletModal.remove();
                                window.currentWalletModal = null;
                            }

                            // Fallback: close modal by ID if reference didn't work
                            const modalById = document.getElementById('walletConnectionModal');
                            if (modalById) {
                                console.log('🔄 Base Launch: Closing modal by ID (fallback)');
                                modalById.remove();
                            }

                            // Fallback: close any remaining wallet modal by class
                            const modalByClass = document.querySelector('.wallet-modal');
                            if (modalByClass) {
                                console.log('🔄 Base Launch: Closing modal by class (fallback)');
                                modalByClass.remove();
                            }

                            // Update UI
                            updateBaseLaunchUI(accounts[0]);

                            console.log(`✅ Base Launch: ${wallet.name} connected successfully!`);

                            // Load dashboards directly instead of page reload
                            setTimeout(async () => {
                                console.log('🔄 Base Launch: Loading user tokens...');
                                try {
                                    await connectWallet();
                                    await refreshDashboards();
                                } catch (e) {
                                    console.error('Dashboard loading failed:', e);
                                }
                            }, 500);

                            console.log(`✅ Base Launch: ${wallet.name} connected successfully!`);
                        }
                    }
                } catch (error) {
                    const walletName = window.availableWallets.ethereum[walletIndex]?.name;
                    console.error(`❌ Base Launch: ${walletName} connection failed:`, error);
                    alert(`Connection failed: ${error.message}`);
                }
            };

            function updateBaseLaunchUI(address) {
                const connectBtn = document.getElementById('connectBtn');

                if (connectBtn) {
                    const shortAddr = `${address.slice(0, 6)}...${address.slice(-4)}`;
                    connectBtn.textContent = `Connected: ${shortAddr}`;
                    connectBtn.style.background = 'linear-gradient(135deg, #0070f3, #00c851, #0051cc)';
                    connectBtn.style.backgroundSize = '200% 200%';
                    connectBtn.style.animation = 'gradientShift 6s ease infinite';
                    connectBtn.disabled = false; // Keep button clickable for disconnect option
                    connectBtn.style.cursor = 'pointer'; // Show it's still clickable
                }

                // Hide the connection prompt when wallet is connected
                const connectionStatus = document.getElementById('connectionStatus');
                if (connectionStatus) {
                    connectionStatus.style.display = 'none';
                }

                // Show main content after wallet connection
                const mainContent = document.getElementById('mainContent');
                const priceStatus = document.getElementById('priceStatus');
                const tokenManagement = document.getElementById('tokenManagementSection');
                if (mainContent) mainContent.style.display = 'block';
                if (priceStatus) priceStatus.style.display = 'block';
                if (tokenManagement) tokenManagement.style.display = 'block';

                // Enable functionality
                document.querySelectorAll('.form-input, .btn').forEach(el => {
                    if (el.id !== 'connectBtn') {
                        el.disabled = false;
                    }
                });

                // Update displays
                if (typeof updateDisplays === 'function') {
                    updateDisplays();
                }

                console.log('✅ Base Launch: UI updated and functionality enabled');
            }

            function setupBaseLaunchWallet() {
                console.log('🔧 Base Launch: Setting up wallet connection');

                const connectBtn = document.getElementById('connectBtn');
                if (!connectBtn) {
                    console.error('❌ Base Launch: Connect wallet button not found');
                    return;
                }

                connectBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🔗 Base Launch: Connect button clicked');
                    handleConnectButtonClick();
                });

                // Ensure button is properly centered on page load
                adjustButtonGroupLayout();

                console.log('✅ Base Launch: Wallet setup complete');
            }

            // Smart connect button handler - connects or disconnects based on current state
            function handleConnectButtonClick() {
                // Check if wallet is already connected
                if (userAddress && provider) {
                    // Wallet is connected, ask if user wants to disconnect
                    const shortAddr = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                    const confirmDisconnect = confirm(`Disconnect wallet ${shortAddr}?\n\nThis will hide all token management features and return you to the connection screen.`);

                    if (confirmDisconnect) {
                        console.log('🔌 User requested wallet disconnection');
                        handleWalletDisconnect();
                    }
                } else {
                    // Wallet is not connected, show connection modal
                    console.log('🔗 User wants to connect wallet');
                    showChainSelectionModal();
                }
            }

            // Global variables
            window.currentAddress = null;
            window.currentChain = null;
            window.currentProvider = null;

            // NEW ANTI-SNIPER & ENHANCED FUNCTIONS

            // Helper function to load user tokens using createdTokens mapping
            async function getUserTokens(userAddress) {
                const tokens = [];
                let tokenIndex = 0;
                let maxAttempts = 100; // Prevent infinite loops

                try {
                    while (tokenIndex < maxAttempts) {
                        try {
                            const tokenInfo = await CONTRACT.createdTokens(userAddress, tokenIndex);
                            // Check if we got a valid token (tokenAddress != 0x0)
                            if (tokenInfo[0] && tokenInfo[0] !== '0x0000000000000000000000000000000000000000') {
                                tokens.push(tokenInfo);
                                tokenIndex++;
                            } else {
                                break; // No more tokens
                            }
                        } catch (e) {
                            break; // No more tokens or error occurred
                        }
                    }
                } catch (err) {
                    console.log('Error loading user tokens:', err.message);
                }

                return tokens;
            }

            // Batch swap accumulated token fees
            async function batchSwapTokens() {
                console.log('🚀 batchSwapTokens() function called!');
                console.log('CONTRACT:', CONTRACT);
                console.log('User Address:', userAddress);

                if (!CONTRACT || !userAddress) {
                    console.log('❌ Missing CONTRACT or userAddress');
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    console.log('🔄 Starting token fee swap...');

                    // First get user's tokens to check if they have any
                    const userTokens = await getUserTokens(userAddress);
                    console.log('📋 User tokens found:', userTokens.length);

                    if (userTokens.length === 0) {
                        showStatus('No tokens found. Please create a token first.', 'error');
                        return;
                    }

                    // Check different types of balances that might be stuck
                    console.log('🔍 Checking for different types of stuck tokens...');

                    // Check creator token balance (fees earned as tokens)
                    const tokenBalance = await CONTRACT.getCreatorTokenBalance(userAddress);
                    console.log('💰 Creator token balance:', ethers.utils.formatEther(tokenBalance), 'tokens');

                    // Check if there are any LP token fees accumulated
                    let hasStuckTokens = false;
                    const tokenAddress = userTokens[0][0]; // First token address
                    console.log('🎯 Checking token:', tokenAddress);

                    // Try to check if CONTRACT has any of the user's tokens
                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function decimals() view returns (uint8)",
                        "function symbol() view returns (string)"
                    ];

                    const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                    const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                    const tokenSymbol = await tokenCONTRACT.symbol();

                    console.log('🏦 CONTRACT balance of', tokenSymbol + ':', ethers.utils.formatEther(CONTRACTTokenBalance));

                    if (tokenBalance.gt(0)) {
                        console.log('✅ Found creator token fees to swap');
                        hasStuckTokens = true;
                    } else if (CONTRACTTokenBalance.gt(0)) {
                        console.log('✅ Found CONTRACT token balance that might need swapping');
                        hasStuckTokens = true;
                    } else {
                        showStatus('No stuck tokens found to swap. Token balance: ' + ethers.utils.formatEther(tokenBalance) + ', CONTRACT balance: ' + ethers.utils.formatEther(CONTRACTTokenBalance), 'info');
                        return;
                    }

                    // Proceed with swap
                    console.log('🔄 Attempting to swap tokens for:', tokenAddress);
                    console.log('📊 Creator token balance to swap:', ethers.utils.formatEther(tokenBalance));
                    console.log('🏦 CONTRACT token balance found:', ethers.utils.formatEther(CONTRACTTokenBalance));

                    // The tokens are stuck in the CONTRACT but not assigned to creator yet
                    // Try rescueAndSellStuckTokens function instead
                    console.log('💡 Using rescueAndSellStuckTokens to rescue stuck tokens...');
                    showStatus('Collecting rewards from your tokens...', 'info');

                    try {
                        console.log('� Calling rescueAndSellStuckTokens for token:', tokenAddress);
                        const rescueTx = await CONTRACT.rescueAndSellStuckTokens([tokenAddress]);
                        console.log('⏳ Rescue transaction sent:', rescueTx.hash);

                        const rescueReceipt = await rescueTx.wait();
                        console.log('✅ Rescue confirmed:', rescueReceipt.transactionHash);

                        if (rescueReceipt.logs && rescueReceipt.logs.length > 0) {
                            console.log('� Rescue completed with', rescueReceipt.logs.length, 'events');
                        }

                        showStatus('Rewards successfully collected and converted to ETH!', 'success');

                        // Refresh displays to show updated ETH balances
                        await checkPlatformFees();
                        return;

                    } catch (rescueError) {
                        console.error('Rescue tokens error:', rescueError);
                        let errorMsg = 'Rescue failed: ' + rescueError.message;

                        if (rescueError.message.includes('execution reverted')) {
                            errorMsg = 'Rescue failed - may be insufficient tokens or no liquidity';
                        } else if (rescueError.message.includes('user rejected')) {
                            errorMsg = 'Transaction rejected by user';
                        } else if (rescueError.message.includes('insufficient funds')) {
                            errorMsg = 'Insufficient ETH for gas fees';
                        }

                        showStatus('❌ ' + errorMsg, 'error');
                        return;
                    }

                    showStatus('Testing batch swap function directly...', 'info');

                    // First test with callStatic to see what the error is
                    try {
                        console.log('🧪 Testing batchSwapTokenFees with callStatic...');
                        const result = await CONTRACT.callStatic.batchSwapTokenFees(userAddress, tokenAddress);
                        console.log('✅ callStatic succeeded, result:', result);
                    } catch (testError) {
                        console.log('❌ callStatic failed:', testError.message);
                        if (testError.message.includes('INSUFFICIENT_BALANCE')) {
                            showStatus('Insufficient tokens available for processing', 'error');
                            return;
                        } else if (testError.message.includes('NO_LIQUIDITY')) {
                            showStatus('Trading liquidity not yet available for this token', 'error');
                            return;
                        } else if (testError.message.includes('NOT_AUTHORIZED')) {
                            showStatus('Unable to process tokens at this time', 'error');
                            return;
                        }
                        // Continue anyway to see the real error
                        console.log('🤔 Continuing with actual transaction despite callStatic error...');
                    }

                    showStatus('Processing token fees...', 'info');

                    // Call the batch swap function
                    const tx = await CONTRACT.batchSwapTokenFees(userAddress, tokenAddress);
                    console.log('⏳ Swap transaction sent:', tx.hash);

                    const receipt = await tx.wait();
                    console.log('✅ Swap confirmed:', receipt.transactionHash);

                    // Check how much was swapped
                    if (receipt.logs && receipt.logs.length > 0) {
                        console.log('📋 Swap completed with', receipt.logs.length, 'events');
                    }

                    showStatus('Token fees successfully processed!', 'success');

                    // Refresh displays to show updated ETH balances
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Batch swap error:', error);
                    let errorMsg = 'Batch swap failed: ' + error.message;

                    if (error.message.includes('execution reverted')) {
                        errorMsg = 'Swap failed - may be insufficient liquidity or slippage too high';
                    } else if (error.message.includes('user rejected')) {
                        errorMsg = 'Transaction rejected by user';
                    } else if (error.message.includes('insufficient funds')) {
                        errorMsg = 'Insufficient ETH for gas fees';
                    }

                    showStatus('❌ ' + errorMsg, 'error');
                }
            }

            // Show token selection dialog for multi-project fee collection
            async function showTokenSelectionDialog(tokenOptions) {
                return new Promise((resolve) => {
                    // Create modal dialog
                    const modal = document.createElement('div');
                    modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

                    const dialog = document.createElement('div');
                    dialog.className = 'token-selection-modal';
                    dialog.style.cssText = `
                    background: white;
                    border-radius: 10px;
                    padding: 30px;
                    max-width: 600px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;

                    const tokensWithRewards = tokenOptions.filter(opt => opt.hasRewards);
                    const tokensWithoutRewards = tokenOptions.filter(opt => !opt.hasRewards);

                    dialog.innerHTML = `
                    <h2 style="margin-top: 0; color: #333; text-align: center;">Select Tokens to Collect Rewards</h2>
                    <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 12px; margin-bottom: 20px; color: #856404;">
                        <strong>Multiple Transaction Notice:</strong> Each selected token will require a separate transaction. You'll need to approve each transaction in your wallet.
                    </div>
                    <p style="color: #666; text-align: center; margin-bottom: 25px;">
                        Choose which tokens you want to collect LP rewards from to save on gas fees.
                    </p>
                    
                    ${tokensWithRewards.length > 0 ? `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #28a745; margin-bottom: 15px;">Tokens with Available Rewards:</h3>
                            ${tokensWithRewards.map(opt => `
                                <label style="display: block; margin-bottom: 10px; padding: 15px; border: 2px solid #28a745; border-radius: 8px; cursor: pointer; background-color: #f8fff8;">
                                    <input type="checkbox" value="${opt.index}" checked style="margin-right: 10px; transform: scale(1.3);">
                                    <div style="color: #333;">
                                        <strong style="font-size: 16px; color: #1a5f1a;">${opt.symbol}</strong>
                                        <br>
                                        <span style="color: #555; font-size: 14px;">Available: ${opt.rewardDisplay}</span>
                                        <br>
                                        <span style="color: #777; font-size: 12px;">Position ID: ${opt.tokenId}</span>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${tokensWithoutRewards.length > 0 ? `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #dc3545; margin-bottom: 15px;">Tokens without Rewards:</h3>
                            ${tokensWithoutRewards.map(opt => `
                                <label style="display: block; margin-bottom: 10px; padding: 15px; border: 2px solid #ddd; border-radius: 8px; background-color: #f8f8f8;">
                                    <input type="checkbox" value="${opt.index}" disabled style="margin-right: 10px; transform: scale(1.3);">
                                    <div style="color: #666;">
                                        <strong style="font-size: 16px; color: #999;">${opt.symbol}</strong>
                                        <br>
                                        <span style="color: #999; font-size: 14px;">No rewards available</span>
                                        <br>
                                        <span style="color: #bbb; font-size: 12px;">Position ID: ${opt.tokenId || 'unknown'}</span>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 30px; flex-wrap: wrap;">
                        <button id="selectAll" style="padding: 12px 24px; background-color: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Select All Available
                        </button>
                        <button id="confirmSelection" style="padding: 12px 24px; background-color: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Collect Selected (${tokensWithRewards.length} txns)
                        </button>
                        <button id="cancelSelection" style="padding: 12px 24px; background-color: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Cancel
                        </button>
                    </div>
                `;

                    modal.appendChild(dialog);
                    document.body.appendChild(modal);

                    // Event listeners
                    const selectAllBtn = dialog.querySelector('#selectAll');
                    const confirmBtn = dialog.querySelector('#confirmSelection');
                    const cancelBtn = dialog.querySelector('#cancelSelection');
                    const checkboxes = dialog.querySelectorAll('input[type="checkbox"]:not([disabled])');

                    // Function to update button text based on selection
                    const updateConfirmButtonText = () => {
                        const selectedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
                        confirmBtn.textContent = `Collect Selected (${selectedCount} txns)`;
                        confirmBtn.disabled = selectedCount === 0;
                        confirmBtn.style.opacity = selectedCount === 0 ? '0.5' : '1';
                    };

                    // Add change listeners to checkboxes
                    checkboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', updateConfirmButtonText);
                    });

                    selectAllBtn.addEventListener('click', () => {
                        checkboxes.forEach(cb => cb.checked = true);
                        updateConfirmButtonText();
                    });

                    confirmBtn.addEventListener('click', () => {
                        const selected = Array.from(checkboxes)
                            .filter(cb => cb.checked)
                            .map(cb => parseInt(cb.value));

                        document.body.removeChild(modal);
                        resolve(selected);
                    });

                    cancelBtn.addEventListener('click', () => {
                        document.body.removeChild(modal);
                        resolve(null);
                    });

                    // Close on backdrop click
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            document.body.removeChild(modal);
                            resolve(null);
                        }
                    });
                });
            }

            // Collect tokens directly to creator wallet (no conversion needed)
            async function transferTokensToCreator() {
                console.log('🚀 Collect creator tokens from selected projects directly to wallet!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    console.log('🔄 Starting direct creator token collection...');

                    // Get current creator's tokens
                    const userTokens = await getUserTokens(userAddress);
                    if (userTokens.length === 0) {
                        showStatus('No tokens found for your wallet address', 'error');
                        return;
                    }

                    console.log(`📊 Found ${userTokens.length} token(s) available for collection`);

                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function symbol() view returns (string)"
                    ];

                    // Step 1: If multiple tokens, let user select which ones to collect
                    let selectedTokens = userTokens;

                    if (userTokens.length === 1) {
                        console.log('🔄 Single token found, processing directly...');
                        const tokenInfo = userTokens[0];
                        const tokenAddress = tokenInfo[0];
                        const tokenId = tokenInfo[4];

                        // Quick check if single token has rewards
                        try {
                            const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                            const contractBalance = await tokenContract.balanceOf(CONTRACT.address);
                            const tokenSymbol = await tokenContract.symbol();

                            console.log(`📊 Single token ${tokenSymbol} - contract balance:`, ethers.utils.formatEther(contractBalance));

                            if (contractBalance.eq(0)) {
                                // Check position rewards as well
                                try {
                                    const positionManagerContract = new ethers.Contract(
                                        '0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1',
                                        [
                                            "function positions(uint256) view returns (uint96, address, address, address, uint24, int24, int24, uint128, uint256, uint256, uint128, uint128)"
                                        ],
                                        provider
                                    );

                                    const position = await positionManagerContract.positions(tokenId);
                                    const tokensOwed0 = position[10];
                                    const tokensOwed1 = position[11];

                                    console.log(`💰 Single token position ${tokenId} - tokensOwed0:`, ethers.utils.formatEther(tokensOwed0));
                                    console.log(`💰 Single token position ${tokenId} - tokensOwed1:`, ethers.utils.formatEther(tokensOwed1));

                                    if (tokensOwed0.eq(0) && tokensOwed1.eq(0)) {
                                        showStatus(`No LP rewards available for ${tokenSymbol}. Position may need to be refreshed.`, 'info');
                                        return;
                                    }
                                } catch (posError) {
                                    console.log('⚠️ Could not check position for single token:', posError.message);
                                    showStatus(`No LP rewards available for ${tokenSymbol}. Contract balance is zero.`, 'info');
                                    return;
                                }
                            }
                        } catch (error) {
                            console.log('❌ Error checking single token:', error.message);
                        }
                    } else {
                        console.log('Multiple tokens found, reading reward data from existing cards...');
                        showStatus('Reading reward data from your token cards...', 'info');

                        // Get reward data from existing cards instead of re-detecting
                        const tokenOptions = [];
                        for (let i = 0; i < userTokens.length; i++) {
                            const tokenInfo = userTokens[i];
                            const tokenAddress = tokenInfo[0];
                            const tokenId = tokenInfo[4];

                            try {
                                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                                const tokenSymbol = await tokenContract.symbol();

                                // Find the corresponding fee section by token ID
                                const feesSectionId = `fees-section-${tokenId}`;
                                const feesSection = document.getElementById(feesSectionId);
                                let cardRewardText = '';
                                let hasRewards = false;

                                if (feesSection) {
                                    // Extract ETH and token amounts from the fee section
                                    const ethFeesElement = feesSection.querySelector('.eth-fees span');
                                    const tokenFeesElement = feesSection.querySelector('.token-fees span');

                                    const ethText = ethFeesElement ? ethFeesElement.textContent : '';
                                    const tokenText = tokenFeesElement ? tokenFeesElement.textContent : '';

                                    console.log(`Token ${tokenSymbol} - ETH text: "${ethText}", Token text: "${tokenText}"`);

                                    // Check if there are meaningful rewards
                                    const ethMatch = ethText.match(/([0-9.]+)\s*ETH/);
                                    const tokenMatch = tokenText.match(/\+\s*([0-9.]+)\s*\S+/);

                                    const ethAmount = ethMatch ? parseFloat(ethMatch[1]) : 0; // This is already creator's 50% share
                                    const tokenAmount = tokenMatch ? parseFloat(tokenMatch[1]) : 0;

                                    hasRewards = ethAmount > 0.000001 || tokenAmount > 0.000001;

                                    if (hasRewards) {
                                        const parts = [];
                                        if (ethAmount > 0.000001) parts.push(`${ethAmount.toFixed(6)} ETH`);
                                        if (tokenAmount > 0.000001) parts.push(`${tokenAmount.toFixed(6)} ${tokenSymbol}`);
                                        cardRewardText = parts.join(' + ');
                                    } else {
                                        cardRewardText = 'Very small or no rewards';
                                    }

                                    console.log(`Token ${tokenSymbol} - Final: hasRewards=${hasRewards}, display="${cardRewardText}"`);
                                } else {
                                    console.log(`No fee section found for token ID ${tokenId}`);
                                    cardRewardText = 'Fee section not found';
                                }

                                tokenOptions.push({
                                    index: i,
                                    tokenInfo: tokenInfo,
                                    symbol: tokenSymbol,
                                    hasRewards: hasRewards,
                                    rewardDisplay: cardRewardText.trim() || 'No reward data found',
                                    tokenId: tokenId.toString()
                                });

                            } catch (error) {
                                console.log(`Error processing token ${i}:`, error.message);
                                tokenOptions.push({
                                    index: i,
                                    tokenInfo: tokenInfo,
                                    symbol: `Token ${i + 1}`,
                                    hasRewards: false,
                                    rewardDisplay: 'Error loading data',
                                    tokenId: 'unknown'
                                });
                            }
                        }

                        // Show selection dialog
                        const tokensWithRewards = tokenOptions.filter(opt => opt.hasRewards);
                        const tokensWithoutRewards = tokenOptions.filter(opt => !opt.hasRewards);

                        console.log('📊 Token options summary:');
                        console.log('  Total tokens:', tokenOptions.length);
                        console.log('  Tokens with rewards:', tokensWithRewards.length);
                        console.log('  Tokens without rewards:', tokensWithoutRewards.length);

                        tokenOptions.forEach((opt, i) => {
                            console.log(`  ${i + 1}. ${opt.symbol}: hasRewards=${opt.hasRewards}, ETH=${opt.ethRewards}, Tokens=${opt.tokenRewards}`);
                        });

                        if (tokensWithRewards.length === 0) {
                            console.log('No tokens with rewards found');
                            showStatus('No LP rewards are currently available for your tokens. Try refreshing the page or waiting for more trading activity.', 'info');
                            return;
                        }

                        const selection = await showTokenSelectionDialog(tokenOptions);
                        if (!selection || selection.length === 0) {
                            showStatus('Collection cancelled by user.', 'info');
                            return;
                        }

                        selectedTokens = selection.map(index => userTokens[index]);
                        console.log(`👤 User selected ${selectedTokens.length} token(s) for collection`);
                    }

                    let totalCollected = 0;
                    let successfulCollections = 0;
                    const collectionResults = [];

                    // Step 2: Process each selected token project
                    for (let i = 0; i < selectedTokens.length; i++) {
                        const tokenInfo = selectedTokens[i];
                        const tokenAddress = tokenInfo[0];
                        const tokenId = tokenInfo[4];
                        const creatorAddress = userAddress;

                        console.log(`\n🔄 Processing selected token ${i + 1}/${selectedTokens.length}:`);
                        console.log('👤 Creator:', creatorAddress);
                        console.log('🪙 Token:', tokenAddress);
                        console.log('🆔 Token ID:', tokenId.toString());

                        try {
                            // Check current token balances for this token
                            const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                            const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                            const creatorWalletBalance = await tokenCONTRACT.balanceOf(creatorAddress);
                            const tokenSymbol = await tokenCONTRACT.symbol();

                            console.log(`🏦 CONTRACT has ${ethers.utils.formatEther(CONTRACTTokenBalance)} ${tokenSymbol}`);
                            console.log(`👤 Creator wallet has ${ethers.utils.formatEther(creatorWalletBalance)} ${tokenSymbol}`);

                            if (CONTRACTTokenBalance.eq(0)) {
                                console.log(`ℹ️ No LP fees available for ${tokenSymbol}, skipping...`);
                                collectionResults.push({ symbol: tokenSymbol, collected: '0', status: 'No fees available' });
                                continue;
                            }

                            // Collect LP fees from Uniswap position for this token
                            showStatus(`Collecting rewards from ${tokenSymbol} position (${i + 1}/${selectedTokens.length})...`, 'info');
                            try {
                                const collectTx = await CONTRACT.collectFees(tokenId);
                                console.log(`⏳ CollectFees transaction sent for ${tokenSymbol}:`, collectTx.hash);

                                const collectReceipt = await collectTx.wait();
                                console.log(`✅ CollectFees confirmed for ${tokenSymbol}:`, collectReceipt.transactionHash);

                                if (collectReceipt.logs && collectReceipt.logs.length > 0) {
                                    console.log(`📋 Collection completed for ${tokenSymbol} with ${collectReceipt.logs.length} events`);
                                }

                                // Check what we collected for this token
                                const newCONTRACTBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                                const newCreatorWalletBalance = await tokenCONTRACT.balanceOf(creatorAddress);
                                const creatorTokenBalance = await CONTRACT.getCreatorTokenBalance(creatorAddress);

                                const tokensCollected = CONTRACTTokenBalance.sub(newCONTRACTBalance);
                                const tokensToWallet = newCreatorWalletBalance.sub(creatorWalletBalance);

                                let collectedAmount = '0';
                                let status = 'Success';

                                if (tokensToWallet.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(tokensToWallet);
                                    console.log(`✅ ${collectedAmount} ${tokenSymbol} transferred to wallet`);
                                } else if (creatorTokenBalance.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(creatorTokenBalance);
                                    console.log(`✅ ${collectedAmount} ${tokenSymbol} collected`);
                                } else if (tokensCollected.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(tokensCollected);
                                    console.log(`✅ ${collectedAmount} ${tokenSymbol} rewards collected`);
                                } else {
                                    status = 'No token rewards found';
                                    console.log(`ℹ️ LP fees collected for ${tokenSymbol}, but no token rewards found`);
                                }

                                collectionResults.push({
                                    symbol: tokenSymbol,
                                    collected: collectedAmount,
                                    status: status
                                });

                                if (parseFloat(collectedAmount) > 0) {
                                    totalCollected += parseFloat(collectedAmount);
                                    successfulCollections++;
                                }

                            } catch (collectError) {
                                console.log(`❌ Collect LP fees failed for ${tokenSymbol}:`, collectError.message);
                                collectionResults.push({
                                    symbol: tokenSymbol,
                                    collected: '0',
                                    status: 'Collection failed: ' + collectError.message
                                });
                                // Continue with other tokens instead of stopping
                                continue;
                            }

                        } catch (tokenError) {
                            console.log(`❌ Error processing token ${i + 1}:`, tokenError.message);
                            collectionResults.push({
                                symbol: `Token ${i + 1}`,
                                collected: '0',
                                status: 'Processing error: ' + tokenError.message
                            });
                            continue;
                        }
                    }

                    // Step 2: Display comprehensive results
                    console.log('\n� Collection Summary:');
                    console.log(`✅ Successfully processed: ${successfulCollections}/${selectedTokens.length} selected tokens`);
                    console.log(`💰 Total value collected: ${totalCollected} tokens`);

                    let resultMessage = `Collection completed for ${selectedTokens.length} selected project(s):\n`;
                    collectionResults.forEach((result, index) => {
                        if (parseFloat(result.collected) > 0) {
                            resultMessage += `✅ ${result.symbol}: ${result.collected} tokens collected\n`;
                        } else {
                            resultMessage += `ℹ️ ${result.symbol}: ${result.status}\n`;
                        }
                    });

                    if (successfulCollections > 0) {
                        showStatus(`Success! Collected LP rewards from ${successfulCollections} selected project(s). Your wallet should now contain the collected tokens and you can now claim your ETH.`, 'success');
                        console.log(resultMessage);
                    } else if (collectionResults.length > 0) {
                        showStatus(`ℹ️ Processed ${selectedTokens.length} selected project(s) but no LP rewards were available to collect.`, 'info');
                    } else {
                        showStatus('No projects found to process.', 'error');
                    }

                    // Refresh displays to show updated balances
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Creator token collection error:', error);
                    showStatus('❌ Collection failed: ' + error.message, 'error');
                }
            }

            // Admin function to collect all platform fees and distribute them
            async function collectAllPlatformFees() {
                console.log('🔥 Admin: Collecting ALL platform fees!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    // First check if user is platform admin
                    const platformAdmin = await CONTRACT.platformAdmin();
                    console.log('👑 Platform admin address:', platformAdmin);
                    console.log('👤 Current user address:', userAddress);

                    if (userAddress.toLowerCase() !== platformAdmin.toLowerCase()) {
                        showStatus('❌ Only platform admin can collect all fees', 'error');
                        return;
                    }

                    console.log('✅ Admin verified, proceeding with platform-wide collection...');
                    showStatus('🔥 Admin: Starting platform-wide fee collection...', 'info');

                    // Get total token count
                    const totalTokens = await CONTRACT.getTokenCount();
                    console.log('📊 Total tokens in platform:', totalTokens.toString());

                    if (totalTokens.eq(0)) {
                        showStatus('No tokens in platform to collect fees from', 'info');
                        return;
                    }

                    // Step 1: Use collectAllTokens function to collect from all LP positions
                    showStatus('Step 1: Collecting fees from all LP positions...', 'info');
                    try {
                        const collectAllTx = await CONTRACT.collectAllTokens();
                        console.log('⏳ CollectAllTokens transaction sent:', collectAllTx.hash);

                        const collectAllReceipt = await collectAllTx.wait();
                        console.log('✅ CollectAllTokens confirmed:', collectAllReceipt.transactionHash);

                        if (collectAllReceipt.logs && collectAllReceipt.logs.length > 0) {
                            console.log('📋 Collection completed with', collectAllReceipt.logs.length, 'events');
                        }

                    } catch (collectAllError) {
                        console.log('❌ CollectAllTokens failed:', collectAllError.message);
                        showStatus('❌ Failed to collect from all positions: ' + collectAllError.message, 'error');
                        return;
                    }

                    // Step 2: Check what we collected
                    const platformFees = await CONTRACT.getPlatformFees();
                    console.log('🏢 Platform fees after collection:', ethers.utils.formatEther(platformFees), 'ETH');

                    showStatus('Step 2: Checking collected fees and token balances...', 'info');

                    // Step 3: For each token, try to convert any stuck tokens to ETH
                    showStatus('Step 3: Converting any stuck tokens to ETH...', 'info');

                    const tokenAddresses = [];

                    // Get all token addresses for rescue operation
                    for (let i = 0; i < Math.min(totalTokens.toNumber(), 50); i++) { // Limit to 50 for gas reasons
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            tokenAddresses.push(tokenInfo.tokenAddress);
                        } catch (error) {
                            console.log(`❌ Failed to get token ${i}:`, error.message);
                        }
                    }

                    console.log('🎯 Found', tokenAddresses.length, 'token addresses for rescue');

                    if (tokenAddresses.length > 0) {
                        try {
                            const rescueTx = await CONTRACT.rescueAndSellStuckTokens(tokenAddresses);
                            console.log('⏳ Rescue transaction sent:', rescueTx.hash);

                            const rescueReceipt = await rescueTx.wait();
                            console.log('✅ Rescue confirmed:', rescueReceipt.transactionHash);

                        } catch (rescueError) {
                            console.log('❌ Rescue failed (may be no stuck tokens):', rescueError.message);
                        }
                    }

                    // Step 4: Final fee check and summary
                    const finalPlatformFees = await CONTRACT.getPlatformFees();
                    console.log('💰 Final platform fees:', ethers.utils.formatEther(finalPlatformFees), 'ETH');

                    const totalCollected = finalPlatformFees.sub(platformFees);

                    if (totalCollected.gt(0)) {
                        showStatus(`✅ Success! Collected ${ethers.utils.formatEther(totalCollected)} ETH from all positions. Ready to withdraw platform fees.`, 'success');
                    } else {
                        showStatus('✅ Fee collection completed. No new fees were available across all positions.', 'success');
                    }

                    // Refresh displays
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Admin fee collection error:', error);
                    showStatus('❌ Admin collection failed: ' + error.message, 'error');
                }
            }

            // Function to collect fees for a specific token
            async function collectFeesForToken(tokenName) {
                console.log(`💰 COLLECTING FEES FOR ${tokenName}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("❌ Provider or CONTRACT not available");
                        showStatus('Please connect your wallet first', 'error');
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("👤 User address:", userAddress);

                    // Get all tokens to find the specific one
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    let targetToken = null;

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            if (tokenInfo.name && tokenInfo.name.includes(tokenName)) {
                                targetToken = tokenInfo;
                                console.log(`✅ Found ${tokenName}:`, tokenInfo);
                                break;
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    if (!targetToken) {
                        console.log(`❌ ${tokenName} not found!`);
                        showStatus(`❌ ${tokenName} not found in contract`, 'error');
                        return;
                    }

                    console.log(`🎯 Collecting fees for ${tokenName} (${targetToken.tokenAddress})`);
                    showStatus(`🔄 Collecting fees from ${tokenName}'s liquidity pool...`, 'info');

                    // Call the contract to collect fees for this token
                    const tx = await CONTRACT.collectTokenFees(targetToken.tokenAddress);
                    console.log("📝 Transaction sent:", tx.hash);
                    showStatus(`⏳ Collecting ${tokenName} fees... Transaction: ${tx.hash.substring(0, 10)}...`, 'info');

                    // Wait for confirmation
                    const receipt = await tx.wait();
                    console.log("✅ Transaction confirmed:", receipt);

                    showStatus(`✅ ${tokenName} fees collected successfully!`, 'success');

                    // Refresh fee displays
                    setTimeout(() => {
                        checkPlatformFees();
                        loadUserTokens();
                    }, 2000);

                } catch (error) {
                    console.error(`❌ Error collecting ${tokenName} fees:`, error);
                    showStatus(`❌ Failed to collect ${tokenName} fees: ${error.message}`, 'error');
                }
            }

            // Debug function to check all user tokens
            async function debugUserTokens() {
                console.log(`🔍 DEBUGGING ALL USER TOKENS`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("❌ Provider or CONTRACT not available");
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("👤 User address:", userAddress);
                    console.log("🏭 Contract address:", CONTRACT.address);

                    // Get all tokens
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    console.log("📊 Total tokens in contract:", totalTokenCount.toString());

                    let userTokens = [];
                    let totalUserFees = ethers.BigNumber.from("0");

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            console.log(`Token ${i}:`, tokenInfo);

                            // Check if user is the creator
                            if (tokenInfo.creator && tokenInfo.creator.toLowerCase() === userAddress.toLowerCase()) {
                                const tokenFees = ethers.BigNumber.from(tokenInfo.totalFeesETH || "0");
                                const creatorPortion = tokenFees.mul(50).div(100);

                                userTokens.push({
                                    index: i,
                                    name: tokenInfo.name,
                                    address: tokenInfo.tokenAddress,
                                    totalFees: ethers.utils.formatEther(tokenFees),
                                    creatorShare: ethers.utils.formatEther(creatorPortion)
                                });

                                totalUserFees = totalUserFees.add(creatorPortion);
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    console.log("🎯 USER'S TOKENS:");
                    userTokens.forEach((token, idx) => {
                        console.log(`  ${idx + 1}. ${token.name}`);
                        console.log(`     Address: ${token.address}`);
                        console.log(`     Total Fees: ${token.totalFees} ETH`);
                        console.log(`     Creator Share: ${token.creatorShare} ETH`);
                    });

                    console.log(`💰 Total lifetime earnings: ${ethers.utils.formatEther(totalUserFees)} ETH`);

                    // Check current withdrawable fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log("💸 Current withdrawable creator fees:", ethers.utils.formatEther(creatorFees), "ETH");

                    if (userTokens.length === 0) {
                        console.log("❌ No tokens found for current user in this contract!");
                        console.log("This could mean:");
                        console.log("1. You haven't created any tokens with this contract");
                        console.log("2. Your tokens were created with a previous contract version");
                        console.log("3. There's a mismatch in wallet address");
                    }

                } catch (error) {
                    console.error(`❌ Error debugging user tokens:`, error);
                }
            }

            // Enhanced debug function for specific token with detailed fee tracking
            async function debugTokenFees(tokenName) {
                console.log(`🔍 DEBUGGING FEES FOR ${tokenName}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("❌ Provider or CONTRACT not available");
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("👤 User address:", userAddress);
                    console.log("🏭 Contract address:", CONTRACT.address);

                    // Get all tokens
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    console.log("📊 Total tokens in contract:", totalTokenCount.toString());

                    // Find the specific token
                    let foundToken = null;
                    let tokenIndex = -1;

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            console.log(`Token ${i}:`, tokenInfo);

                            if (tokenInfo.name && tokenInfo.name.includes(tokenName)) {
                                foundToken = tokenInfo;
                                tokenIndex = i;
                                console.log(`✅ Found ${tokenName} at index ${i}:`, tokenInfo);
                                break;
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    if (!foundToken) {
                        console.log(`❌ ${tokenName} not found in current contract!`);
                        return;
                    }

                    console.log(`🎯 ${tokenName} DETAILED ANALYSIS:`);
                    console.log("  - Token Address:", foundToken.tokenAddress);
                    console.log("  - Creator:", foundToken.creator);
                    console.log("  - Total Fees (stored):", ethers.utils.formatEther(foundToken.totalFeesETH || "0"), "ETH");
                    console.log("  - Created by current user:", foundToken.creator.toLowerCase() === userAddress.toLowerCase());
                    console.log("  - Token raw data:", foundToken);

                    // Check if user is the creator
                    if (foundToken.creator.toLowerCase() === userAddress.toLowerCase()) {
                        const creatorPortion = ethers.BigNumber.from(foundToken.totalFeesETH || "0").mul(50).div(100);
                        console.log("💰 Creator's share:", ethers.utils.formatEther(creatorPortion), "ETH");
                    } else {
                        console.log("ℹ️ User is not the creator of this token");
                    }

                    // Check current withdrawable fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log("💸 Current withdrawable creator fees:", ethers.utils.formatEther(creatorFees), "ETH");

                    // Additional debugging - check if token has any Uniswap activity
                    console.log("🔍 CHECKING UNISWAP ACTIVITY...");
                    try {
                        const tokenContract = new ethers.Contract(foundToken.tokenAddress, [
                            "function balanceOf(address) view returns (uint256)",
                            "function totalSupply() view returns (uint256)",
                            "function name() view returns (string)",
                            "function symbol() view returns (string)"
                        ], provider);

                        const tokenSupply = await tokenContract.totalSupply();
                        console.log("📊 Token total supply:", ethers.utils.formatEther(tokenSupply));

                        // Check token balance in Uniswap V3 Position Manager (this is where LP tokens are held)
                        const POSITION_MANAGER = "0x03a520b32C04BF3bEEf7BF5d24FC2e9de0e4a1e7";
                        const lpBalance = await tokenContract.balanceOf(POSITION_MANAGER);
                        console.log("💧 Tokens in Uniswap LP:", ethers.utils.formatEther(lpBalance));

                        if (lpBalance.gt(0)) {
                            console.log("✅ Token has liquidity in Uniswap - trades should generate fees");
                            console.log("🔍 Fee generation requires actual trades/swaps on Uniswap");
                            console.log("💡 Try making a small swap on the token to generate fees");
                        } else {
                            console.log("⚠️ No tokens found in Uniswap LP - fees can only generate from trades");
                        }

                    } catch (tokenError) {
                        console.log("⚠️ Could not check token contract details:", tokenError.message);
                    }

                    console.log("🎯 DEBUGGING SUMMARY:");
                    console.log(`   Token exists in contract: YES`);
                    console.log(`   Creator matches user: ${foundToken.creator.toLowerCase() === userAddress.toLowerCase() ? 'YES' : 'NO'}`);
                    console.log(`   Fees stored in contract: ${ethers.utils.formatEther(foundToken.totalFeesETH || "0")} ETH`);
                    console.log(`   To generate fees: Make trades on Uniswap for this token`);

                } catch (error) {
                    console.error(`❌ Error debugging ${tokenName}:`, error);
                }
            }

            // Function to manually collect fees for a specific token
            async function manualCollectTokenFees(tokenAddress) {
                console.log(`🔄 MANUALLY COLLECTING FEES FOR TOKEN: ${tokenAddress}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("❌ Provider or CONTRACT not available");
                        return;
                    }

                    console.log("📞 Calling collectTokenFees...");
                    const tx = await CONTRACT.collectTokenFees(tokenAddress);
                    console.log("📋 Transaction sent:", tx.hash);

                    showStatus(`🔄 Collecting fees for token... TX: ${tx.hash}`, 'info');

                    const receipt = await tx.wait();
                    console.log("✅ Transaction confirmed:", receipt);

                    // Check fees again after collection
                    setTimeout(() => {
                        checkPlatformFees();
                    }, 3000);

                    showStatus(`✅ Fees collected successfully!`, 'success');

                } catch (error) {
                    console.error(`❌ Error collecting fees:`, error);
                    showStatus(`❌ Error collecting fees: ${error.message}`, 'error');
                }
            }

            // Debug function to understand withdrawal issues
            async function debugWithdrawCreatorFees() {
                console.log('🔍 DEBUGGING WITHDRAW CREATOR FEES');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    showStatus('🔍 Debugging withdrawal issue...', 'info');

                    // Check multiple calls to see if state is changing
                    console.log('📞 Making multiple getCreatorFees calls...');

                    const fees1 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('🔍 Call 1 - Creator fees:', ethers.utils.formatEther(fees1), 'ETH', '(' + fees1.toString() + ' wei)');

                    const fees2 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('🔍 Call 2 - Creator fees:', ethers.utils.formatEther(fees2), 'ETH', '(' + fees2.toString() + ' wei)');

                    const fees3 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('🔍 Call 3 - Creator fees:', ethers.utils.formatEther(fees3), 'ETH', '(' + fees3.toString() + ' wei)');

                    // Check CONTRACT ETH balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);
                    console.log('🏦 CONTRACT ETH balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH', '(' + CONTRACTBalance.toString() + ' wei)');

                    if (CONTRACTBalance.lt(fees1)) {
                        console.log('❌ CONTRACT BALANCE TOO LOW! CONTRACT has', ethers.utils.formatEther(CONTRACTBalance), 'but needs', ethers.utils.formatEther(fees1));
                        showStatus('Insufficient balance available for withdrawal', 'error');
                        return;
                    } else {
                        console.log('✅ CONTRACT has sufficient balance for withdrawal');
                    }

                    if (fees1.eq(fees2) && fees2.eq(fees3)) {
                        console.log('✅ Fees are consistent across calls');
                    } else {
                        console.log('❌ WARNING: Fees are changing between calls!');
                    }

                    // Check if amount is greater than 0
                    if (fees1.gt(0)) {
                        console.log('✅ Amount is greater than 0, should be withdrawable');

                        // Try to estimate gas for the withdrawal
                        try {
                            console.log('🔍 Trying to estimate gas for withdrawal...');
                            const gasEstimate = await CONTRACT.estimateGas.withdrawCreatorFees();
                            console.log('✅ Gas estimate successful:', gasEstimate.toString());

                            showStatus('✅ Gas estimation passed - trying actual withdrawal...', 'info');

                            // If gas estimation works, try the actual call
                            const tx = await CONTRACT.withdrawCreatorFees();
                            console.log('✅ Transaction submitted:', tx.hash);
                            showStatus('⏳ Waiting for confirmation...', 'info');

                            const receipt = await tx.wait();
                            console.log('✅ Transaction confirmed:', receipt.transactionHash);
                            showStatus('Withdrawal successful!', 'success');

                        } catch (gasError) {
                            console.log('❌ Gas estimation failed:', gasError.message);
                            console.log('❌ Full gas error:', gasError);

                            // Try to understand why gas estimation fails
                            if (gasError.message.includes('execution reverted')) {
                                console.log('💡 The CONTRACT is reverting - checking why...');

                                // Double-check the amount right before the call
                                const lastCheck = await CONTRACT.getCreatorFees(userAddress);
                                console.log('🔍 Final amount check:', ethers.utils.formatEther(lastCheck), 'ETH');

                                if (lastCheck.eq(0)) {
                                    showStatus('❌ Amount became 0 just before withdrawal - possible race condition', 'error');
                                } else {
                                    console.log('❌ CONTRACT is reverting even though amount > 0 - trying manual gas approach...');

                                    // Try with optimized gas limit
                                    try {
                                        console.log('🔧 Attempting withdrawal with optimized gas limit...');

                                        // Smart gas estimation for withdrawal
                                        let gasLimit;
                                        try {
                                            const estimatedGas = await CONTRACT.estimateGas.withdrawCreatorFees();
                                            gasLimit = Math.floor(estimatedGas.toNumber() * 1.2); // 20% buffer
                                            console.log(`💡 Withdrawal gas optimized: ${gasLimit}`);
                                        } catch (estError) {
                                            gasLimit = 80000; // Lower conservative limit
                                        }

                                        const tx = await CONTRACT.withdrawCreatorFees({
                                            gasLimit: gasLimit  // Optimized gas limit
                                        });
                                        console.log('✅ Optimized gas transaction submitted:', tx.hash);
                                        showStatus('⏳ Optimized withdrawal submitted...', 'info');

                                        const receipt = await tx.wait();
                                        console.log('✅ Manual gas withdrawal confirmed:', receipt.transactionHash);
                                        showStatus('✅ Manual gas withdrawal successful!', 'success');

                                    } catch (manualGasError) {
                                        console.log('❌ Manual gas also failed:', manualGasError.message);

                                        // Check if there's a minimum threshold issue
                                        if (lastCheck.lt(ethers.utils.parseEther('0.0001'))) {
                                            console.log('⚠️ Amount might be below minimum threshold');
                                            showStatus('❌ Amount too small - CONTRACT may have minimum withdrawal threshold', 'error');
                                        } else {
                                            showStatus('❌ CONTRACT bug confirmed - withdrawal impossible even with manual gas', 'error');
                                        }
                                    }
                                }
                            } else {
                                showStatus('❌ Gas estimation error: ' + gasError.message, 'error');
                            }
                        }

                    } else {
                        console.log('❌ Amount is 0, cannot withdraw');
                        showStatus('No fees available for withdrawal', 'error');
                    }

                } catch (error) {
                    console.error('❌ Debug error:', error);
                    showStatus('❌ Debug failed: ' + error.message, 'error');
                }
            }

            // Admin panel balance check with on-page results
            async function adminCheckBalance() {
                console.log('🔍 ADMIN: Checking CONTRACT balance vs expected fees');

                const resultDiv = document.getElementById('balanceCheckResult');
                const CONTRACTAddress = CONTRACT?.address || TOKEN_FACTORY_ADDRESS || "0xaB4FE16F395921081bD9895359cf173a2Eaa7125";

                if (!CONTRACT || !userAddress) {
                    resultDiv.innerHTML = '<div style="background:#fee2e2; color:#dc2626; padding:8px; border-radius:4px;">❌ Please connect your wallet first</div>';
                    resultDiv.style.display = 'block';
                    return;
                }

                try {
                    resultDiv.innerHTML = '<div style="background:#e0f2fe; color:#0369a1; padding:8px; border-radius:4px;">🔍 Checking CONTRACT balance...</div>';
                    resultDiv.style.display = 'block';

                    // Get expected fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalExpectedFees = creatorFees.add(platformFees);

                    // Get actual CONTRACT balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);

                    // Log to console for debugging
                    console.log('💰 Expected creator fees:', ethers.utils.formatEther(creatorFees), 'ETH');
                    console.log('🏢 Expected platform fees:', ethers.utils.formatEther(platformFees), 'ETH');
                    console.log('📊 Total expected fees:', ethers.utils.formatEther(totalExpectedFees), 'ETH');
                    console.log('🏦 Actual CONTRACT balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH');

                    let resultHTML = '';

                    if (CONTRACTBalance.eq(0)) {
                        console.log('❌ CONTRACT IS EMPTY! All ETH was drained.');
                        console.log('🔧 TO FIX: Send exactly', ethers.utils.formatEther(totalExpectedFees), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('🎯 EXACT AMOUNT IN WEI:', totalExpectedFees.toString());

                        resultHTML = `
                        <div style="background:#fee2e2; color:#dc2626; padding:12px; border-radius:6px; border-left:4px solid #dc2626;">
                            <div style="font-weight:600; margin-bottom:8px;">INSUFFICIENT BALANCE!</div>
                            <div style="margin-bottom:4px;">Expected rewards: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Current balance: <strong>0.000000 ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">TO RESOLVE:</div>
                                <div style="margin-bottom:4px;">Please contact support regarding the balance shortage</div>
                                <div style="font-weight:600; margin-bottom:2px;">Required amount:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-size:0.75rem; margin-bottom:4px;">${ethers.utils.formatEther(totalExpectedFees)} ETH</div>
                                <div style="margin-top:6px; font-size:0.7rem; color:rgba(0,0,0,0.7);">Exact wei: ${totalExpectedFees.toString()}</div>
                            </div>
                        </div>
                    `;
                    } else if (CONTRACTBalance.lt(totalExpectedFees)) {
                        const shortfall = totalExpectedFees.sub(CONTRACTBalance);
                        console.log('⚠️ CONTRACT UNDERFUNDED! Has', ethers.utils.formatEther(CONTRACTBalance), 'but owes', ethers.utils.formatEther(totalExpectedFees));
                        console.log('💸 SHORTFALL:', ethers.utils.formatEther(shortfall), 'ETH');
                        console.log('🔧 TO FIX: Send exactly', ethers.utils.formatEther(shortfall), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('🎯 EXACT SHORTFALL IN WEI:', shortfall.toString());

                        resultHTML = `
                        <div style="background:#fef3c7; color:#d97706; padding:12px; border-radius:6px; border-left:4px solid #d97706;">
                            <div style="font-weight:600; margin-bottom:8px;">CONTRACT UNDERFUNDED!</div>
                            <div style="margin-bottom:4px;">Expected fees: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Actual balance: <strong>${ethers.utils.formatEther(CONTRACTBalance)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Shortfall: <strong>${ethers.utils.formatEther(shortfall)} ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">TO FIX:</div>
                                <div style="margin-bottom:4px;">Send exactly <strong>${ethers.utils.formatEther(shortfall)} ETH</strong></div>
                                <div style="font-weight:600; margin-bottom:2px;">Send to this CONTRACT address:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-size:0.75rem; margin-bottom:4px; word-break:break-all;">${CONTRACTAddress}</div>
                                <div style="margin-top:6px; font-size:0.7rem; color:rgba(0,0,0,0.7);">Exact wei: ${shortfall.toString()}</div>
                            </div>
                        </div>
                    `;
                    } else {
                        const excess = CONTRACTBalance.sub(totalExpectedFees);
                        console.log('✅ CONTRACT has sufficient balance');
                        console.log('💰 EXCESS ETH (safe to rescue):', ethers.utils.formatEther(excess), 'ETH');
                        console.log('🎯 EXCESS IN WEI:', excess.toString());

                        resultHTML = `
                        <div style="background:#d1fae5; color:#065f46; padding:12px; border-radius:6px; border-left:4px solid #10b981;">
                            <div style="font-weight:600; margin-bottom:8px;">CONTRACT BALANCE OK!</div>
                            <div style="margin-bottom:4px;">Expected fees: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Actual balance: <strong>${ethers.utils.formatEther(CONTRACTBalance)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Excess (safe to rescue): <strong>${ethers.utils.formatEther(excess)} ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">CONTRACT Address:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-size:0.75rem; margin-bottom:4px; word-break:break-all;">${CONTRACTAddress}</div>
                            </div>
                        </div>
                    `;
                    }

                    resultDiv.innerHTML = resultHTML;

                } catch (error) {
                    console.error('❌ Balance check error:', error);
                    resultDiv.innerHTML = `
                    <div style="background:#fee2e2; color:#dc2626; padding:12px; border-radius:6px;">
                        <div style="font-weight:600; margin-bottom:4px;">❌ Balance Check Failed</div>
                        <div style="font-size:0.8rem;">${error.message}</div>
                    </div>
                `;
                }
            }

            // Helper function to adjust button group layout when buttons are hidden
            function adjustButtonGroupLayout() {
                const switchBtn = document.getElementById('switchNetworkBtn');
                const buttonGroup = switchBtn?.parentElement;

                if (buttonGroup && buttonGroup.classList.contains('btn-group-2')) {
                    if (switchBtn.style.display === 'none') {
                        buttonGroup.classList.remove('btn-group-2');
                        buttonGroup.classList.add('btn-group-full');
                    } else {
                        buttonGroup.classList.remove('btn-group-full');
                        buttonGroup.classList.add('btn-group-2');
                    }
                }
            }

            // Simple function to check CONTRACT ETH balance vs expected fees
            async function checkCONTRACTBalance() {
                console.log('🔍 CHECKING CONTRACT BALANCE VS EXPECTED FEES');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    showStatus('🔍 Checking CONTRACT balance...', 'info');

                    // Get expected fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalExpectedFees = creatorFees.add(platformFees);

                    // Get actual CONTRACT balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);

                    console.log('💰 Expected creator fees:', ethers.utils.formatEther(creatorFees), 'ETH');
                    console.log('🏢 Expected platform fees:', ethers.utils.formatEther(platformFees), 'ETH');
                    console.log('📊 Total expected fees:', ethers.utils.formatEther(totalExpectedFees), 'ETH');
                    console.log('🏦 Actual CONTRACT balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH');

                    if (CONTRACTBalance.eq(0)) {
                        console.log('❌ CONTRACT IS EMPTY! All ETH was drained.');
                        console.log('🔧 TO FIX: Send exactly', ethers.utils.formatEther(totalExpectedFees), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('🎯 EXACT AMOUNT IN WEI:', totalExpectedFees.toString());
                        showStatus('❌ CONTRACT has 0 ETH - fees were drained by rescue function!', 'error');
                    } else if (CONTRACTBalance.lt(totalExpectedFees)) {
                        const shortfall = totalExpectedFees.sub(CONTRACTBalance);
                        console.log('⚠️ CONTRACT UNDERFUNDED! Has', ethers.utils.formatEther(CONTRACTBalance), 'but owes', ethers.utils.formatEther(totalExpectedFees));
                        console.log('💸 SHORTFALL:', ethers.utils.formatEther(shortfall), 'ETH');
                        console.log('🔧 TO FIX: Send exactly', ethers.utils.formatEther(shortfall), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('🎯 EXACT SHORTFALL IN WEI:', shortfall.toString());
                        showStatus('⚠️ CONTRACT underfunded - rescue function drained some fees', 'error');
                    } else {
                        const excess = CONTRACTBalance.sub(totalExpectedFees);
                        console.log('✅ CONTRACT has sufficient balance');
                        console.log('💰 EXCESS ETH (safe to rescue):', ethers.utils.formatEther(excess), 'ETH');
                        console.log('🎯 EXCESS IN WEI:', excess.toString());
                        showStatus('✅ CONTRACT balance OK - withdrawal should work', 'success');
                    }

                } catch (error) {
                    console.error('❌ Balance check error:', error);
                    showStatus('❌ Balance check failed: ' + error.message, 'error');
                }
            }

            // Comprehensive rescue function for stuck tokens
            async function rescueStuckTokensComprehensive() {
                console.log('🚀 Comprehensive rescue function called!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    console.log('🔄 Starting comprehensive token rescue...');

                    // Get user's tokens
                    const userTokens = await getUserTokens(userAddress);
                    console.log('📋 User tokens found:', userTokens.length);

                    if (userTokens.length === 0) {
                        showStatus('No tokens found to rescue', 'error');
                        return;
                    }

                    const tokenAddress = userTokens[0][0]; // First token address
                    const tokenId = userTokens[0][4]; // Token ID
                    console.log('🎯 Rescuing token:', tokenAddress, 'with ID:', tokenId.toString());

                    // Check CONTRACT token balance
                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function symbol() view returns (string)"
                    ];

                    const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                    const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                    const tokenSymbol = await tokenCONTRACT.symbol();

                    console.log('🏦 CONTRACT balance of', tokenSymbol + ':', ethers.utils.formatEther(CONTRACTTokenBalance));

                    if (CONTRACTTokenBalance.eq(0)) {
                        showStatus('No tokens stuck in CONTRACT to rescue', 'info');
                        return;
                    }

                    // Method 1: collectFees with tokenId
                    showStatus('Method 1: Collecting LP fees for token...', 'info');
                    try {
                        const collectTx = await CONTRACT.collectFees(tokenId);
                        console.log('⏳ CollectFees transaction sent:', collectTx.hash);

                        const collectReceipt = await collectTx.wait();
                        console.log('✅ CollectFees confirmed:', collectReceipt.transactionHash);

                        showStatus('✅ LP fees collected successfully! Check your balances.', 'success');
                        await checkPlatformFees();
                        return;

                    } catch (collectError) {
                        console.log('❌ collectFees failed:', collectError.message);
                    }

                    // Method 2: rescueAndSellStuckTokens
                    showStatus('Method 2: Using rescue function...', 'info');
                    try {
                        const rescueTx = await CONTRACT.rescueAndSellStuckTokens([tokenAddress]);
                        console.log('⏳ Rescue transaction sent:', rescueTx.hash);

                        const rescueReceipt = await rescueTx.wait();
                        console.log('✅ Rescue confirmed:', rescueReceipt.transactionHash);

                        showStatus('✅ Tokens rescued and converted to ETH!', 'success');
                        await checkPlatformFees();
                        return;

                    } catch (rescueError) {
                        console.log('❌ rescueAndSellStuckTokens failed:', rescueError.message);
                    }

                    showStatus('❌ All rescue methods failed. Tokens may need manual intervention.', 'error');

                } catch (error) {
                    console.error('Comprehensive rescue error:', error);
                    showStatus('❌ Rescue failed: ' + error.message, 'error');
                }
            }

            // Check if token is in dev buy window (removed - function doesn't exist in deployed CONTRACT)
            async function checkDevBuyWindow(tokenAddress) {
                try {
                    // These functions are not available in the deployed CONTRACT
                    console.log('Anti-sniper functions not available in deployed CONTRACT');
                    return { inWindow: false, remainingTime: 0 };
                } catch (error) {
                    console.error('Dev buy window check error:', error.message);
                    return { inWindow: false, remainingTime: 0 };
                }
            }

            // Helper function to format small ETH amounts properly
            function formatSmallETHAmount(ethAmount) {
                const num = parseFloat(ethAmount);
                const usdAmount = num * currentETHPrice;

                let ethDisplay = "";
                if (num === 0) {
                    ethDisplay = "0.0000 ETH";
                } else if (num > 0 && num < 0.000001) {
                    ethDisplay = num.toExponential(6) + " ETH";
                } else if (num > 0 && num < 0.0001) {
                    ethDisplay = num.toFixed(12) + " ETH";
                } else {
                    ethDisplay = num.toFixed(6) + " ETH";
                }

                // Add USD amount
                if (num === 0) {
                    return ethDisplay + " ($0.00)";
                } else if (usdAmount < 0.01) {
                    return ethDisplay + " (<$0.01)";
                } else {
                    return ethDisplay + " ($" + usdAmount.toFixed(2) + ")";
                }
            }

            // Helper function to check claimable token amounts
            async function checkClaimableTokenAmounts() {
                if (!CONTRACT || !userAddress) return;

                try {
                    const tokenAmountsList = document.getElementById('tokenAmountsList');
                    const claimableSection = document.getElementById('claimableTokenAmounts');

                    if (!tokenAmountsList || !claimableSection) return;

                    // Get user's created tokens
                    const tokens = [];
                    let tokenIndex = 0;
                    let maxAttempts = 50;

                    while (tokenIndex < maxAttempts) {
                        try {
                            const tokenInfo = await CONTRACT.createdTokens(userAddress, tokenIndex);
                            if (tokenInfo[0] && tokenInfo[0] !== '0x0000000000000000000000000000000000000000') {
                                tokens.push({
                                    address: tokenInfo[0],
                                    name: tokenInfo[2] || 'Unknown Token',
                                    tokenId: tokenInfo[4]
                                });
                                tokenIndex++;
                            } else {
                                break;
                            }
                        } catch (e) {
                            break;
                        }
                    }

                    if (tokens.length === 0) {
                        claimableSection.style.display = 'none';
                        return;
                    }

                    // Check each token for claimable amounts
                    let hasClaimableTokens = false;
                    let tokenAmountsHTML = '';

                    for (const token of tokens) {
                        try {
                            // Try to simulate batchSwapTokenFees to see if there are claimable amounts
                            const canClaim = await CONTRACT.callStatic.batchSwapTokenFees(userAddress, token.address)
                                .then(() => true)
                                .catch(() => false);

                            if (canClaim) {
                                tokenAmountsHTML += `
                                <div style="margin-bottom: 4px; padding: 4px 8px; background: #e6fffa; border-radius: 4px; border: 1px solid #81e6d9;">
                                    <span style="font-weight: 600;">${token.name}</span>
                                    <span style="color: #2c7a7b; font-size: 0.65rem; margin-left: 4px;">• Has claimable tokens</span>
                                </div>
                            `;
                                hasClaimableTokens = true;
                            }
                        } catch (e) {
                            // Ignore errors for individual tokens
                        }
                    }

                    if (hasClaimableTokens) {
                        tokenAmountsList.innerHTML = tokenAmountsHTML;
                        claimableSection.style.display = 'block';
                    } else {
                        claimableSection.style.display = 'none';
                    }

                } catch (error) {
                    console.log('Error checking claimable token amounts:', error.message);
                    document.getElementById('claimableTokenAmounts').style.display = 'none';
                }
            }

            // Helper function to update all fee displays
            function updateAllFeeDisplays(creatorFeesETH, platformFeesETH, totalLifetimeETH = "0", userLifetimeETH = "0") {
                console.log("🔄 Updating all fee displays...");

                // Update creator fees main display with lifetime total in parentheses
                const creatorFeesElement = document.getElementById('creatorFees');
                if (creatorFeesElement) {
                    const formattedCreator = formatSmallETHAmount(creatorFeesETH);
                    const formattedLifetime = formatSmallETHAmount(userLifetimeETH);

                    // Show withdrawable + lifetime total
                    if (parseFloat(userLifetimeETH) > 0) {
                        creatorFeesElement.innerHTML = `${formattedCreator}<br><small style="color:#666;">Lifetime: ${formattedLifetime}</small>`;
                    } else {
                        creatorFeesElement.textContent = formattedCreator;
                    }
                    console.log("✅ Updated creatorFees:", formattedCreator, "| Lifetime:", formattedLifetime);
                }

                // Update withdrawable creator fees
                const withdrawableElement = document.getElementById('withdrawableCreatorFees');
                if (withdrawableElement) {
                    const formattedWithdrawable = formatSmallETHAmount(creatorFeesETH);
                    withdrawableElement.textContent = formattedWithdrawable; // Show full amount with USD
                    console.log("✅ Updated withdrawableCreatorFees:", formattedWithdrawable);
                }

                // Update Creator Dashboard card title - keep it simple
                const dashboardTitle = document.getElementById('creatorDashboardTitle');
                if (dashboardTitle) {
                    dashboardTitle.textContent = 'Creator Dashboard';
                }

                // Update platform fees with lifetime total
                const platformFeesElement = document.getElementById('platformFeesAmount');
                if (platformFeesElement) {
                    const formattedPlatform = formatSmallETHAmount(platformFeesETH);
                    const formattedTotalLifetime = formatSmallETHAmount(totalLifetimeETH);

                    // Show withdrawable + lifetime total for platform
                    if (parseFloat(totalLifetimeETH) > 0) {
                        const platformLifetime = (parseFloat(totalLifetimeETH) * 0.5).toFixed(12); // Platform gets 50%
                        const formattedPlatformLifetime = formatSmallETHAmount(platformLifetime.toString());
                        platformFeesElement.innerHTML = `${formattedPlatform}<br><small style="color:#666;">Lifetime: ${formattedPlatformLifetime}</small>`;
                    } else {
                        platformFeesElement.textContent = formattedPlatform;
                    }
                    console.log("✅ Updated platformFeesAmount:", formattedPlatform, "| Total lifetime:", formattedTotalLifetime);
                }

                // Check for claimable token amounts
                checkClaimableTokenAmounts().catch(e => console.log('Error checking tokens:', e.message));
            }



            // Function to withdraw all accumulated creator fees
            async function withdrawCreatorFees() {
                console.log('💰 Withdrawing all creator fees...');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    showStatus('Preparing ETH withdrawal...', 'info');

                    // First check how much the creator can withdraw
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log('💰 Creator fees to withdraw:', ethers.utils.formatEther(creatorFees), 'ETH');

                    if (creatorFees.eq(0)) {
                        showStatus('No ETH fees available for withdrawal', 'info');
                        return;
                    }

                    // Call the CONTRACT function to withdraw creator fees
                    const tx = await CONTRACT.withdrawCreatorFees();
                    console.log('⏳ Withdraw transaction sent:', tx.hash);
                    showStatus(`Processing withdrawal of ${ethers.utils.formatEther(creatorFees)} ETH...`, 'info');

                    const receipt = await tx.wait();
                    console.log('✅ Withdraw confirmed:', receipt.transactionHash);

                    // Parse the receipt for events
                    if (receipt.logs && receipt.logs.length > 0) {
                        console.log('📋 Withdrawal completed with', receipt.logs.length, 'events');

                        // Look for CreatorWithdraw event
                        const withdrawnAmount = ethers.utils.formatEther(creatorFees);
                        showStatus(`Successfully withdrew ${withdrawnAmount} ETH to your wallet!`, 'success');
                    } else {
                        showStatus('Withdrawal completed successfully!', 'success');
                    }

                    // Refresh fee displays after withdrawal
                    await checkPlatformFees();

                } catch (error) {
                    console.error('❌ Withdraw error:', error);
                    if (error.message.includes('insufficient')) {
                        showStatus('Insufficient balance to complete withdrawal', 'error');
                    } else if (error.message.includes('denied')) {
                        showStatus('Transaction cancelled by user', 'error');
                    } else if (error.message.includes('gas')) {
                        showStatus('Transaction failed due to network issues', 'error');
                    } else {
                        showStatus('Withdrawal failed: ' + error.message, 'error');
                    }
                }
            }

            async function checkPlatformFees() {
                console.log("🔄 checkPlatformFees() called");
                try {
                    if (!provider || !CONTRACT) {
                        console.error("❌ Provider or CONTRACT not available");
                        alert("Please connect your wallet first!");
                        return null;
                    }

                    console.log("📞 Calling CONTRACT functions...");
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalTokenCount = await CONTRACT.getTokenCount();

                    // Get all tokens by iterating through the allTokens array
                    const allTokens = [];
                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            allTokens.push(tokenInfo);
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break; // Stop if we hit an error
                        }
                    }
                    let totalLifetimeFees = ethers.BigNumber.from("0");
                    let userLifetimeFees = ethers.BigNumber.from("0");

                    if (allTokens && allTokens.length > 0) {
                        const currentUser = await signer.getAddress();

                        for (const token of allTokens) {
                            const tokenTotalFees = ethers.BigNumber.from(token.totalFeesETH || "0");
                            totalLifetimeFees = totalLifetimeFees.add(tokenTotalFees);

                            // If this user created this token, add to their lifetime total
                            if (token.creator && token.creator.toLowerCase() === currentUser.toLowerCase()) {
                                // Creator gets 50% of total fees (PLATFORM_SHARE = 50%)
                                const creatorPortion = tokenTotalFees.mul(50).div(100);
                                userLifetimeFees = userLifetimeFees.add(creatorPortion);
                            }
                        }
                    }

                    // Also get current withdrawable creator fees
                    let creatorFees;
                    try {
                        const userAddress = await signer.getAddress();
                        creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    } catch (e) {
                        console.log("⚠️ Could not get creator fees:", e.message);
                        creatorFees = ethers.utils.parseEther("0");
                    }

                    console.log("📊 Raw platform fees (withdrawable):", platformFees.toString());
                    console.log("📊 Raw creator fees (withdrawable):", creatorFees.toString());
                    console.log("📊 Total lifetime fees collected:", ethers.utils.formatEther(totalLifetimeFees));
                    console.log("📊 User lifetime fees earned:", ethers.utils.formatEther(userLifetimeFees));
                    console.log("📊 Token count:", totalTokenCount.toString());

                    // Format fees using ethers
                    const platformFeesFormatted = ethers.utils.formatEther(platformFees);
                    const creatorFeesFormatted = ethers.utils.formatEther(creatorFees);
                    const totalLifetimeFormatted = ethers.utils.formatEther(totalLifetimeFees);
                    const userLifetimeFormatted = ethers.utils.formatEther(userLifetimeFees);

                    console.log("� Formatted platform fees:", platformFeesFormatted);
                    console.log("📊 Formatted creator fees:", creatorFeesFormatted);

                    // Update all fee displays with proper formatting
                    updateAllFeeDisplays(creatorFeesFormatted, platformFeesFormatted, totalLifetimeFormatted, userLifetimeFormatted);

                    // Status messages
                    if (platformFees.eq(0) && creatorFees.eq(0)) {
                        if (totalLifetimeFees.gt(0)) {
                            console.log("✅ Lifetime fees were collected and withdrawn!");
                            console.log("   Total fees ever collected:", formatSmallETHAmount(totalLifetimeFormatted));
                            console.log("   Platform lifetime earnings:", formatSmallETHAmount((parseFloat(totalLifetimeFormatted) * 0.5).toFixed(12)));
                            console.log("   Your lifetime earnings:", formatSmallETHAmount(userLifetimeFormatted));
                            console.log("   Current withdrawable: 0 ETH (already withdrawn)");

                            // Remove distracting lifetime fee notifications
                            // showStatus(`✅ Lifetime fees collected: ${formatSmallETHAmount(totalLifetimeFormatted)} | Your share: ${formatSmallETHAmount(userLifetimeFormatted)}`, 'success');
                        } else {
                            console.log("💡 No fees collected yet. This means:");
                            console.log("   - No one has traded your tokens yet");
                            console.log("   - Or you need to call collectFees() first");
                            console.log("   - Try the 'Collect All Fees' button");
                            // showStatus('No fees collected yet - tokens may not have been traded or fees need collection', 'info');
                        }
                    } else {
                        console.log("✅ Fees available!");
                        console.log("   Platform fees:", formatSmallETHAmount(platformFeesFormatted));
                        console.log("   Creator fees:", formatSmallETHAmount(creatorFeesFormatted));
                        console.log("💡 Click withdraw buttons to claim them!");

                        // Remove distracting platform fee notifications
                        // if (parseFloat(platformFeesFormatted) > 0) {
                        //     showStatus(`✅ Platform fees ready for withdrawal: ${formatSmallETHAmount(platformFeesFormatted)}`, 'success');
                        // }
                    }

                    return {
                        platformFees: formatSmallETHAmount(platformFeesFormatted),
                        creatorFees: formatSmallETHAmount(creatorFeesFormatted),
                        tokenCount: totalTokenCount.toString()
                    };

                } catch (error) {
                    console.error("❌ Error checking platform fees:", error);
                    alert("Error checking fees: " + error.message);
                    return null;
                }
            }

            async function collectAllTokenFees() {
                console.log("🔄 collectAllTokenFees() called");
                try {
                    if (!signer) {
                        console.error("❌ No signer available");
                        alert("Please connect your wallet first!");
                        return;
                    }

                    console.log("� Starting fee collection process...");

                    // Use getUserTokens helper instead of getCreatedTokens to avoid ABI issues
                    const userAddress = await signer.getAddress();
                    console.log("👤 User address:", userAddress);

                    console.log("📞 Calling getUserTokens()...");
                    const userTokens = await getUserTokens(userAddress);

                    console.log("📊 Found", userTokens.length, "tokens created by you");

                    if (userTokens.length === 0) {
                        alert("No tokens found for your address");
                        return;
                    }

                    let successCount = 0;
                    let errorCount = 0;
                    let totalCollected = ethers.utils.parseEther("0");

                    for (let i = 0; i < userTokens.length; i++) {
                        try {
                            const tokenInfo = userTokens[i];
                            const tokenId = tokenInfo.tokenId;

                            console.log(`📊 Token ${i}: ${tokenInfo.name} (${tokenInfo.symbol})`);
                            console.log(`🎯 Attempting to collect fees for tokenId: ${tokenId.toString()}`);

                            // Check platform fees before collection
                            const platformFeesBefore = await CONTRACT.getPlatformFees();
                            console.log("💰 Platform fees before:", ethers.utils.formatEther(platformFeesBefore));

                            console.log("🚀 Calling CONTRACTWithSigner.collectFees()...");
                            const tx = await CONTRACTWithSigner.collectFees(tokenId);
                            console.log("✅ Transaction sent:", tx.hash);

                            console.log("⏳ Waiting for confirmation...");
                            const receipt = await tx.wait();
                            console.log("✅ Transaction confirmed in block:", receipt.blockNumber);

                            // Check platform fees after collection
                            const platformFeesAfter = await CONTRACT.getPlatformFees();
                            console.log("💰 Platform fees after:", ethers.utils.formatEther(platformFeesAfter));

                            const collected = platformFeesAfter.sub(platformFeesBefore);

                            if (collected.gt(0)) {
                                const collectedFormatted = ethers.utils.formatEther(collected);
                                console.log(`✅ Collected ${collectedFormatted} ETH in fees for token ${i}`);
                                totalCollected = totalCollected.add(collected);
                                successCount++;
                            } else {
                                console.log(`📭 No fees available for token ${i} yet`);
                            }

                        } catch (error) {
                            console.log(`⚠️ Could not collect fees for token ${i}:`, error.message);
                            errorCount++;

                            if (error.message.includes("No fees") || error.message.includes("amount is 0")) {
                                console.log("💡 No fees available for this token yet");
                            } else if (error.message.includes("execution reverted")) {
                                console.log("💡 Transaction reverted - likely no fees to collect");
                            }
                        }
                    }

                    // Show results
                    if (successCount > 0) {
                        const totalFormatted = ethers.utils.formatEther(totalCollected);
                        const message = `✅ Successfully collected ${totalFormatted} ETH in platform fees from ${successCount} token(s)!`;
                        console.log(message);
                        alert(message);
                    } else {
                        const message = `📭 No fees available to collect from ${userTokens.length} token(s). Either no trading has occurred yet or fees are below the minimum threshold.`;
                        console.log(message);
                        alert(message);
                    }

                    // Refresh the display
                    console.log("🔄 Refreshing platform fees display...");
                    await checkPlatformFees();

                } catch (error) {
                    console.error("❌ Error collecting fees:", error);
                    alert("Error collecting fees: " + error.message);
                }
            }

            async function withdrawPlatformFees() {
                try {
                    if (!signer) {
                        throw new Error("Please connect your wallet first");
                    }

                    console.log("Withdrawing platform fees...");
                    const tx = await CONTRACTWithSigner.withdrawPlatformFees();
                    await tx.wait();

                    console.log("✅ Platform fees withdrawn!");
                    alert("Platform fees withdrawn successfully!");

                    // Refresh the display
                    await checkPlatformFees();

                } catch (error) {
                    console.error("Error withdrawing platform fees:", error);
                    alert("Error withdrawing platform fees: " + error.message);
                }
            }

            // Enhanced loadUserTokens with anti-sniper status
            async function loadUserTokensEnhanced(loadMore = false) {
                const list = document.getElementById('myTokensList');
                if (!list) return;
                if (!userAddress) {
                    list.textContent = 'Connect wallet to load your tokens...';
                    return;
                }

                if (!loadMore) userTokensPage = 0;

                try {
                    if (!loadMore) list.textContent = 'Loading your tokens...';
                    console.log('[Dashboard] Loading user tokens with anti-sniper info for', userAddress, 'page', userTokensPage);
                    const allTokens = await getUserTokens(userAddress);
                    console.log('[Dashboard] Total tokens:', allTokens.length);

                    let fees = null;
                    if (capability.creatorFees) {
                        try {
                            console.log('💰 Fetching creator fees for:', userAddress);
                            fees = await CONTRACT.getCreatorFees(userAddress);
                            const feeAmount = ethers.utils.formatEther(fees);
                            console.log('💰 Creator fees found:', feeAmount, 'ETH');
                        } catch (e) {
                            if (!capability.suppressedCreatorFeeWarn) {
                                console.warn('[Dashboard] Disabling creator aggregate fee probe after revert.');
                                capability.suppressedCreatorFeeWarn = true;
                            }
                            capability.creatorFees = false;
                            fees = null;
                        }
                    }

                    // Check for accumulated token balances
                    let tokenBalance = null;
                    try {
                        tokenBalance = await CONTRACT.getCreatorTokenBalance(userAddress);
                    } catch (e) {
                        console.log('Could not check token balance:', e.message);
                    }

                    const wd = document.getElementById('withdrawableCreatorFees');
                    if (wd) wd.textContent = fees ? fmt(fees) : '0.000000';
                    const withdrawBtn = document.getElementById('withdrawMyFeesBtn');
                    if (withdrawBtn) withdrawBtn.disabled = !fees || fees.eq(0);
                    const collectBtn = document.getElementById('collectMyFeesBtn');
                    if (collectBtn) collectBtn.disabled = allTokens.length === 0;

                    if (allTokens.length === 0) {
                        list.textContent = 'You have not launched any tokens yet.';
                        return;
                    }

                    // Pagination logic
                    const startIdx = userTokensPage * TOKENS_PER_PAGE;
                    const endIdx = startIdx + TOKENS_PER_PAGE;
                    const tokens = allTokens.slice(startIdx, endIdx);
                    const hasMore = endIdx < allTokens.length;

                    // Generate table rows with anti-sniper status
                    let tableRows = '';
                    for (const t of tokens) {
                        let raw = undefined;
                        if (t.totalFeesETH !== undefined) raw = t.totalFeesETH;
                        if (!raw && Array.isArray(t)) {
                            if (t.length > 9) raw = t[9];
                            else if (t.length > 7) raw = t[7];
                        }
                        const feeETH = fees ? sanitizeFee(raw, fees) : '0.000000';
                        const feeETHNum = parseFloat(feeETH.replace(/ ETH.*$/, ''));
                        const feeUSD = feeETHNum * currentETHPrice;
                        const fee = feeETHNum.toFixed(6) + ' ETH ($' + feeUSD.toFixed(2) + ')';
                        const name = t.name || t[2];
                        const tokenId = t.tokenId || t[4];
                        const tokenAddress = t.tokenAddress || t[0];

                        // Check anti-sniper status
                        let antiSniperStatus = 'Checking...';
                        try {
                            const devStatus = await checkDevBuyWindow(tokenAddress);
                            if (devStatus.inWindow) {
                                const minutes = Math.floor(devStatus.remainingTime / 60);
                                const seconds = devStatus.remainingTime % 60;
                                antiSniperStatus = `<span style="color:orange;">🛡️ Dev Window: ${minutes}:${seconds.toString().padStart(2, '0')}</span>`;
                            } else {
                                antiSniperStatus = '<span style="color:green;">🌍 Public Trading</span>';
                            }
                        } catch {
                            antiSniperStatus = '<span style="color:gray;">❓ Unknown</span>';
                        }

                        // Check LP NFT status
                        let lpStatus = 'Checking...';
                        try {
                            const nfpm = new ethers.Contract(POSITION_MANAGER_ADDRESS, ["function ownerOf(uint256) view returns (address)"], provider);
                            const ownerAddr = await nfpm.ownerOf(tokenId);
                            const factoryAddr = TOKEN_FACTORY_ADDRESS.toLowerCase();

                            if (ownerAddr.toLowerCase() === factoryAddr) {
                                lpStatus = '<span style="color:green;">🔒 Locked</span>';
                            } else if (ownerAddr.toLowerCase() === userAddress.toLowerCase()) {
                                lpStatus = '<span style="color:red;">⚠️ In Wallet</span>';
                            } else {
                                lpStatus = '<span style="color:orange;">👤 Other</span>';
                            }
                        } catch {
                            lpStatus = '<span style="color:gray;">❓ Unknown</span>';
                        }

                        tableRows += `<tr><td>${name}</td><td><a href="https://basescan.org/token/${tokenAddress}" target="_blank" style="color:#667eea;text-decoration:none;">${tokenAddress.slice(0, 10)}...${tokenAddress.slice(-8)}</a></td><td style="text-align:right;font-weight:600;">${fee}</td><td style="text-align:center;">${antiSniperStatus}</td><td style="text-align:center;">${lpStatus}</td></tr>`;
                    }

                    if (!loadMore) {
                        // Initial load - create full table
                        let html = '<div class="table-container"><table>';
                        html += '<thead><tr><th>Name</th><th>Token Address</th><th>Fees (ETH)</th><th>Trading Status</th><th>LP Status</th></tr></thead>';
                        html += '<tbody>' + tableRows + '</tbody>';
                        html += '</table></div>';

                        // Add token balance info if any
                        if (tokenBalance && tokenBalance.gt(0)) {
                            html += `<div style="margin-top:12px;padding:8px;background:#e3f2fd;border-radius:6px;font-size:0.8rem;">
                            💰 Accumulated Token Fees: ${ethers.utils.formatEther(tokenBalance)} tokens
                            <button onclick="batchSwapTokens()" style="margin-left:8px;padding:2px 6px;font-size:0.7rem;background:#2196f3;color:white;border:none;border-radius:3px;cursor:pointer;">Swap to ETH</button>
                        </div>`;
                        }

                        if (hasMore) {
                            html += `<div style="display:flex;justify-content:center;margin-top:12px;"><button onclick="loadMoreUserTokens()" class="btn btn-secondary">Load More (${allTokens.length - endIdx} remaining)</button></div>`;
                        }

                        list.innerHTML = html;
                    } else {
                        // Load more - append rows to existing table
                        const tbody = list.querySelector('table tbody');
                        if (tbody) {
                            tbody.insertAdjacentHTML('beforeend', tableRows);
                        }

                        // Update load more button
                        const loadMoreBtn = list.querySelector('button');
                        if (loadMoreBtn) {
                            if (hasMore) {
                                loadMoreBtn.textContent = `Load More (${allTokens.length - endIdx} remaining)`;
                            } else {
                                loadMoreBtn.remove();
                            }
                        }
                    }

                    if (!loadMore) {
                        userTokensPage = 1; // Set to 1 after first load
                    } else {
                        userTokensPage++; // Increment only for load more
                    }
                } catch (err) {
                    list.textContent = 'Failed to load';
                    console.error(err);
                }
            }

            // Override the original loadUserTokens with the enhanced version
            loadUserTokens = loadUserTokensEnhanced;
        </script>

        <div class="page-wrapper">
            <div id="riskBanner"
                style="display:none;margin:0 0 18px 0;padding:12px 18px;border-radius:10px;font-size:0.75rem;font-weight:600;line-height:1.35;background:linear-gradient(135deg,#7b1f21,#b11b1e);color:#fff;border:1px solid #ffcccc;box-shadow:0 2px 6px -1px rgba(0,0,0,0.25);">
                <span id="riskBannerText">Legacy factory detected – LP NFT may reside in creator wallet. Redeploy secure
                    factory or update address.</span>
            </div>
            <div class="container">
                <div class="header">
                    <h1>BASE TOKEN LOCKING</h1>
                    <p style="text-align: center;">Lock ERC20 tokens for a set period of time</p>
                </div>

                <div class="main-content">
                    <!-- Connection Status -->
                    <div class="card">
                        <div class="card-title">Wallet Connection</div>
                        <div id="connectionStatus" class="status status-info">
                            Click "Connect Wallet" to get started!
                        </div>
                        <div class="btn-group btn-group-2">
                            <button id="connectBtn" class="btn btn-primary">Connect Wallet</button>
                            <button id="switchNetworkBtn" class="btn btn-secondary" style="display: none;">Switch to
                                BASE</button>
                            <!-- Removed manual price update button; price updates automatically every 5 minutes -->
                        </div>
                        <div id="priceStatus"
                            style="margin-top: 12px; font-size: 0.9rem; color: var(--violet-muted); display: none;">
                            Current ETH Price: $<span id="currentPrice">4400.00</span>
                        </div>
                        <div id="factoryMode" style="margin-top:8px;font-size:0.75rem;color:#555;display:none;">Mode: —
                        </div>
                        <div id="lpVaultStatus" style="margin-top:4px;font-size:0.7rem;color:#666;display:none;">LP
                            Vault: —</div>
                    </div>


                    <div class="grid-2" id="mainContent" style="display: none;">

                        <!-- Token Creation Form -->
                        <!---->
                        <div class="card" id="tokenLockingCard">
                            <div class="card-title">Lock Token</div>
                            <form id="lockForm">
                                <div class="form-group">
                                    <label class="form-label" for="tokenAddress">ERC20 TOKEN ADDRESS</label>
                                    <input type="text" id="tokenAddress" class="form-input" placeholder="0x..."
                                        maxlength="32" required>
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="beneficiary">BENEFICIARY ADDRESS</label>
                                    <input type="text" id="beneficiary" class="form-input" placeholder="e.g., MAT"
                                        maxlength="32" required>
                                    <button type="button" id="setSelfBeneficiary"
                                        style="padding:4px 12px;min-width:56px;align-self:flex-start;margin-top:12px;">ME</button>
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="amount">AMOUNT</label>
                                    <input type="number" id="amount" class="form-input" required min="0" step="any"
                                        placeholder="AMOUNT">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="lockName">LOCK NAME</label>
                                    <input type="text" id="lockName" class="form-input" rrequired maxlength="64"
                                        placeholder="LOCK NAME">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="lockName">UNLOCK AFTER</label>
                                    <div style="display:flex;gap:8px;align-items:center;">
                                        <input type="number" id="unlockDays" min="0" value="0" style="width:80px;"
                                            placeholder="Days" /> days
                                        <input type="number" id="unlockHours" min="0" value="0" style="width:80px;"
                                            placeholder="Hours" /> hours
                                        <input type="number" id="unlockMinutes" min="0" value="0" style="width:80px;"
                                            placeholder="Minutes" /> minutes
                                    </div>
                                </div>
                                <button type="submit" style="display:block;margin:18px auto 0 auto;">LOCK
                                    TOKENS</button>


                            </form>
                        </div>

                        <div id="status" style="margin-top:1em;"></div>
                        <button id="refreshLocksBtn"
                            style="margin-bottom:12px;width:100%;font-size:1.08em;letter-spacing:0.08em;">REFRESH
                            LOCKS</button>
                        <h3>Your Locks</h3>
                        <ul id="userLocks"></ul>
                    </div>
                    <script>
                        const CONTRACT_ADDRESS = "0x58f7D324A96Eb2932a66d99dd06459aCdc30c29D";
                        const FACTORY_ADDRESS = "0xaaDf8d2919C824BD5573e19F43D7a6aFe4867b56";
                        const FACTORY_ABI = [
                            { "inputs": [{ "internalType": "address", "name": "token", "type": "address" }, { "internalType": "address", "name": "beneficiary", "type": "address" }, { "internalType": "uint256", "name": "days_", "type": "uint256" }, { "internalType": "uint256", "name": "hours_", "type": "uint256" }, { "internalType": "uint256", "name": "minutes_", "type": "uint256" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }, { "internalType": "string", "name": "lockName", "type": "string" }], "name": "createLock", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
                            { "inputs": [{ "internalType": "address", "name": "user", "type": "address" }], "name": "getUserLocks", "outputs": [{ "internalType": "address[]", "name": "", "type": "address[]" }], "stateMutability": "view", "type": "function" },
                            { "inputs": [], "name": "getAllLocks", "outputs": [{ "internalType": "address[]", "name": "", "type": "address[]" }], "stateMutability": "view", "type": "function" },
                            { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "lock", "type": "address" }, { "indexed": true, "internalType": "address", "name": "creator", "type": "address" }, { "indexed": true, "internalType": "address", "name": "beneficiary", "type": "address" }, { "indexed": false, "internalType": "address", "name": "token", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "releaseTime", "type": "uint256" }, { "indexed": false, "internalType": "string", "name": "lockName", "type": "string" }], "name": "LockCreated", "type": "event" }
                        ];
                        const LOCK_ABI = [
                            { "inputs": [{ "internalType": "address", "name": "token_", "type": "address" }, { "internalType": "address", "name": "beneficiary_", "type": "address" }, { "internalType": "uint256", "name": "releaseTime_", "type": "uint256" }, { "internalType": "uint256", "name": "amount_", "type": "uint256" }, { "internalType": "string", "name": "lockName_", "type": "string" }], "stateMutability": "nonpayable", "type": "constructor" },
                            { "inputs": [], "name": "amount", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
                            { "inputs": [], "name": "beneficiary", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" },
                            { "inputs": [], "name": "lockName", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" },
                            { "inputs": [], "name": "release", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
                            { "inputs": [], "name": "releaseTime", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
                            { "inputs": [], "name": "released", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" },
                            { "inputs": [], "name": "token", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }
                        ];

                        // Fee collector address from config
                        const FEE_COLLECTOR_ADDRESS = window.LOCK_FEE_CONFIG?.BASE_FEE_COLLECTOR || "0x1234567890123456789012345678901234567890";

                        let provider, signer, userAddress;

                        async function connectWallet() {
                            console.log('🔵 Base locking: connectWallet function called - using token furnace style');

                            // Check if we already have a connection from the modal
                            if (window.currentAddress && window.currentProvider) {
                                provider = window.currentProvider;
                                userAddress = window.currentAddress;

                                // Create signer from provider
                                if (window.ethers && provider) {
                                    const ethersProvider = new ethers.providers.Web3Provider(provider);
                                    signer = ethersProvider.getSigner();
                                }

                                console.log('✅ Using existing wallet connection');
                                document.getElementById('walletAddress').textContent = 'Connected: ' + userAddress;

                                loadUserLocks();
                                loadLockCreationFee();
                                return;
                            }

                            // If no connection exists, show the modal
                            console.log('🔗 No existing connection, showing wallet modal');
                            showChainSelectionModal();
                        }

                        // Wait for wallet.js to be available
                        function waitForWalletSystem() {
                            console.log('🔍 Waiting for wallet system... wildWestWallet exists:', !!window.wildWestWallet);

                            if (window.wildWestWallet) {
                                console.log('✅ Wallet system loaded, setting up connect button');
                                const connectBtn = document.getElementById('connectWalletBtn');

                                if (connectBtn) {
                                    connectBtn.onclick = function () {
                                        // UNBLOCK wallet access since user explicitly requested connection
                                        window.WALLET_AUTO_CONNECTION_BLOCKED = false;
                                        console.log('✅ Base locking: Wallet auto-connection block lifted by user action');

                                        // DETECT ALL AVAILABLE EVM WALLETS
                                        console.log('🔍 Detecting available EVM wallets...');
                                        const availableEvmWallets = detectAvailableEvmWallets();
                                        console.log('� Available EVM wallets:', availableEvmWallets);

                                        if (availableEvmWallets.length === 0) {
                                            alert('No EVM wallets detected. Please install MetaMask, Coinbase Wallet, or another EVM wallet.');
                                            return;
                                        }

                                        // SHOW WALLET SELECTION OR CONNECT DIRECTLY
                                        if (availableEvmWallets.length === 1) {
                                            // Only one wallet available, connect directly
                                            const wallet = availableEvmWallets[0];
                                            console.log('🎯 Using single available EVM wallet:', wallet.name);
                                            connectToSelectedEvmWallet(wallet);
                                        } else {
                                            // Multiple wallets available, show selection modal
                                            console.log('📋 Multiple wallets available, showing selection modal');
                                            showEvmWalletSelectionModal(availableEvmWallets, connectToSelectedEvmWallet);
                                        }
                                    };
                                    connectBtn.textContent = 'CONNECT WALLET';
                                    console.log('✅ Connect button configured with anti-auto-connection safeguards');
                                } else {
                                    console.error('❌ Connect button not found');
                                }

                                // --- EVM WALLET DETECTION FUNCTIONS ---
                                function detectAvailableEvmWallets() {
                                    const wallets = [];

                                    if (window.ethereum) {
                                        // Check for multiple providers
                                        if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                                            window.ethereum.providers.forEach((provider, index) => {
                                                if (provider.isMetaMask && !provider.isPhantom) {
                                                    wallets.push({
                                                        name: 'MetaMask',
                                                        icon: '🦊',
                                                        provider: provider,
                                                        type: 'metamask'
                                                    });
                                                } else if (provider.isCoinbaseWallet) {
                                                    wallets.push({
                                                        name: 'Coinbase Wallet',
                                                        icon: '🔵',
                                                        provider: provider,
                                                        type: 'coinbase'
                                                    });
                                                } else if (provider.isRainbow) {
                                                    wallets.push({
                                                        name: 'Rainbow',
                                                        icon: '🌈',
                                                        provider: provider,
                                                        type: 'rainbow'
                                                    });
                                                } else if (provider.isTrust) {
                                                    wallets.push({
                                                        name: 'Trust Wallet',
                                                        icon: '🛡️',
                                                        provider: provider,
                                                        type: 'trust'
                                                    });
                                                } else if (provider.isPhantom && !provider.isMetaMask) {
                                                    wallets.push({
                                                        name: 'Phantom (EVM)',
                                                        icon: '👻',
                                                        provider: provider,
                                                        type: 'phantom-evm'
                                                    });
                                                }
                                            });
                                        } else {
                                            // Single provider
                                            if (window.ethereum.isMetaMask && !window.ethereum.isPhantom) {
                                                wallets.push({
                                                    name: 'MetaMask',
                                                    icon: '🦊',
                                                    provider: window.ethereum,
                                                    type: 'metamask'
                                                });
                                            } else if (window.ethereum.isCoinbaseWallet) {
                                                wallets.push({
                                                    name: 'Coinbase Wallet',
                                                    icon: '🔵',
                                                    provider: window.ethereum,
                                                    type: 'coinbase'
                                                });
                                            } else if (window.ethereum.isPhantom) {
                                                wallets.push({
                                                    name: 'Phantom (EVM)',
                                                    icon: '👻',
                                                    provider: window.ethereum,
                                                    type: 'phantom-evm'
                                                });
                                            } else {
                                                wallets.push({
                                                    name: 'Unknown EVM Wallet',
                                                    icon: '💼',
                                                    provider: window.ethereum,
                                                    type: 'unknown'
                                                });
                                            }
                                        }
                                    }

                                    return wallets;
                                }

                                function showEvmWalletSelectionModal(wallets, callback) {
                                    const modal = document.createElement('div');
                                    modal.className = 'wallet-modal-overlay';
                                    modal.style.cssText = `
                              position: fixed;
                              top: 0;
                              left: 0;
                              right: 0;
                              bottom: 0;
                              background: rgba(0, 0, 0, 0.9);
                              display: flex;
                              align-items: center;
                              justify-content: center;
                              z-index: 10000;
                              animation: fadeIn 0.2s ease-out;
                            `;

                                    const walletsHtml = wallets.map(wallet => `
                              <button class="wallet-select-btn" data-wallet-type="${wallet.type}" style="
                                display: flex;
                                align-items: center;
                                gap: 1rem;
                                width: 100%;
                                padding: 1rem;
                                margin: 0.5rem 0;
                                border: 2px solid #00eaff;
                                border-radius: 12px;
                                background: rgba(0, 234, 255, 0.1);
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s;
                                font-size: 1.1rem;
                              ">
                                <div style="flex: 1; text-align: left;">
                                  <div style="font-weight: bold;">${wallet.name}</div>
                                  <div style="font-size: 0.9rem; color: #ccc;">Base Network</div>
                                </div>
                                <span style="color: #00eaff;">→</span>
                              </button>
                            `).join('');

                                    modal.innerHTML = `
                              <div style="
                                background: linear-gradient(135deg, #1a1a2e, #16213e);
                                border: 2px solid #00eaff;
                                border-radius: 16px;
                                box-shadow: 0 0 30px rgba(0, 234, 255, 0.3);
                                max-width: 500px;
                                width: 90vw;
                                overflow: hidden;
                              ">
                                <div style="
                                  padding: 1.5rem;
                                  border-bottom: 1px solid rgba(0, 234, 255, 0.2);
                                  display: flex;
                                  justify-content: space-between;
                                  align-items: center;
                                ">
                                  <div>
                                    <h3 style="margin: 0; color: #00eaff; font-size: 1.25rem;">Select Base Wallet</h3>
                                    <p style="margin: 0.5rem 0 0 0; color: #ccc; font-size: 0.9rem;">Choose your wallet for Base network</p>
                                  </div>
                                  <button class="close-modal" style="
                                    background: none;
                                    border: none;
                                    color: #00eaff;
                                    font-size: 1.5rem;
                                    cursor: pointer;
                                  ">×</button>
                                </div>
                                <div style="padding: 1.5rem;">
                                  ${walletsHtml}
                                </div>
                              </div>
                            `;

                                    document.body.appendChild(modal);

                                    // Handle wallet selection
                                    modal.querySelectorAll('.wallet-select-btn').forEach(btn => {
                                        btn.addEventListener('click', async () => {
                                            const walletType = btn.dataset.walletType;
                                            const selectedWallet = wallets.find(w => w.type === walletType);
                                            document.body.removeChild(modal);

                                            if (selectedWallet && callback) {
                                                callback(selectedWallet);
                                            }
                                        });

                                        btn.addEventListener('mouseenter', () => {
                                            btn.style.background = 'rgba(0, 234, 255, 0.2)';
                                            btn.style.transform = 'translateY(-2px)';
                                        });

                                        btn.addEventListener('mouseleave', () => {
                                            btn.style.background = 'rgba(0, 234, 255, 0.1)';
                                            btn.style.transform = 'translateY(0)';
                                        });
                                    });

                                    // Handle close
                                    modal.querySelector('.close-modal').addEventListener('click', () => {
                                        document.body.removeChild(modal);
                                    });

                                    modal.addEventListener('click', (e) => {
                                        if (e.target === modal) {
                                            document.body.removeChild(modal);
                                        }
                                    });
                                }

                                async function connectToSelectedEvmWallet(selectedWallet) {
                                    console.log('🔵 Connecting to selected EVM wallet:', selectedWallet.name);

                                    const connectBtn = document.getElementById('connectWalletBtn');
                                    connectBtn.textContent = 'CONNECTING...';
                                    connectBtn.disabled = true;

                                    try {
                                        // Use the specific provider for this wallet
                                        const accounts = await selectedWallet.provider.request({ method: 'eth_requestAccounts' });

                                        if (accounts.length > 0) {
                                            // Switch to Base network if not already on it
                                            try {
                                                await selectedWallet.provider.request({
                                                    method: 'wallet_switchEthereumChain',
                                                    params: [{ chainId: '0x2105' }], // Base mainnet
                                                });
                                            } catch (switchError) {
                                                // If the chain doesn't exist, add it
                                                if (switchError.code === 4902) {
                                                    await selectedWallet.provider.request({
                                                        method: 'wallet_addEthereumChain',
                                                        params: [{
                                                            chainId: '0x2105',
                                                            chainName: 'Base',
                                                            nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                                                            rpcUrls: [RPC_CONFIG.getBaseEndpoint()],
                                                            blockExplorerUrls: ['https://basescan.org']
                                                        }]
                                                    });
                                                }
                                            }

                                            // Update global state
                                            window.ethereum = selectedWallet.provider;
                                            window.signer = new ethers.providers.Web3Provider(selectedWallet.provider).getSigner();

                                            // Update UI
                                            document.getElementById('walletAddress').textContent = accounts[0];
                                            connectBtn.textContent = 'WALLET CONNECTED';
                                            connectBtn.disabled = false;

                                            console.log('✅ Connected to', selectedWallet.name, 'with address:', accounts[0]);

                                            // Update balance and locks display
                                            await updateBalance();
                                            await loadUserLocks();

                                        } else {
                                            throw new Error('No accounts returned from wallet');
                                        }
                                    } catch (error) {
                                        console.error('❌ Failed to connect to', selectedWallet.name, ':', error);
                                        connectBtn.textContent = 'CONNECT WALLET';
                                        connectBtn.disabled = false;

                                        // Re-block auto-connection on error
                                        window.WALLET_AUTO_CONNECTION_BLOCKED = true;

                                        alert('Failed to connect to ' + selectedWallet.name + ': ' + error.message);
                                    }
                                }
                            } else {
                                console.log('⏳ Wallet system not ready, waiting...');
                                setTimeout(waitForWalletSystem, 100);
                            }
                        }

                        // Initialize token furnace style wallet connection
                        console.log('✅ Base Locking: Token furnace style wallet system ready');

                        // Debug function to test wallet system
                        window.debugWalletSystem = function () {
                            console.log('🔍 DEBUG: Wallet System Status');
                            console.log('• window.wildWestWallet exists:', !!window.wildWestWallet);
                            console.log('• BASE_LOCKING_HANDLES_WALLET_BUTTON:', window.BASE_LOCKING_HANDLES_WALLET_BUTTON);

                            if (window.wildWestWallet) {
                                console.log('• isConnected:', window.wildWestWallet.isConnected);
                                console.log('• account:', window.wildWestWallet.account);
                                console.log('• currentChain:', window.wildWestWallet.currentChain);
                                console.log('• isConnecting:', window.wildWestWallet.isConnecting);
                            }

                            const connectBtn = document.getElementById('connectWalletBtn');
                            console.log('• Connect button exists:', !!connectBtn);
                            console.log('• Connect button onclick:', connectBtn?.onclick);
                            console.log('• Connect button text:', connectBtn?.textContent);

                            return {
                                walletSystem: !!window.wildWestWallet,
                                connectButton: !!connectBtn,
                                buttonHandler: !!connectBtn?.onclick
                            };
                        };

                        // Debug function to manually test connection
                        window.testConnection = async function () {
                            console.log('🧪 Testing wallet connection manually...');
                            try {
                                await connectWallet();
                            } catch (error) {
                                console.error('❌ Manual test failed:', error);
                            }
                        };

                        console.log('💡 Debug functions available:');
                        console.log('• debugWalletSystem() - Check wallet system status');
                        console.log('• testConnection() - Manually test wallet connection');

                        // Load and display the lock creation fee
                        async function loadLockCreationFee() {
                            try {
                                if (lockingFeeCalculator.isFreeService()) {
                                    // Service is now completely free for everyone!
                                    document.getElementById('feeAmount').textContent = '🎉 Completely FREE!';
                                    document.getElementById('feeDisplay').style.background = 'rgba(0,255,0,0.1)';
                                    document.getElementById('feeDisplay').style.borderColor = '#00ff00';
                                    document.querySelector('#feeDisplay div:first-child').textContent = '🎉 FREE TOKEN LOCKING';
                                    document.querySelector('#feeDisplay div:first-child').style.color = '#00ff00';
                                } else {
                                    // Fallback logic (should not execute since fee is $0)
                                    const isExempt = userAddress && lockingFeeCalculator.isExemptFromFees(userAddress, 'base');
                                    if (isExempt) {
                                        document.getElementById('feeAmount').textContent = 'FREE (Exempt Address)';
                                        document.getElementById('feeDisplay').style.background = 'rgba(0,255,0,0.1)';
                                        document.getElementById('feeDisplay').style.borderColor = '#00ff00';
                                    } else {
                                        const feeAmount = await lockingFeeCalculator.getFormattedETHFee();
                                        document.getElementById('feeAmount').textContent = feeAmount;
                                    }
                                }
                            } catch (error) {
                                console.error('Failed to load fee:', error);
                                // Even on error, default to free since we set USD_FEE_AMOUNT to 0
                                document.getElementById('feeAmount').textContent = '🎉 FREE - No fees required!';
                                document.getElementById('feeDisplay').style.background = 'rgba(0,255,0,0.1)';
                                document.getElementById('feeDisplay').style.borderColor = '#00ff00';
                            }
                        }

                        // Load fee when page loads
                        loadLockCreationFee();

                        document.getElementById('lockForm').onsubmit = async function (e) {
                            e.preventDefault();
                            if (!signer) {
                                alert('Connect wallet first!');
                                return;
                            }
                            const tokenAddress = document.getElementById('tokenAddress').value.trim();
                            const beneficiary = document.getElementById('beneficiary').value.trim();
                            const lockName = document.getElementById('lockName').value.trim();
                            const unlockDays = parseInt(document.getElementById('unlockDays').value, 10) || 0;
                            const unlockHours = parseInt(document.getElementById('unlockHours').value, 10) || 0;
                            const unlockMinutes = parseInt(document.getElementById('unlockMinutes').value, 10) || 0;
                            const statusDiv = document.getElementById('status');
                            statusDiv.textContent = '';
                            if (!tokenAddress || !beneficiary || !lockName) {
                                statusDiv.textContent = 'Fill all fields.';
                                return;
                            }
                            try {
                                // Get token decimals
                                const erc20 = new ethers.Contract(tokenAddress, [
                                    { "constant": false, "inputs": [{ "name": "spender", "type": "address" }, { "name": "value", "type": "uint256" }], "name": "approve", "outputs": [{ "name": "", "type": "bool" }], "type": "function" },
                                    { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "name": "", "type": "uint8" }], "type": "function" }
                                ], signer);
                                const decimals = await erc20.decimals();
                                // Convert amount to correct decimals
                                const amountRaw = document.getElementById('amount').value.trim();
                                const amount = ethers.utils.parseUnits(amountRaw, decimals);
                                const now = Math.floor(Date.now() / 1000);
                                const releaseTime = now + (unlockDays * 86400) + (unlockHours * 3600) + (unlockMinutes * 60);
                                // Approve tokens
                                statusDiv.textContent = 'Approving tokens...';
                                const approveTx = await erc20.approve(FACTORY_ADDRESS, amount);
                                await approveTx.wait();

                                // Small delay to ensure allowance propagates
                                await new Promise(resolve => setTimeout(resolve, 2000));

                                // Check if user needs to pay fees (now always false since service is free)
                                const isExempt = lockingFeeCalculator.isFreeService() || lockingFeeCalculator.isExemptFromFees(userAddress, 'base');

                                if (!isExempt) {
                                    // This block should never execute since service is now free
                                    statusDiv.textContent = 'Sending lock creation fee...';
                                    const lockCreationFee = await lockingFeeCalculator.getETHFeeAmount();
                                    const feeTx = await signer.sendTransaction({
                                        to: FEE_COLLECTOR_ADDRESS,
                                        value: lockCreationFee
                                    });
                                    await feeTx.wait();
                                } else {
                                    statusDiv.textContent = 'No fees required - Creating lock for free! 🎉';
                                }

                                // Call the factory to create a new lock
                                statusDiv.textContent = 'Creating lock...';
                                const factory = new ethers.Contract(FACTORY_ADDRESS, FACTORY_ABI, signer);
                                const tx = await factory.createLock(
                                    tokenAddress,
                                    beneficiary,
                                    unlockDays,
                                    unlockHours,
                                    unlockMinutes,
                                    amount,
                                    lockName
                                );
                                await tx.wait();
                                statusDiv.textContent = 'Lock created!';
                                loadUserLocks();
                            } catch (err) {
                                statusDiv.textContent = 'Error: ' + (err.message || err);
                            }
                        };

                        // Display user's locks (requires factory with event logs or lock registry)
                        async function loadUserLocks() {
                            console.log('🔍 loadUserLocks called');
                            console.log('📍 Provider available:', !!provider);
                            console.log('📍 User address:', userAddress);

                            const userLocksList = document.getElementById('userLocks');
                            userLocksList.innerHTML = '';

                            if (!provider || !userAddress) {
                                console.log('❌ Cannot load locks: missing provider or userAddress');
                                const li = document.createElement('li');
                                li.textContent = 'Connect wallet to view your locks.';
                                li.style.color = '#888';
                                li.style.textAlign = 'center';
                                userLocksList.appendChild(li);
                                return;
                            }

                            try {
                                console.log('🏭 Creating factory contract...');

                                // Create proper ethers provider from wallet provider
                                const ethersProvider = new ethers.providers.Web3Provider(provider);
                                console.log('✅ Created ethers provider:', !!ethersProvider);

                                const factory = new ethers.Contract(FACTORY_ADDRESS, FACTORY_ABI, ethersProvider);

                                // Get locks where user is creator
                                console.log('📞 Calling getUserLocks for creator locks:', userAddress);
                                const creatorLockAddresses = await factory.getUserLocks(userAddress);
                                console.log('📦 Found creator lock addresses:', creatorLockAddresses);

                                // Get locks where user is beneficiary by scanning events
                                console.log('� Scanning for beneficiary locks...');
                                let beneficiaryLockAddresses = [];
                                try {
                                    const filter = factory.filters.LockCreated(null, null, userAddress); // beneficiary filter
                                    const events = await factory.queryFilter(filter, 0, 'latest');
                                    beneficiaryLockAddresses = events.map(event => event.args.lock);
                                    console.log('�📦 Found beneficiary lock addresses:', beneficiaryLockAddresses);
                                } catch (eventErr) {
                                    console.log('⚠️ Could not scan beneficiary events:', eventErr.message);
                                }

                                // Combine and deduplicate lock addresses
                                const allLockAddresses = [...new Set([...creatorLockAddresses, ...beneficiaryLockAddresses])];
                                console.log('📊 Total unique locks found:', allLockAddresses.length);
                                console.log('📋 All lock addresses:', allLockAddresses);

                                if (allLockAddresses.length === 0) {
                                    const li = document.createElement('li');
                                    li.textContent = 'No locks found. Create a lock or check if any locks have you as beneficiary.';
                                    userLocksList.appendChild(li);
                                    return;
                                }
                                for (const lockAddr of allLockAddresses) {
                                    console.log(`🔍 Processing lock ${allLockAddresses.indexOf(lockAddr) + 1}/${allLockAddresses.length}: ${lockAddr}`);

                                    try {
                                        const lock = new ethers.Contract(lockAddr, LOCK_ABI, ethersProvider);
                                        const [name, amount, releaseTime, released, beneficiary] = await Promise.all([
                                            lock.lockName(),
                                            lock.amount(),
                                            lock.releaseTime(),
                                            lock.released(),
                                            lock.beneficiary()
                                        ]);

                                        console.log(`📝 Lock details: ${name}, Amount: ${amount.toString()}, Released: ${released}, Beneficiary: ${beneficiary}`);

                                        if (released) {
                                            console.log(`⏭️ Skipping released lock: ${name}`);
                                            continue; // Skip claimed locks
                                        }
                                        const now = Math.floor(Date.now() / 1000);

                                        // Determine user's relationship to this lock
                                        const isCreator = creatorLockAddresses.includes(lockAddr);
                                        const isBeneficiary = beneficiary.toLowerCase() === userAddress.toLowerCase();

                                        let userRole;
                                        if (isCreator && isBeneficiary) {
                                            userRole = 'Creator & Beneficiary';
                                        } else if (isCreator) {
                                            userRole = 'Creator';
                                        } else if (isBeneficiary) {
                                            userRole = 'Beneficiary';
                                        } else {
                                            userRole = 'Viewer';
                                        }

                                        // Format amount for display
                                        let formattedAmount = amount;
                                        let symbol = '';
                                        try {
                                            const token = new ethers.Contract(await lock.token(), [
                                                { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "name": "", "type": "uint8" }], "type": "function" },
                                                { "constant": true, "inputs": [], "name": "symbol", "outputs": [{ "name": "", "type": "string" }], "type": "function" }
                                            ], ethersProvider);
                                            const [decimals, sym] = await Promise.all([
                                                token.decimals(),
                                                token.symbol()
                                            ]);
                                            formattedAmount = ethers.utils.formatUnits(amount, decimals);
                                            symbol = sym;
                                        } catch (tokenErr) {
                                            console.log('❌ Could not get token info:', tokenErr.message);
                                            // Fallback to ETH formatting if token contract fails
                                            formattedAmount = ethers.utils.formatEther(amount);
                                            symbol = 'UNKNOWN';
                                        }

                                        // Card container
                                        const li = document.createElement('li');
                                        li.className = 'wildwest-lock-card';
                                        li.style.maxWidth = '420px';
                                        li.style.minWidth = '420px';
                                        li.style.width = '420px';
                                        li.style.minHeight = '320px'; // Changed from height to minHeight
                                        li.style.marginBottom = '18px';
                                        li.style.borderRadius = '20px';
                                        li.style.padding = '38px 18px 18px 18px'; // Increased bottom padding
                                        li.style.boxSizing = 'border-box';
                                        li.style.position = 'relative';
                                        // Get token address for display/copy
                                        const tokenAddr = await lock.token();
                                        li.innerHTML = `
                              <img src="../images/locked.png" class="lock-img-card" alt="Lock" />
                              <div class="wildwest-label">WILDWEST LOCK</div>
                              <div class="lock-title">${name}</div>
                              <div class="lock-info" style="color:#dc267f;font-weight:600;">YOUR ROLE: ${userRole}</div>
                              <div class="lock-info">AMOUNT: <span title="${amount.toString()}" style="font-family:monospace;">${formattedAmount}${symbol ? ' ' + symbol : ''}</span></div>
                              <div class="lock-info">BENEFICIARY: <span style="font-family:monospace;">${beneficiary}</span></div>
                              <div class="lock-info">TOKEN: <span title="${tokenAddr}" class="copy-token" style="cursor:pointer;color:#6c8cff;">${tokenAddr.slice(0, 6)}...${tokenAddr.slice(-4)}</span></div>
                              <div class="lock-info">UNLOCKS: ${new Date(releaseTime * 1000).toLocaleString()}</div>
                              <div class="lock-status ${(released ? 'claimed' : (now >= releaseTime ? 'claimable' : 'locked'))}">
                                ${(released ? 'CLAIMED' : (now >= releaseTime ? 'CLAIMABLE' : 'LOCKED'))}
                              </div>
                            `;

                                        // Fix lock image size to match Solana card
                                        if (!document.getElementById('lock-img-card-style')) {
                                            const style = document.createElement('style');
                                            style.id = 'lock-img-card-style';
                                            style.textContent = `
                                .lock-img-card {
                                  position: absolute;
                                  top: 18px;
                                  left: 14px;
                                  width: 44px;
                                  height: 44px;
                                  max-width: 44px;
                                  max-height: 44px;
                                  aspect-ratio: 1/1;
                                  object-fit: contain;
                                  z-index: 12;
                                  background: transparent;
                                  border-radius: 10px;
                                  border: none;
                                  padding: 2px;
                                  display: flex;
                                  align-items: center;
                                  justify-content: center;
                                  box-shadow: 0 2px 8px #0004;
                                }
                              `;
                                            document.head.appendChild(style);
                                        }

                                        // Copy token address to clipboard
                                        li.querySelector('.copy-token').onclick = function () {
                                            navigator.clipboard.writeText(tokenAddr);
                                            this.textContent = 'COPIED!';
                                            setTimeout(() => { this.textContent = tokenAddr.slice(0, 6) + '...' + tokenAddr.slice(-4); }, 1200);
                                        };

                                        // --- EMBED ICON AT TOP RIGHT ---
                                        const embedIcon = document.createElement('span');
                                        embedIcon.className = 'embed-icon';
                                        embedIcon.title = 'Copy embed widget code';
                                        embedIcon.style.position = 'absolute';
                                        embedIcon.style.top = '18px';
                                        embedIcon.style.right = '18px';
                                        embedIcon.style.cursor = 'pointer';
                                        embedIcon.style.zIndex = '20';
                                        embedIcon.style.display = 'flex';
                                        embedIcon.style.alignItems = 'center';
                                        embedIcon.style.justifyContent = 'center';
                                        embedIcon.style.width = '28px';
                                        embedIcon.style.height = '28px';
                                        embedIcon.style.background = 'rgba(76,108,255,0.10)';
                                        embedIcon.style.borderRadius = '7px';
                                        embedIcon.style.transition = 'background 0.18s';
                                        embedIcon.innerHTML = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="5" width="14" height="10" rx="2" stroke="#6c8cff" stroke-width="2" fill="none"/><path d="M7 9L5 10L7 11" stroke="#6c8cff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M13 9L15 10L13 11" stroke="#6c8cff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
                                        let embedIconTimeout = null;
                                        embedIcon.onclick = () => {
                                            showWidgetModal(lockAddr);
                                        };
                                        li.appendChild(embedIcon);

                                        // --- ACTION BUTTONS FLEX CONTAINER ---
                                        const actionsDiv = document.createElement('div');
                                        actionsDiv.className = 'lock-actions';
                                        actionsDiv.style.display = 'flex';
                                        actionsDiv.style.flexWrap = 'wrap';
                                        actionsDiv.style.gap = '8px';
                                        actionsDiv.style.justifyContent = 'center';
                                        actionsDiv.style.marginTop = '8px'; // reduce gap above buttons
                                        actionsDiv.style.marginBottom = '0'; // ensure no extra margin at bottom

                                        // Basescan link button
                                        const shareBtn = document.createElement('button');
                                        shareBtn.textContent = 'COPY BASESCAN LINK';
                                        shareBtn.title = 'Copy the Basescan contract link for this lock to your clipboard';
                                        shareBtn.onclick = () => {
                                            const url = `https://basescan.org/address/${lockAddr}`;
                                            navigator.clipboard.writeText(url);
                                            shareBtn.textContent = 'COPIED!';
                                            setTimeout(() => shareBtn.textContent = 'COPY BASESCAN LINK', 1200);
                                        };
                                        actionsDiv.appendChild(shareBtn);

                                        // Claim button if claimable and not claimed
                                        if (!released && now >= releaseTime && beneficiary.toLowerCase() === userAddress.toLowerCase()) {
                                            const claimBtn = document.createElement('button');
                                            claimBtn.textContent = 'CLAIM';
                                            claimBtn.style.background = '#2ecc71';
                                            claimBtn.style.color = 'white';
                                            claimBtn.style.fontWeight = 'bold';
                                            claimBtn.onclick = async () => {
                                                if (!signer) {
                                                    alert('Please connect your wallet first!');
                                                    return;
                                                }

                                                try {
                                                    claimBtn.textContent = 'CLAIMING...';
                                                    claimBtn.disabled = true;

                                                    console.log('🎯 Claiming lock:', lockAddr);
                                                    const lockWithSigner = new ethers.Contract(lockAddr, LOCK_ABI, signer);
                                                    const tx = await lockWithSigner.release();

                                                    console.log('⏳ Transaction sent:', tx.hash);
                                                    await tx.wait();

                                                    console.log('✅ Claim successful!');
                                                    alert('Tokens claimed successfully!');
                                                    loadUserLocks(); // Reload to update status
                                                } catch (err) {
                                                    console.error('❌ Claim failed:', err);
                                                    alert('Claim failed: ' + (err.message || err));
                                                    claimBtn.textContent = 'CLAIM';
                                                    claimBtn.disabled = false;
                                                }
                                            };
                                            actionsDiv.appendChild(claimBtn);
                                        }

                                        li.appendChild(actionsDiv);
                                        userLocksList.appendChild(li);

                                    } catch (lockErr) {
                                        console.error(`❌ Error processing lock ${lockAddr}:`, lockErr);
                                        const li = document.createElement('li');
                                        li.textContent = `Error loading lock ${lockAddr.slice(0, 6)}...${lockAddr.slice(-4)}: ${lockErr.message}`;
                                        li.style.color = '#ff6c6c';
                                        userLocksList.appendChild(li);
                                    }
                                }
                            } catch (err) {
                                console.error('❌ Error in loadUserLocks:', err);
                                const li = document.createElement('li');
                                li.textContent = 'Error loading locks: ' + (err.message || err);
                                li.style.color = '#ff6c6c';
                                userLocksList.appendChild(li);
                            }
                        }

                        // Function to claim tokens from a lock
                        async function claimLock(lockAddress) {
                            if (!signer) {
                                alert('Please connect your wallet first!');
                                return;
                            }

                            try {
                                console.log('🔓 Claiming lock:', lockAddress);
                                const ethersProvider = new ethers.providers.Web3Provider(provider);
                                const lock = new ethers.Contract(lockAddress, LOCK_ABI, ethersProvider.getSigner());

                                const tx = await lock.release();
                                console.log('📤 Claim transaction sent:', tx.hash);

                                // Show status
                                const statusDiv = document.getElementById('status');
                                statusDiv.textContent = 'Claiming tokens...';
                                statusDiv.style.color = '#ff8c00';

                                await tx.wait();

                                statusDiv.textContent = 'Tokens claimed successfully!';
                                statusDiv.style.color = '#00e676';

                                // Refresh the locks list
                                setTimeout(() => {
                                    loadUserLocks();
                                    statusDiv.textContent = '';
                                }, 2000);

                            } catch (error) {
                                console.error('❌ Error claiming lock:', error);
                                const statusDiv = document.getElementById('status');
                                statusDiv.textContent = 'Error claiming tokens: ' + error.message;
                                statusDiv.style.color = '#ff6b6b';
                            }
                        }

                        // Make claimLock globally available
                        window.claimLock = claimLock;

                        document.getElementById('setSelfBeneficiary').onclick = function () {
                            if (userAddress) {
                                document.getElementById('beneficiary').value = userAddress;
                            } else {
                                alert('Connect wallet first!');
                            }
                        };

                        async function fetchTokenInfo() {
                            const tokenAddress = document.getElementById('tokenAddress').value.trim();
                            const tokenInfoDiv = document.getElementById('tokenInfo');

                            console.log('🔍 fetchTokenInfo called with:', tokenAddress);
                            console.log('🔍 provider available:', !!provider);
                            console.log('🔍 userAddress available:', !!userAddress);

                            tokenInfoDiv.textContent = '';

                            if (!tokenAddress) {
                                console.log('❌ No token address provided');
                                return;
                            }

                            if (!ethers.utils.isAddress(tokenAddress)) {
                                console.log('❌ Invalid token address');
                                tokenInfoDiv.textContent = 'Invalid token address';
                                return;
                            }

                            if (!provider) {
                                console.log('❌ No provider available');
                                tokenInfoDiv.textContent = 'Connect wallet first to view token info';
                                return;
                            }

                            try {
                                tokenInfoDiv.textContent = 'Loading token info...';
                                console.log('🔄 Creating ethers provider...');

                                // Create proper ethers provider from wallet provider
                                const ethersProvider = new ethers.providers.Web3Provider(provider);
                                console.log('✅ Ethers provider created');

                                const erc20 = new ethers.Contract(tokenAddress, [
                                    { "constant": true, "inputs": [], "name": "name", "outputs": [{ "name": "", "type": "string" }], "type": "function" },
                                    { "constant": true, "inputs": [], "name": "symbol", "outputs": [{ "name": "", "type": "string" }], "type": "function" },
                                    { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "name": "", "type": "uint8" }], "type": "function" },
                                    { "constant": true, "inputs": [{ "name": "account", "type": "address" }], "name": "balanceOf", "outputs": [{ "name": "", "type": "uint256" }], "type": "function" }
                                ], ethersProvider);

                                console.log('🔄 Fetching token details...');

                                // First get basic token info (name, symbol, decimals)
                                const [name, symbol, decimals] = await Promise.all([
                                    erc20.name(),
                                    erc20.symbol(),
                                    erc20.decimals()
                                ]);

                                console.log('✅ Token info fetched:', { name, symbol, decimals });

                                // If we have userAddress, get balance too
                                let balanceText = '';
                                if (userAddress) {
                                    try {
                                        const balance = await erc20.balanceOf(userAddress);
                                        const formattedBalance = ethers.utils.formatUnits(balance, decimals);
                                        balanceText = ` | Balance: ${formattedBalance} ${symbol}`;
                                        console.log('✅ Balance fetched:', formattedBalance);
                                    } catch (balanceErr) {
                                        console.log('⚠️ Could not fetch balance:', balanceErr.message);
                                        balanceText = ' | Balance: Unable to fetch';
                                    }
                                }

                                tokenInfoDiv.textContent = `Name: ${name} | Symbol: ${symbol}${balanceText}`;
                                tokenInfoDiv.style.color = '#008080';

                            } catch (err) {
                                console.error('❌ Error fetching token info:', err);
                                tokenInfoDiv.textContent = 'Could not fetch token info: ' + err.message;
                                tokenInfoDiv.style.color = '#ff6b6b';
                            }
                        }
                        document.getElementById('tokenAddress').addEventListener('input', function () {
                            // Debounce to avoid too many requests
                            clearTimeout(window._tokenInfoTimeout);
                            window._tokenInfoTimeout = setTimeout(fetchTokenInfo, 400);
                        });

                        document.getElementById('refreshLocksBtn').onclick = function () {
                            loadUserLocks();
                            document.getElementById('status').textContent = 'Lock list refreshed.';
                            setTimeout(() => { document.getElementById('status').textContent = ''; }, 1200);
                        };

                        // Widget Modal Functions
                        let currentLockAddress = null;

                        function showWidgetModal(lockAddress) {
                            currentLockAddress = lockAddress;
                            document.getElementById('widgetModal').style.display = 'block';
                            document.getElementById('codeSection').style.display = 'none';
                            document.getElementById('copyCodeBtn').style.display = 'none';
                        }

                        function closeWidgetModal() {
                            document.getElementById('widgetModal').style.display = 'none';
                            currentLockAddress = null;
                        }

                        function selectWidgetType(type) {
                            if (!currentLockAddress) return;

                            const baseUrl = window.location.origin;
                            let widgetUrl, dimensions;

                            if (type === 'readonly') {
                                widgetUrl = `${baseUrl}/embed-base-lock.html?lock=${currentLockAddress}`;
                                dimensions = 'width="400" height="320"';
                            } else {
                                widgetUrl = `${baseUrl}/embed-base-lock-interactive.html?lock=${currentLockAddress}`;
                                dimensions = 'width="400" height="380"';
                            }

                            const iframeCode = `<iframe 
                    src="${widgetUrl}" 
                    ${dimensions} 
                    style="border:none;border-radius:20px;box-shadow:0 2px 12px #0003;">
                  </iframe>`;

                            document.getElementById('widgetCode').textContent = iframeCode;
                            document.getElementById('codeSection').style.display = 'block';
                            document.getElementById('copyCodeBtn').style.display = 'inline-block';
                        }

                        function copyWidgetCode() {
                            const codeText = document.getElementById('widgetCode').textContent;
                            navigator.clipboard.writeText(codeText).then(() => {
                                const btn = document.getElementById('copyCodeBtn');
                                const originalText = btn.textContent;
                                btn.textContent = '✅ Copied!';
                                btn.style.background = '#00e676';
                                setTimeout(() => {
                                    btn.textContent = originalText;
                                    btn.style.background = '#6c8cff';
                                }, 2000);
                            }).catch(err => {
                                console.error('Failed to copy code:', err);
                                alert('Failed to copy code. Please select and copy manually.');
                            });
                        }

                        // Close modal when clicking outside
                        document.addEventListener('click', function (e) {
                            const modal = document.getElementById('widgetModal');
                            if (e.target === modal) {
                                closeWidgetModal();
                            }
                        });
                    </script>

                    <!-- Widget Configuration Modal -->
                    <div id="widgetModal" class="widget-modal">
                        <div class="widget-modal-content">
                            <h2>🔗 Create Your Widget</h2>
                            <p style="text-align: center; color: #b8c0d0; margin-bottom: 2em;">
                                Choose the type of widget you'd like to embed on your website:
                            </p>

                            <div class="widget-option" onclick="selectWidgetType('readonly')">
                                <div class="preview-size">400×320</div>
                                <h3>📖 Read-Only Widget</h3>
                                <p>Perfect for displaying lock information without wallet interaction. Shows lock
                                    details, token amounts,
                                    unlock
                                    dates, and links to Base Explorer. Ideal for portfolios, documentation, or
                                    informational pages.</p>
                            </div>

                            <div class="widget-option" onclick="selectWidgetType('interactive')">
                                <div class="preview-size">400×380</div>
                                <h3>⚡ Interactive Widget</h3>
                                <p>Full-featured widget with wallet connect and claim functionality. Users can connect
                                    their MetaMask wallet
                                    and
                                    claim unlocked tokens directly from your website. Perfect for dApps and user
                                    dashboards.</p>
                            </div>

                            <div id="codeSection" style="display: none;">
                                <h3 style="color: #6c8cff; margin-top: 2em;">Your Widget Code:</h3>
                                <div id="widgetCode" class="code-display"></div>
                                <p style="color: #b8c0d0; font-size: 0.9em; text-align: center;">
                                    Copy this code and paste it anywhere on your website!
                                </p>
                            </div>

                            <div class="modal-buttons">
                                <button class="modal-btn" id="copyCodeBtn" onclick="copyWidgetCode()"
                                    style="display: none;">📋 Copy
                                    Code</button>
                                <button class="modal-btn secondary" onclick="closeWidgetModal()">Close</button>
                            </div>
                        </div>
                    </div>

                    <!-- =========== Footer =========== -->


                    <div class="footer-section">
                        <p class="wild-west-footer">WILDWEST LAUNCHPAD</p>
                        <div class="footer-socials">
                            <a href="https://t.me/wildwestlaunchpad" target="_blank" rel="noopener">
                                <img src="../images/icons/icons8-telegram-app-240_WHITE.png" alt="Telegram"
                                    class="nav-icon">
                            </a>
                            <a href="https://x.com/WILDWESTLP?t=wmcDfvCKnkAaLCtJbmAxgA" target="_blank" rel="noopener">
                                <img src="../images/icons/icons8-twitterx-240_WHITE.png" alt="Twitter/X"
                                    class="nav-icon">
                            </a>
                            <a href="https://dexscreener.com/base/0x8129609e5303910464fce3022a809fa44455fe9a"
                                target="_blank" rel="noopener">
                                <img src="../images/icons/661375b92a7e161501f4b5e5_dexscreener.322a5a2d_WHITE.png"
                                    alt="DEXScreener" class="nav-icon">
                            </a>
                        </div>
                        <p class="footer-wildw">$WILDW TOKEN (BASE)</p>
                        <span class="footer-address"
                            id="contract-address">0x8129609E5303910464FCe3022a809fA44455Fe9A</span>



                        <p class="footer-url">&copy; 2025 Wild West Launchpad. All rights reserved.</p>
                    </div>
                </div>
                </footer>

</body>

</html>