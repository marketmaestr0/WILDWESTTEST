<!DOCTYPE html>
<html lang="en">

<head>
    <!-- CACHE BUST v20250824-001 - FORCE BROWSER RELOAD -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wild West Trending Tokens</title>

    <link rel="stylesheet" href="css/styles.css">

    <!-- Cool Fonts for Amazing Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@400;700;900&family=Rajdhani:wght@400;600;700&family=Russo+One&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <!-- Production Configuration -->
    <script src="js/production-config.js"></script>
    <!-- GitHub Storage System -->
    <script src="js/secure-config.js"></script>
    <script src="js/github-actions-uploader.js"></script>
    <script src="js/token-metadata-storage.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Force expansion in any iframe or constrained environment */
        html,
        body {
            height: auto !important;
            min-height: 100vh !important;
            overflow-y: auto !important;
            position: relative !important;
        }

        html {
            height: auto;
            /* Force auto height */
            min-height: 100vh;
            /* At least viewport height */
            overflow-y: auto;
            /* Allow vertical scrolling */
            width: 100%;
            /* Force the HTML element to expand fully */
            position: relative;
            display: block;
        }

        body {
            font-family: 'Orbitron', 'Courier New', monospace;
            background: linear-gradient(160deg, var(--panel), var(--violet));
            color: #ffffff;
            min-height: 100vh;
            height: auto;
            /* Allow body to expand beyond viewport */
            overflow-x: hidden;
            overflow-y: auto;
            /* Ensure vertical scrolling works */
            -webkit-overflow-scrolling: touch;
            /* Smooth scrolling on iOS */
            width: 100%;
            /* Ensure body takes full width */
            margin: 0;
            padding: 0;
            /* Force body to expand and be flexible */
            position: relative;
            display: block;
            flex: 1;
        }

        .trending-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
            position: relative;
            width: 100%;
            /* Ensure container takes full width */
            min-width: 0;
            /* Prevent width conflicts */
            display: block;
            /* Explicit display */
            /* Force container to expand */
            min-height: 100vh;
            height: auto;
            overflow: visible;
        }

        .trending-title {
            text-align: center;
            font-size: 3.5rem;
            letter-spacing: 0.7rem;
            font-family: 'Orbitron', 'Exo 2', 'Rajdhani', 'Russo One', monospace;
            background: #ffffff;
            background-size: 300% 300%;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8rem;
            margin-top: 8rem;
            text-transform: uppercase;
            position: relative;
        }

        .search-container {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
        }

        .search-input {
            width: 100%;
            max-width: 400px;
            padding: 1rem 1.5rem;
            background: var(--panel);
            border: 2px solid var(--yellow);
            border-radius: 25px;
            color: #ffffff;
            font-size: 0.8rem;
            letter-spacing: 0.13rem;
            font-family: 'Orbitron', 'Courier New', monospace;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            box-shadow: 0 0 20px var(--yellow-30);
            background: var(--yellow-30);

        }

        .search-input::placeholder {
            color: #888;
        }

        .filters-container {
            display: flex;
            gap: 30px;
            margin: 2rem 0px 2rem;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;

        }

        .filter-select {
            background: var(--panel);
            color: #ffffff;
            border: 2px solid #ffffff;
            font-size: 0.8rem;
            letter-spacing: 0.13rem;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Orbitron', 'Courier New', monospace;
            cursor: pointer;
            min-width: 150px;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--yellow);
            box-shadow: 0 0 10px var(--violet-shadow);
        }

        .filter-label {
            color: #ffffff;
            font-size: 0.9rem;
        }

        .trending-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
            min-height: auto;
            /* Let content determine natural height instead of fixed calculation */
        }


        /*===========================
        |                            |
        |        TOKEN CARDS         |
        |                            |
        |============================|*/



        .token-card {
            background: linear-gradient(135deg, var(--panel-80), var(--panel-50));
            border: 2px solid var(--dark-violet);
            border-radius: 15px;
            padding: 1.5rem;
            position: relative;
            transition: all 0.3s ease;
            overflow: hidden;
            container: token / inline-size;
        }

        .token-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px var(--yellow-10);
            border-color: var(--yellow);
        }


        /* Mobile adjustments */
        @media (max-width: 768px) {
            .trade-btn {
                font-size: 0.65rem;
                padding: 0.4rem 0.8rem;
                font-weight: 800;
            }

            .token-header {
                padding-right: 4px;
            }
        }

        @media (max-width: 480px) {
            .trade-btn {
                font-size: 0.6rem;
                padding: 0.35rem 0.7rem;
                font-weight: 700;
            }

            .token-header {
                padding-right: 2px;
            }
        }






        /* Placeholder card styles */

        .placeholder-card {
            opacity: 0.6;
            background: linear-gradient(135deg, var(--panel-80), var(--panel-50));
            border: 1px dashed var(--dark-violet);
            border-radius: 15px;
        }

        .placeholder-card:hover {
            transform: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);

            border-radius: 15px;
        }

        .placeholder-banner {
            background: linear-gradient(135deg, var(--panel), var(--dark-violet));
            color: #888;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.9em;
        }

        .placeholder-logo {
            background: linear-gradient(135deg, var(--panel), var(--dark-violet));
            border: 2px dashed #666;
        }

        .placeholder-logo .placeholder-icon {
            font-size: 1.5em;
            color: #888;
            font-weight: bold;
        }

        .rank-placeholder {
            background: linear-gradient(135deg, var(--panel), var(--dark-violet));
            color: #bbb;
            border: 2px solid #666;
        }

        .link-placeholder {
            color: #666;
            font-style: italic;
            font-size: 0.85em;
        }

        .rank-badge {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            color: #000;
            z-index: 2;
        }




        /* Star shapes for top 3 */
        .rank-1 {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            border-radius: 0;
            animation: pulse-gold-star 1.5s infinite ease-in-out;
            width: 60px;
            height: 60px;
            margin-top: -10px;
            /* move upward */
            margin-left: -10px;
            /* move left */
            font-size: 1rem;
        }

        .rank-1::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            margin: -30px 0 0 -30px;
            border-radius: 50%;
            background: transparent;
            box-shadow: 0 0 20px 10px rgba(255, 215, 0, 0.6);
            animation: pulse-glow-gold 1.5s infinite ease-in-out;
            z-index: -1;
            pointer-events: none;
        }

        .rank-2 {
            background: linear-gradient(45deg, #8C8C8C, #B8B8B8, #D3D3D3);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            border-radius: 0;
            animation: pulse-silver-star 1.5s infinite ease-in-out;
            width: 40px;
            height: 40px;
            margin-top: -7px;
            /* move upward */
            margin-left: -7px;
            /* move left */
            font-size: 0.8rem;
            justify-items: center;
        }

        .rank-2::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            margin: -25px 0 0 -25px;
            border-radius: 50%;
            background: transparent;
            box-shadow: 0 0 15px 8px rgba(192, 192, 192, 0.5);
            animation: pulse-glow-silver 1.5s infinite ease-in-out;
            z-index: -1;
            pointer-events: none;
        }

        .rank-3 {
            background: linear-gradient(45deg, #cd7f32, #daa520);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            border-radius: 0;
            animation: pulse-bronze-star 1.5s infinite ease-in-out;
            width: 36px;
            height: 36px;
            margin-top: -6px;
            /* move upward */
            margin-left: -6px;
            /* move left */
            font-size: 0.7rem;
        }

        .rank-3::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            margin: -25px 0 0 -25px;
            border-radius: 50%;
            background: transparent;
            box-shadow: 0 0 15px 8px rgba(205, 127, 50, 0.5);
            animation: pulse-glow-bronze 1.5s infinite ease-in-out;
            z-index: -1;
            pointer-events: none;
        }

        .rank-top12 {
            background: linear-gradient(45deg, var(--light-blue), var(--light-blue-60));
            animation: pulse-blue 2s infinite;
        }

        .rank-default {
            background: rgba(255, 255, 255, 0.1);
        }






        /* Base Network Badge */
        .base-network-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            /* Moved to right side to avoid covering rank badges */
            background: linear-gradient(135deg, #0052FF, #0066FF);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            box-shadow: 0 2px 4px rgba(0, 82, 255, 0.3);
            z-index: 5;
            border: 1px solid rgba(0, 82, 255, 0.4);
        }

        .base-network-badge img {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        /* Mobile adjustments for Base badge */
        @media (max-width: 768px) {
            .base-network-badge {
                font-size: 9px;
                padding: 3px 6px;
                border-radius: 10px;
            }

            .base-network-badge img {
                width: 10px;
                height: 10px;
            }
        }

        @keyframes pulse-glow-gold {

            0%,
            100% {
                box-shadow: 0 0 20px 10px rgba(255, 215, 0, 0.6);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 30px 15px rgba(255, 215, 0, 0.8);
                transform: scale(1.2);
            }
        }

        @keyframes pulse-glow-silver {

            0%,
            100% {
                box-shadow: 0 0 15px 8px rgba(192, 192, 192, 0.5);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 25px 12px rgba(192, 192, 192, 0.7);
                transform: scale(1.1);
            }
        }

        @keyframes pulse-glow-bronze {

            0%,
            100% {
                box-shadow: 0 0 15px 8px rgba(205, 127, 50, 0.5);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 25px 12px rgba(205, 127, 50, 0.7);
                transform: scale(1.1);
            }
        }

        @keyframes pulse-gold-star {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.1);
                filter: brightness(1.3);
            }
        }

        @keyframes pulse-silver-star {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.1);
                filter: brightness(1.2);
            }
        }

        @keyframes pulse-bronze-star {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.1);
                filter: brightness(1.2);
            }
        }

        @keyframes pulse-blue {

            0%,
            100% {
                box-shadow: 0 0 5px #0080ff;
            }

            50% {
                box-shadow: 0 0 20px #0080ff, 0 0 30px #0080ff;
            }
        }





        /* TOKEN CARD CONTENT*/

        .token-banner {
            width: 100%;
            height: 100px;
            background: linear-gradient(135deg, #333, #555);
            border-radius: 8px;
            margin-bottom: 1.5rem;
            background-size: cover;
            background-position: center;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 0.8rem;
            aspect-ratio: 3/1;
        }


        .token-header {
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            display: grid;
            grid-template-columns: auto minmax(0, 1fr) auto;
            align-items: center;
            justify-items: stretch;
            /* children fill their grid areas */
            gap: .5rem;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
        }


        .token-logo-img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--light-blue), var(--light-blue-60));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            background-size: cover;
            background-position: center;
            color: #000;
            font-size: 0.9rem;
            /* No margins needed; grid gap handles spacing */
        }

        /* Flexible middle column – can shrink and let text wrap */
        .token-info {
            min-width: 0;
            /* CRITICAL: allows wrapping instead of overflowing */
            margin-left: 1rem;
        }

        .token-name,
        .token-symbol,
        .token-price {
            white-space: normal;
            /* allow line breaks */
            overflow-wrap: anywhere;
            /* break very long strings safely */
            word-break: normal;
            /* avoid aggressive mid-letter breaks */
            hyphens: auto;
            /* nicer hyphenation (needs lang= on HTML) */
            max-width: 100%;
            margin: 0 0 0.25rem 0;
        }


        .token-name {
            font-size: 0.75rem;
            letter-spacing: 0.2rem;
            font-weight: bold;
            color: #fff;
            text-transform: uppercase;
        }

        .token-symbol {
            font-size: 0.65rem;
            letter-spacing: 0.15rem;
            color: #999;
            text-transform: uppercase;
        }

        .token-price {
            font-size: 0.75rem;
            color: var(--light-blue);
        }

        .trade-btn {
            /* visual styles (unchanged) */
            background: var(--yellow);
            background-size: 200% 200%;
            color: var(--panel);
            border: none;
            border-radius: 20px;
            font-weight: 900;
            font-size: 0.75rem;
            font-family: 'Orbitron';
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            overflow: hidden;
            animation: gradientFlow 3s ease-in-out infinite;

            /* layout for grid */
            position: relative;
            /* contains ::before shine */
            justify-self: end;
            /* stick to right edge of the header */
            align-self: center;
            /* vertically center in the row */
            white-space: nowrap;
            /* keep label on one line */
            transform: none;
            /* ensure no vertical yank */
        }

        .trade-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            /* fill the button */
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, .2), transparent);
            transform: translateX(-100%);
            /* start off left */
            transition: transform .5s;
        }

        .trade-btn:hover::before {
            transform: translateX(100%);
            /* sweep across */
        }


        .trade-btn:hover {
            transform: none;
            box-shadow:
                0 8px 25px var(--yellow-30),
                0 0 30px var(--yellow-10),
                0 0 40px var(--yellow-10),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            background-position: 100% 100%;
            filter: brightness(1.1);
            animation: gradientFlow 1.5s ease-in-out infinite, buttonPulse 1s ease-in-out infinite;
            /* Cool pulse effect on hover */
        }

        .trade-btn:active {
            transform: none;
        }

        @keyframes gradientFlow {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }


        @keyframes buttonPulse {
            0% {
                box-shadow:
                    0 0 10px var(--yellow-50),
                    0 0 13px var(--yellow-30),
                    0 0 16px var(--yellow-10),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }

            50% {
                box-shadow:
                    0 0 15px var(--yellow-70),
                    0 0 19px var(--yellow-50),
                    0 0 24px var(--yellow-30),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }

            100% {
                box-shadow:
                    0 0 10px var(--yellow-50),
                    0 0 13px var(--yellow-30),
                    0 0 16px var(--yellow-10),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
        }


        .token-description {
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background: var(--panel);
            border-radius: 8px;
            font-size: 0.75rem;
            color: #999;
            word-wrap: break-word;
            height: 2.5rem;
            position: relative;
            overflow: hidden;
        }

        .description-text {
            height: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 1;
            line-clamp: 1;
            -webkit-box-orient: vertical;
            padding-right: 60px;
            /* Space for more button */
        }

        .description-more-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: var(--light-blue-30);
            border: 1px solid var(--light-blue);
            color: var(--light-blue);
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .description-more-btn:hover {
            background: var(--yellow-30);
            color: var(--yellow);
            transform: translateY(-1px);
        }

        .token-address {
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.75rem;
            font-family: monospace;
            font-weight: 500;
            text-align: center;
            word-break: break-all;
            background: var(--panel);
            border: 1px solid var(--yellow-30);
            border-radius: 5px;
            color: var(--yellow);
        }

        .token-address:hover {
            border-color: var(--yellow);
            transform: translateY(-1px);
            color: var(--yellow);
            background: var(--yellow-30);
            border: 1px solid var(--yellow);
        }



        /*========= TOKEN LINKS =========*/


        /* --- Layout ------------------------------------------------------------- */
        .token-links {
            display: grid;
            gap: 8px;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            padding: 0;
            /* match .token-header’s left/right padding */
            width: 100%;
            box-sizing: border-box;
            /* include padding in width calc */
        }

        .token-links .links-row {
            display: flex;
            flex-wrap: nowrap;
            /* keep each row on a single line */
            align-items: stretch;
            justify-content: flex-start;
            gap: 8px;
            /* fixed gap baseline */
        }

        /* --- Buttons (shared) --------------------------------------------------- */
        .token-link {
            /* layout inside the grid cell */
            display: flex;
            flex: 1 1 auto;
            min-width: 0;
            /* lets label ellipsis instead of overflowing */
            box-sizing: border-box;

            /* visual */
            align-items: center;
            justify-content: center;
            gap: 0.45rem;
            padding: 0.5rem 0.5rem;
            min-height: 40px;
            border-radius: 8px;
            text-decoration: none;
            border: 1px solid var(--yellow-70);
            background: var(--yellow-10, transparent);
            color: #fff;
            font-size: 0.85rem;
            line-height: 1;
            letter-spacing: 0.02em;
            transition: box-shadow .2s ease, transform .1s ease, border-color .2s ease;
        }

        .token-link .link-text {
            display: inline;
            flex: 0 1 auto;
            /* claim leftover space */
            min-width: 2ch;
            /* don't collapse to 0 */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.7rem;
            letter-spacing: 0.1em;
        }

        .token-link img {
            width: 20px;
            height: 20px;
            /*  display: block;*/
            flex: 0 0 auto;
        }




        @container token (max-width: 420px) {
            .token-links .links-row {
                gap: 6px;
            }

            .token-link {
                padding-inline: 0.45rem;
                gap: 0.35rem;
            }
        }


        @container token (max-width: 310px) {
            .token-link img {
                width: 18px;
                height: 18px;
            }
        }


        @container token (max-width: 300px) {
            .token-link .link-text {
                display: none;
            }

            /* icons + ticks stay */
            .token-link {
                padding: 0.4rem;
            }
        }





        /* Active hover/focus */
        .token-link:not(.is-disabled):is(:hover, :focus-visible) {
            transform: translateY(-1px);
            box-shadow: 0 0 0 2px var(--yellow-30);
            border-color: var(--yellow);
        }

        /* Disabled (missing link) */
        .token-link.is-disabled {
            opacity: 0.35;
            filter: grayscale(100%);
            border-style: dashed;
            pointer-events: none;
            /* not clickable */
        }


        .dexscreener-link::after,
        .basescan-link::after {
            flex: 0 0 auto;
            /* generated pseudo-element is a flex item */
            margin-left: 0.35rem;
        }

        /* --- Premium tick / cross (emoji) -------------------------------------- */
        /* We read the boolean from data-premium on the link and render an emoji */
        .dexscreener-link[data-premium="true"]::after,
        .basescan-link[data-premium="true"]::after {
            content: "✅";
            font-size: 0.7rem;
            line-height: 1;
        }

        .dexscreener-link[data-premium="false"]::after,
        .basescan-link[data-premium="false"]::after {
            content: "❌";
            font-size: 0.5rem;
            line-height: 1;
        }

        /* If the button is disabled (no address), keep the tick/cross subdued */
        .token-link.is-disabled::after {
            opacity: 0.6;
            filter: grayscale(100%);
        }




        .token-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--yellow);
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 0.8rem;
            font-weight: bold;
            color: #ffffff;
        }


        .edit-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            overflow-y: auto;
        }

        .edit-modal-content {
            background: #1a1a1a;
            margin: 2% auto;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            border-radius: 15px;
            border: 2px solid #0088ff;
            position: relative;
        }

        .edit-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #333;
        }

        .edit-modal h2 {
            color: #0088ff;
            margin: 0;
            font-size: 1.5rem;
        }

        .close-modal {
            background: none;
            border: none;
            color: #999;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-modal:hover {
            color: #0088ff;
        }

        .loading-container {
            text-align: center;
            padding: 3rem;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #333;
            border-top: 4px solid #0088ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0088ff, #0070cc);
            border-radius: 2px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .error-state {
            text-align: center;
            padding: 3rem;
            color: #ff4444;
        }

        .load-more-btn {
            display: block;
            width: 200px;
            margin: 2rem auto 3rem auto;
            /* Fixed: reasonable spacing that won't get cut off */
            padding: 1rem 2rem;
            background: linear-gradient(45deg, #0088ff, #0070cc);
            border: none;
            border-radius: 25px;
            color: #000;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .load-more-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 136, 255, 0.4);
        }

        .load-more-btn:disabled {
            background: linear-gradient(45deg, #666, #555);
            cursor: not-allowed;
            opacity: 0.5;
            transform: none;
            box-shadow: none;
        }

        .load-more-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .back-btn {
            display: block;
            width: 200px;
            margin: 1rem auto 4rem auto;
            padding: 1rem 2rem;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            border: none;
            border-radius: 25px;
            color: #fff;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }

        /* Edit functionality styles */
        .edit-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 6px 12px;
            background: #0088ff;
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 136, 255, 0.3);
        }

        .edit-icon:hover {
            background: #0066cc;
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 136, 255, 0.4);
        }

        .edit-icon:active {
            transform: translateY(0px);
        }

        .update-disclaimer {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .disclaimer-icon {
            font-size: 1.5rem;
            color: #ffc107;
            flex-shrink: 0;
        }

        .disclaimer-text {
            color: #e0e0e0;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .disclaimer-text strong {
            color: #ffc107;
            font-weight: 600;
        }

        .edit-form-group {
            margin-bottom: 1.5rem;
        }

        .edit-form-group label {
            display: block;
            color: #0088ff;
            font-weight: bold;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .edit-form-group input,
        .edit-form-group textarea {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 8px;
            color: white;
            font-family: 'Orbitron', 'Courier New', monospace;
            font-size: 14px;
            box-sizing: border-box;
        }

        .edit-form-group input:focus,
        .edit-form-group textarea:focus {
            outline: none;
            border-color: #0088ff;
            box-shadow: 0 0 10px rgba(0, 136, 255, 0.3);
        }

        .edit-form-group textarea {
            resize: vertical;
            min-height: 80px;
            max-height: 120px;
        }

        .edit-form-group small {
            color: #999;
            font-size: 0.8rem;
            display: block;
            margin-top: 0.25rem;
        }

        .edit-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 2rem;
        }

        .edit-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .edit-btn-save {
            background: linear-gradient(45deg, #0088ff, #0070cc);
            color: white;
        }

        .edit-btn-save:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 136, 255, 0.4);
        }

        .edit-btn-cancel {
            background: transparent;
            color: #999;
            border: 2px solid #333;
        }

        .edit-btn-cancel:hover {
            color: white;
            border-color: #555;
        }

        .file-upload-area {
            border: 2px dashed #333;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-upload-area:hover {
            border-color: #0088ff;
            background: rgba(0, 136, 255, 0.05);
        }

        .file-upload-area.dragover {
            border-color: #0088ff;
            background: rgba(0, 136, 255, 0.1);
        }

        .upload-icon {
            font-size: 24px;
            margin-bottom: 8px;
            color: #999;
        }

        .upload-text {
            color: #999;
            font-size: 14px;
        }

        .image-preview {
            max-width: 100%;
            max-height: 150px;
            border-radius: 8px;
            margin-top: 10px;
        }

        /* Description Modal Styles */
        .description-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            /* Modal appears centered in viewport */
            -webkit-overflow-scrolling: touch;
        }

        .description-modal.show {
            display: flex;
        }

        .description-modal-content {
            background: #1a1a1a;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            min-width: 300px;
            border-radius: 15px;
            border: 2px solid #0088ff;
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
            margin: auto;
            animation: modalSlideIn 0.3s ease-out;
            /* Ensure modal appears in center of viewport */
            flex-shrink: 0;
            box-shadow: 0 10px 30px rgba(0, 136, 255, 0.3);
            /* Force centering */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            position: fixed;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .description-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #333;
        }

        .description-modal h3 {
            color: #0088ff;
            font-size: 1.5rem;
            margin: 0;
            word-wrap: break-word;
            max-width: 80%;
        }

        .description-modal-close {
            background: none;
            border: none;
            color: #999;
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            transition: color 0.3s ease;
            min-width: 30px;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .description-modal-close:hover {
            color: #ff6b6b;
        }

        .description-modal-text {
            color: #ccc;
            font-size: 1rem;
            line-height: 1.6;
            word-wrap: break-word;
            white-space: pre-wrap;
            max-height: 50vh;
            overflow-y: auto;
            padding-right: 10px;
        }

        /* Mobile optimizations for description modal */
        @media (max-width: 768px) {
            .description-modal-content {
                width: 95%;
                max-width: none;
                padding: 1.5rem;
                max-height: 85vh;
                margin: 10px;
                /* Better mobile positioning */
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }

            .description-modal h3 {
                font-size: 1.2rem;
                max-width: 75%;
            }

            .description-modal-text {
                font-size: 0.95rem;
                max-height: 60vh;
            }
        }

        @media (max-width: 480px) {
            .description-modal-content {
                width: 98%;
                padding: 1rem;
                max-height: 90vh;
                margin: 5px;
                border-radius: 12px;
            }

            .description-modal h3 {
                font-size: 1.1rem;
                max-width: 70%;
            }

            .description-modal-text {
                font-size: 0.9rem;
                max-height: 65vh;
                line-height: 1.5;
            }

            .description-modal-close {
                font-size: 1.8rem;
                min-width: 25px;
                min-height: 25px;
            }
        }

        /* Tablet responsive styles */
        @media (max-width: 1024px) {
            .trending-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 1.2rem;
            }
        }

        /* Mobile optimizations - no scroll indicator needed */
        .mobile-device {
            overflow-x: hidden;
        }

        .mobile-device .trending-container {
            min-height: auto;
            padding: 1rem;
        }

        /* Enhanced mobile responsiveness */
        @media (max-width: 480px) {
            .trending-container {
                padding: 0.8rem 0.4rem 6rem 0.4rem;
                /* Added large bottom padding to clear any bottom banner */
                width: 100%;
                /* Ensure full width on small mobile */
                display: block;
                /* Explicit display */
                position: relative;
                /* Back to relative positioning */
            }

            .trending-grid {
                gap: 0.8rem;
            }
        }

        @media (max-width: 768px) {
            html {
                scroll-behavior: smooth;
                -webkit-overflow-scrolling: touch;
                height: auto;
                min-height: 100vh;
            }

            body {
                overflow-x: hidden;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior-y: auto;
                scroll-behavior: smooth;
                padding: 0;
                margin: 0;
                width: 100%;
                /* Ensure body is full width */
                min-width: 320px;
                /* Minimum width for very small screens */
                height: auto;
                /* Let body expand to fit content */
                min-height: 100vh;
                /* At least viewport height */
                /* Force minimum height to accommodate all content */
                min-height: calc(100vh + 2000px);
                /* Extra height to prevent cutoff */
            }

            .trending-container {
                padding: 1rem 0.5rem 8rem 0.5rem;
                /* Added large bottom padding to clear any bottom banner */
                max-width: 100%;
                width: 100%;
                /* Ensure full width on mobile */
                overflow: visible;
                max-height: none;
                position: relative;
                /* Back to relative positioning */
                overscroll-behavior: auto;
                min-height: auto;
                /* Let content determine height naturally */
                display: block;
                /* Explicit display */
            }

            .trending-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
                margin-bottom: 1rem;
                min-height: auto;
                /* Remove height constraint on mobile - let content determine natural height */
                width: 100%;
                /* Ensure grid takes full width */
                display: grid;
                /* Explicit grid display */
            }

            .trending-title {
                font-size: 2.8rem;
                margin-bottom: 1.5rem;
                letter-spacing: 2px;
                transform: perspective(500px) rotateX(8deg);
            }

            /* Enhanced mobile scrolling for content area */
            #trending-content {
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: auto;
                /* Allow scroll-through */
                scroll-behavior: smooth;
                position: relative;
                /* Ensure content doesn't trap scrolling */
                overflow: visible;
                max-height: none;
                min-height: auto;
                /* Let content expand naturally */
                width: 100%;
                /* Full width */
                display: block;
                /* Explicit display */
            }

            .token-card {
                padding: 1rem;
                margin-bottom: 0.5rem;
                /* Better touch interactions */
                touch-action: manipulation;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
            }

            .search-container {
                margin-bottom: 1.5rem;
            }

            .search-input {
                max-width: 100%;
                padding: 0.8rem 1rem;
                font-size: 0.9rem;
            }

            .filters-container {
                gap: 15px;
                margin: 1rem 0;
                padding: 0 0.5rem;
                justify-content: center;
                /* Center the sort dropdown on mobile */
                text-align: center;
                /* Center text alignment */
            }

            /* Ensure touch scrolling works smoothly */
            .trending-container {
                -webkit-overflow-scrolling: touch;
            }

            /* Make cards more touch-friendly */
            .token-card:hover {
                transform: none;
                /* Disable hover effects on mobile */
            }

            .token-card:active {
                transform: scale(0.98);
                transition: transform 0.1s ease;
            }

            /* Mobile-optimized Load More button */
            .load-more-btn {
                width: calc(100% - 2rem);
                max-width: 300px;
                padding: 1.2rem 2rem;
                margin: 2rem auto 5rem auto;
                /* Increased bottom margin to clear banner */
                font-size: 1.1rem;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
                border-radius: 30px;
            }

            .load-more-btn:active {
                transform: scale(0.95);
                transition: transform 0.1s ease;
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .trending-title {
                font-size: 2.2rem;
                letter-spacing: 1px;
                transform: perspective(500px) rotateX(5deg);
                margin-bottom: 1rem;
            }

            .trending-container {
                padding: 1rem 0.25rem;
                /* No scroll trapping on small devices */
                height: auto;
                /* Natural height, no viewport locking */
                overflow: visible;
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
            }

            /* Optimized load more for small screens */
            .load-more-btn {
                width: calc(100% - 1rem);
                margin: 1.5rem auto 4rem auto;
                /* Increased bottom margin to clear banner */
                padding: 1rem 1.5rem;
                font-size: 1rem;
            }

            .trending-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
                min-height: auto;
                /* Remove height constraint on small mobile - let content determine natural height */
                width: 100%;
                /* Ensure grid takes full width */
                display: grid;
                /* Explicit grid display */
            }

            .token-card {
                padding: 0.8rem;
                border-radius: 10px;
            }

            .search-input {
                padding: 0.7rem 0.8rem;
                font-size: 0.85rem;
            }

            .filters-container {
                gap: 10px;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                /* Ensure center alignment */
                text-align: center;
                /* Center text alignment */
            }

            .token-links {
                gap: 0.3rem;
            }

            .token-link,
            .dexscreener-link,
            .basescan-link {
                padding: 0.3rem 0.6rem;
                font-size: 0.75rem;
            }

            .dexscreener-link img,
            .basescan-link img {
                width: 14px;
                height: 14px;
            }

            .verification-checkmark {
                font-size: 10px;
                margin-left: 3px;
            }

            .token-description {
                height: 70px;
                font-size: 0.8rem;
            }

            .description-text {
                -webkit-line-clamp: 2;
                line-clamp: 2;
            }

            .description-more-btn {
                font-size: 0.65rem;
                padding: 3px 6px;
                bottom: 6px;
                right: 6px;
            }

            .description-modal-content {
                padding: 1.5rem;
                width: 95%;
                max-height: 70vh;
            }

            .description-modal h3 {
                font-size: 1.2rem;
            }

            .description-modal-text {
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <div class="trending-container">
        <h1 class="trending-title">TRENDING TOKENS</h1>

        <div class="search-container">
            <input type="text" class="search-input" placeholder="Search by name, symbol, or address..."
                id="search-input">
        </div>

        <div class="filters-container">
            <div>
                <label class="filter-label">Sort by:</label>
                <select class="filter-select" id="sort-filter">
                    <option value="trending">Trending Score</option>
                    <option value="marketcap-high">Market Cap (High to Low)</option>
                    <option value="marketcap-low">Market Cap (Low to High)</option>
                    <option value="volume-high">Volume (High to Low)</option>
                    <option value="volume-low">Volume (Low to High)</option>
                    <option value="transactions-high">Transactions (High to Low)</option>
                    <option value="transactions-low">Transactions (Low to High)</option>
                    <option value="age-new">Age (Newest First)</option>
                    <option value="age-old">Age (Oldest First)</option>
                </select>
            </div>
        </div>

        <div id="trending-content">
            <div class="loading-container">
                <div class="loading-spinner"></div>
                <p>Loading trending tokens...</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
            </div>
        </div>

        <button class="load-more-btn" id="load-more-btn" style="display: none;">LOAD NEXT 12</button>
        <button class="back-btn" id="back-btn" style="display: none;">← BACK TO PREVIOUS 12</button>

        <!-- Height marker for iframe communication -->
        <div id="iframe-height-marker" style="height: 1px; opacity: 0; pointer-events: none;"></div>
    </div>

    <!-- Edit Token Modal -->
    <div id="edit-modal" class="edit-modal">
        <div class="edit-modal-content">
            <div class="edit-modal-header">
                <h2>Edit Token Information</h2>
                <button class="close-modal" onclick="closeEditModal()">&times;</button>
            </div>

            <!-- Update Timing Disclaimer -->
            <div class="update-disclaimer">
                <div class="disclaimer-icon">⏰</div>
                <div class="disclaimer-text">
                    <strong>Please Note:</strong> Changes may take up to 10 minutes to appear on the site.
                </div>
            </div>

            <form id="edit-token-form">
                <div class="edit-form-group">
                    <label for="edit-description">Description</label>
                    <textarea id="edit-description" placeholder="Enter token description (250 characters max)"
                        maxlength="250"></textarea>
                    <small>Characters remaining: <span id="char-count">250</span></small>
                </div>

                <div class="edit-form-group">
                    <label for="edit-website">Website URL</label>
                    <input type="url" id="edit-website" placeholder="https://your-website.com">
                    <small>Include https:// at the beginning</small>
                </div>

                <div class="edit-form-group">
                    <label for="edit-telegram">Telegram URL</label>
                    <input type="url" id="edit-telegram" placeholder="https://t.me/your-channel">
                    <small>Your Telegram channel or group link</small>
                </div>

                <div class="edit-form-group">
                    <label for="edit-x">X (Twitter) URL</label>
                    <input type="url" id="edit-x" placeholder="https://x.com/your-handle">
                    <small>Your X (Twitter) profile or project account</small>
                </div>

                <div class="edit-form-group">
                    <label>Logo Image</label>
                    <div class="file-upload-area" id="logo-upload-area">
                        <div class="upload-icon">📁</div>
                        <div class="upload-text">Click to select logo image (500x500 recommended)</div>
                        <input type="file" id="edit-logo" accept="image/*" style="display: none;">
                    </div>
                    <img id="logo-preview" class="image-preview" style="display: none;">
                </div>

                <div class="edit-form-group">
                    <label>Banner Image</label>
                    <div class="file-upload-area" id="banner-upload-area">
                        <div class="upload-icon">🖼️</div>
                        <div class="upload-text">Click to select banner image (1500x500 recommended)</div>
                        <input type="file" id="edit-banner" accept="image/*" style="display: none;">
                    </div>
                    <img id="banner-preview" class="image-preview" style="display: none;">
                </div>

                <div class="edit-buttons">
                    <button type="button" class="edit-btn edit-btn-cancel" onclick="closeEditModal()">
                        Cancel
                    </button>
                    <button type="submit" class="edit-btn edit-btn-save">
                        Save Changes
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Description Modal -->
    <div id="description-modal" class="description-modal">
        <div class="description-modal-content">
            <div class="description-modal-header">
                <h3 id="description-modal-title">Token Description</h3>
                <button class="description-modal-close" onclick="closeDescriptionModal()">&times;</button>
            </div>
            <div id="description-modal-text" class="description-modal-text">
                <!-- Full description will be inserted here -->
            </div>
        </div>
    </div>

    <!-- Uniswap Trade Modal -->
    <div id="trade-modal" class="description-modal">
        <div class="description-modal-content" style="max-width: 420px; padding: 1rem;">
            <div class="description-modal-header">
                <h3 id="trade-modal-title">Trade Token</h3>
                <button class="description-modal-close" onclick="closeTradeModal()">&times;</button>
            </div>
            <div id="trade-modal-widget" style="width: 100%; height: 600px; border-radius: 12px; overflow: hidden;">
                <!-- Uniswap widget iframe will be injected here -->
            </div>
        </div>
    </div>

    <script>
        // Simple iframe resize for mobile - only send once when content is ready
        function notifyParentOfHeight() {
            if (window.parent && window.parent !== window) {
                try {
                    const height = Math.max(
                        document.body.scrollHeight,
                        document.documentElement.scrollHeight
                    );
                    window.parent.postMessage({
                        type: 'resize',
                        height: height
                    }, '*');
                    console.log(`📏 Sent height to parent: ${height}px`);
                } catch (e) {
                    console.log('Cannot communicate with parent frame:', e);
                }
            }
        }

        class WildWestTrendingSystem {
            constructor() {
                // Configuration
                this.config = {
                    rpcUrl: 'https://responsive-omniscient-model.base-mainnet.quiknode.pro/aa86b92100862c55985ff1d322a9ff07d9ab236f/',
                    factoryAddress: '0xaB4FE16F395921081bD9895359cf173a2Eaa7125',
                    wethAddress: '0x4200000000000000000000000000000000000006',
                    uniswapV3Factory: '0x33128a8fC17869897dcE68Ed026d694621f6FDfD',
                    whitelistTokens: [
                        {
                            address: '0x5C3e978A301a71d5b48C9023EF090321a02A0fc1',
                            name: 'THE RUG POOL',
                            symbol: 'TRP'
                        },
                        {
                            address: '0x8129609E5303910464FCe3022a809fA44455Fe9A',
                            name: 'WILDWEST',
                            symbol: 'WILDW'
                        }
                    ],
                    blacklistedTokens: [
                        '0x72213f5b7c246fb5d14a2aae41d0f73e88310fb4',
                        '0xd5fa8927fa46e866270f4ac884c5967bbed71f13',
                        '0xba4ddbeb1759f894f05ff069f087a44b4132ff97',
                        '0xa575dae0eb60285145d01244be70509706e019a8',
                        '0xd6a1e1cc46964058ad1f2c80099fe8dbe5d721a1',
                        '0xe4954c7cf50c2c63c60e3e24235a24fc0f4ee9a9',
                        '0x6f82fb68263d55472f691bcbc855b6ceba12c7e0',
                        '0x81ab938882e4a5ed44e04e4575c64ac02f6be1a8',
                        '0xe4954c7cf50c2c63c60e3e24235a24fc0f4ee9a9',
                        '0x6f82fb68263d55472f691bcbc855b6ceba12c7e0'
                    ]
                };

                // Factory ABI (minimal)
                this.factoryABI = [
                    'function getTokenCount() view returns (uint256)',
                    'function allTokens(uint256) view returns (address tokenAddress, address creator, string symbol, string name, uint256 createdAt, address poolAddress)'
                ];

                // State
                this.tokens = [];
                this.filteredTokens = [];
                this.isLoading = false;
                this.currentPage = 1;
                this.tokensPerPage = 12; // Always show 12 tokens
                this.searchQuery = '';
                this.sortFilter = 'trending';

                // Initialize
                this.init();
            }

            async init() {
                console.log('🚀 Initializing Wild West Trending System...');

                try {
                    // Setup provider
                    this.provider = new ethers.providers.JsonRpcProvider(this.config.rpcUrl);
                    console.log('✅ Provider connected');

                    // Initialize storage system
                    try {
                        window.tokenMetadataStorage = new TokenMetadataStorage();
                        console.log('🗄️ Storage system initialized');

                        // Fix missing logos for all projects immediately
                        this.fixMissingLogos();
                    } catch (error) {
                        console.warn('⚠️ Storage system not available:', error.message);
                    }

                    // Setup event listeners
                    this.setupEventListeners();

                    // Setup mobile-specific optimizations
                    this.setupMobileOptimizations();

                    // Load tokens with progress tracking
                    await this.loadTokensWithProgress();

                    console.log('✅ System initialized successfully!');

                } catch (error) {
                    console.error('❌ Initialization failed:', error);
                    this.showErrorState(error);
                }
            }

            setupEventListeners() {
                // Search functionality
                const searchInput = document.getElementById('search-input');
                searchInput.addEventListener('input', (e) => {
                    this.searchQuery = e.target.value.toLowerCase();
                    this.applyFiltersAndRender();
                });

                const sortFilter = document.getElementById('sort-filter');
                sortFilter.addEventListener('change', (e) => {
                    this.sortFilter = e.target.value;
                    this.applyFiltersAndRender();
                });

                // Load more button
                const loadMoreBtn = document.getElementById('load-more-btn');
                loadMoreBtn.addEventListener('click', () => {
                    if (this.isLoading) return; // Prevent clicks during loading

                    // Check if there are more tokens to load
                    const tokensPerPage = 12;
                    const startIndex = (this.currentPage - 1) * tokensPerPage;
                    const endIndex = startIndex + tokensPerPage;
                    const hasMoreTokens = endIndex < this.filteredTokens.length;

                    if (!hasMoreTokens) {
                        // Show alert when trying to load but no more tokens available
                        alert('No more tokens available to load.');
                        return;
                    }

                    this.currentPage++;
                    console.log(`📄 Loading page ${this.currentPage} for current filter...`);
                    this.renderTokens();

                    // Auto-scroll to the top of the trending widget after loading new cards
                    setTimeout(() => {
                        const trendingContent = document.getElementById('trending-content');
                        if (trendingContent) {
                            trendingContent.scrollIntoView({
                                behavior: 'smooth',
                                block: 'start'
                            });
                            console.log(`📜 Auto-scrolled to top of page ${this.currentPage} cards`);
                        }
                    }, 100); // Small delay to ensure rendering is complete
                });

                // Back button
                const backBtn = document.getElementById('back-btn');
                backBtn.addEventListener('click', () => {
                    if (this.isLoading) return; // Prevent clicks during loading

                    if (this.currentPage > 1) {
                        this.currentPage--;
                        console.log(`🔙 Going back to page ${this.currentPage}`);
                        this.renderTokens();

                        // Auto-scroll to the top of the trending widget after going back
                        setTimeout(() => {
                            const trendingContent = document.getElementById('trending-content');
                            if (trendingContent) {
                                trendingContent.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'start'
                                });
                                console.log(`📜 Auto-scrolled to top of page ${this.currentPage} cards`);
                            }
                        }, 100); // Small delay to ensure rendering is complete
                    }
                });
            }

            setupMobileOptimizations() {
                // Detect if we're on mobile
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                    window.innerWidth <= 768;

                if (isMobile) {
                    console.log('📱 Mobile device detected - applying mobile optimizations');

                    // Add mobile class to body for CSS targeting
                    document.body.classList.add('mobile-device');

                    // Ensure smooth scrolling on mobile
                    document.documentElement.style.scrollBehavior = 'smooth';

                    // Optimize touch interactions
                    document.addEventListener('touchstart', () => { }, { passive: true });

                    console.log('✅ Mobile optimizations applied - no scroll indicator needed');
                } else {
                    console.log('🖥️ Desktop device detected - standard layout');
                }
            }

            // Bulletproof logo validation and fallback system
            validateAndFixLogo(token) {
                return new Promise((resolve) => {
                    if (!token.logo || token.logo.trim() === '') {
                        console.log(`⚠️ ${token.symbol}: No logo URL available`);
                        resolve(null);
                        return;
                    }

                    // Create a temporary image to test if logo loads
                    const testImg = new Image();
                    const timeout = setTimeout(() => {
                        console.log(`⚠️ ${token.symbol}: Logo URL timeout - ${token.logo}`);
                        resolve(null);
                    }, 5000); // 5 second timeout

                    testImg.onload = () => {
                        clearTimeout(timeout);
                        console.log(`✅ ${token.symbol}: Logo URL valid - ${token.logo}`);
                        resolve(token.logo);
                    };

                    testImg.onerror = () => {
                        clearTimeout(timeout);
                        console.log(`❌ ${token.symbol}: Logo URL failed - ${token.logo}`);
                        // Try to get logo from alternative sources
                        this.tryAlternativeLogoSources(token).then(resolve);
                    };

                    testImg.src = token.logo;
                });
            }

            // Try alternative logo sources when primary fails
            async tryAlternativeLogoSources(token) {
                console.log(`🔍 ${token.symbol}: Trying alternative logo sources...`);

                // Try DexScreener logo if available
                if (token.dexScreenerLogo) {
                    const dexLogo = await this.testImageUrl(token.dexScreenerLogo);
                    if (dexLogo) {
                        console.log(`✅ ${token.symbol}: Using DexScreener logo`);
                        return dexLogo;
                    }
                }

                // Try token metadata storage backup
                if (window.tokenMetadataStorage) {
                    try {
                        const backupMetadata = await window.tokenMetadataStorage.getTokenMetadata(token.address);
                        if (backupMetadata && backupMetadata.logoBackup) {
                            const backupLogo = await this.testImageUrl(backupMetadata.logoBackup);
                            if (backupLogo) {
                                console.log(`✅ ${token.symbol}: Using backup logo`);
                                return backupLogo;
                            }
                        }
                    } catch (error) {
                        console.log(`⚠️ ${token.symbol}: Could not check backup logo:`, error.message);
                    }
                }

                console.log(`❌ ${token.symbol}: No alternative logo sources available`);
                return null;
            }

            // Test if an image URL is valid
            testImageUrl(url) {
                return new Promise((resolve) => {
                    const img = new Image();
                    const timeout = setTimeout(() => resolve(null), 3000);

                    img.onload = () => {
                        clearTimeout(timeout);
                        resolve(url);
                    };

                    img.onerror = () => {
                        clearTimeout(timeout);
                        resolve(null);
                    };

                    img.src = url;
                });
            }

            // Bulletproof metadata validation and backup system
            async validateAndFixAllMetadata(token) {
                const fixes = {};

                // Validate logo
                const validLogo = await this.validateAndFixLogo(token);
                if (validLogo !== token.logo) {
                    fixes.logo = validLogo;
                }

                // Validate banner
                if (token.banner) {
                    const validBanner = await this.validateImageUrl(token.banner, `${token.symbol} banner`);
                    if (!validBanner) {
                        fixes.banner = null;
                        console.log(`⚠️ ${token.symbol}: Banner URL failed - ${token.banner}`);
                    }
                }

                // Validate website URL
                if (token.website) {
                    const validWebsite = await this.validateUrl(token.website, `${token.symbol} website`);
                    if (!validWebsite) {
                        fixes.website = null;
                        console.log(`⚠️ ${token.symbol}: Website URL failed - ${token.website}`);
                    }
                }

                // Validate Telegram URL
                if (token.telegram) {
                    const validTelegram = await this.validateUrl(token.telegram, `${token.symbol} telegram`);
                    if (!validTelegram) {
                        fixes.telegram = null;
                        console.log(`⚠️ ${token.symbol}: Telegram URL failed - ${token.telegram}`);
                    }
                }

                // Validate X (Twitter) URL
                if (token.x) {
                    const validX = await this.validateUrl(token.x, `${token.symbol} X`);
                    if (!validX) {
                        fixes.x = null;
                        console.log(`⚠️ ${token.symbol}: X URL failed - ${token.x}`);
                    }
                }

                // Apply fixes if any were needed
                if (Object.keys(fixes).length > 0) {
                    console.log(`🔧 ${token.symbol}: Applying metadata fixes:`, fixes);
                    Object.assign(token, fixes);

                    // Save the fixed metadata back to storage
                    if (window.tokenMetadataStorage) {
                        try {
                            await this.saveMetadataBackup(token, fixes);
                        } catch (error) {
                            console.error(`Failed to save metadata fixes for ${token.symbol}:`, error);
                        }
                    }
                }

                return fixes;
            }

            // Validate any image URL
            async validateImageUrl(url, description) {
                if (!url || url.trim() === '') return null;

                return new Promise((resolve) => {
                    const testImg = new Image();
                    const timeout = setTimeout(() => {
                        console.log(`⚠️ ${description}: Image URL timeout - ${url}`);
                        resolve(null);
                    }, 5000);

                    testImg.onload = () => {
                        clearTimeout(timeout);
                        console.log(`✅ ${description}: Image URL valid - ${url}`);
                        resolve(url);
                    };

                    testImg.onerror = () => {
                        clearTimeout(timeout);
                        console.log(`❌ ${description}: Image URL failed - ${url}`);
                        resolve(null);
                    };

                    testImg.src = url;
                });
            }

            // Validate any web URL
            async validateUrl(url, description) {
                if (!url || url.trim() === '') return null;

                try {
                    // Basic URL validation
                    const urlObj = new URL(url);
                    if (!['http:', 'https:'].includes(urlObj.protocol)) {
                        console.log(`❌ ${description}: Invalid protocol - ${url}`);
                        return null;
                    }

                    // Try to fetch with timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);

                    try {
                        const response = await fetch(url, {
                            method: 'HEAD',
                            signal: controller.signal,
                            mode: 'no-cors' // Avoid CORS issues
                        });
                        clearTimeout(timeoutId);

                        console.log(`✅ ${description}: URL reachable - ${url}`);
                        return url;
                    } catch (fetchError) {
                        clearTimeout(timeoutId);
                        if (fetchError.name === 'AbortError') {
                            console.log(`⚠️ ${description}: URL timeout - ${url}`);
                        } else {
                            // For no-cors, we can't check response, but no error means it's reachable
                            console.log(`✅ ${description}: URL assumed valid (CORS) - ${url}`);
                            return url;
                        }
                        return null;
                    }
                } catch (error) {
                    console.log(`❌ ${description}: URL validation failed - ${url}:`, error.message);
                    return null;
                }
            }

            // Save metadata backup with multiple redundancy layers
            async saveMetadataBackup(token, fixes) {
                try {
                    const existingMetadata = await window.tokenMetadataStorage.getTokenMetadata(token.address) || {};

                    // Create comprehensive backup
                    const backupMetadata = {
                        ...existingMetadata,
                        // Current data
                        description: token.description,
                        website: token.website,
                        telegram: token.telegram,
                        x: token.x,
                        logo: token.logo,
                        banner: token.banner,
                        // Backup data with timestamps
                        backups: {
                            ...(existingMetadata.backups || {}),
                            [Date.now()]: {
                                description: token.description,
                                website: token.website,
                                telegram: token.telegram,
                                x: token.x,
                                logo: token.logo,
                                banner: token.banner,
                                fixes: fixes,
                                timestamp: new Date().toISOString()
                            }
                        },
                        // Validation tracking
                        lastValidated: Date.now(),
                        validationCount: (existingMetadata.validationCount || 0) + 1,
                        fixesApplied: (existingMetadata.fixesApplied || 0) + Object.keys(fixes).length
                    };

                    // Keep only last 5 backups to prevent storage bloat
                    const backupKeys = Object.keys(backupMetadata.backups || {}).sort();
                    if (backupKeys.length > 5) {
                        const toKeep = backupKeys.slice(-5);
                        const filteredBackups = {};
                        toKeep.forEach(key => {
                            filteredBackups[key] = backupMetadata.backups[key];
                        });
                        backupMetadata.backups = filteredBackups;
                    }

                    await window.tokenMetadataStorage.saveTokenMetadata(token.address, backupMetadata);
                    console.log(`💾 ${token.symbol}: Metadata backup saved with ${Object.keys(fixes).length} fixes`);

                } catch (error) {
                    console.error(`Failed to save metadata backup for ${token.symbol}:`, error);
                    // Don't throw - this is a backup operation, not critical
                }
            }

            // Recover metadata from backups when primary fails
            async recoverMetadataFromBackups(token) {
                if (!window.tokenMetadataStorage) return null;

                try {
                    const metadata = await window.tokenMetadataStorage.getTokenMetadata(token.address);
                    if (!metadata || !metadata.backups) return null;

                    // Get most recent backup
                    const backupKeys = Object.keys(metadata.backups).sort().reverse();
                    if (backupKeys.length === 0) return null;

                    const latestBackup = metadata.backups[backupKeys[0]];
                    console.log(`🔄 ${token.symbol}: Recovering from backup dated ${latestBackup.timestamp}`);

                    return {
                        description: latestBackup.description,
                        website: latestBackup.website,
                        telegram: latestBackup.telegram,
                        x: latestBackup.x,
                        logo: latestBackup.logo,
                        banner: latestBackup.banner
                    };

                } catch (error) {
                    console.error(`Failed to recover metadata backup for ${token.symbol}:`, error);
                    return null;
                }
            }

            // Emergency fix for missing logo metadata (comprehensive check)
            async fixMissingLogos() {
                // Known projects with logo files but potentially missing metadata
                const projectsToCheck = [
                    {
                        address: '0x8129609E5303910464FCe3022a809fA44455Fe9A',
                        symbol: 'WILDW',
                        logoFile: '0x8129609e5303910464fce3022a809fa44455fe9a_logo.png'
                    },
                    {
                        address: '0x5C3e978A301a71d5b48C9023EF090321a02A0fc1',
                        symbol: 'TRP',
                        logoFile: '0x5c3e978a301a71d5b48c9023ef090321a02a0fc1_logo.jpg'
                    }
                ];

                try {
                    console.log('🔧 Checking all projects for missing logo metadata...');

                    if (!window.tokenMetadataStorage) {
                        console.log('⚠️ No storage system available for logo fix');
                        return;
                    }

                    for (const project of projectsToCheck) {
                        const expectedLogoUrl = `https://raw.githubusercontent.com/cowboytbc/wildwest-banner-storage/main/token-assets/logos/${project.logoFile}`;

                        // Get current metadata
                        const currentMetadata = await window.tokenMetadataStorage.loadTokenMetadata(project.address);

                        // Always update WILDWEST logo since it's missing from the metadata
                        if (project.symbol === 'WILDW' || !currentMetadata?.logo) {
                            console.log(`🔧 ${project.symbol} logo ${currentMetadata?.logo ? 'needs refresh' : 'missing'}, checking file availability...`);

                            // Test if logo URL is accessible
                            const logoExists = await this.testImageUrl(expectedLogoUrl);
                            if (!logoExists) {
                                console.log(`❌ ${project.symbol} logo file not accessible at expected URL`);
                                continue;
                            }

                            console.log(`🔧 Adding/updating logo for ${project.symbol}...`);

                            // Update metadata with logo
                            const updatedMetadata = {
                                ...(currentMetadata || {}),
                                logo: expectedLogoUrl,
                                logoFixed: new Date().toISOString()
                            };

                            await window.tokenMetadataStorage.saveTokenMetadata(project.address, updatedMetadata);
                            console.log(`✅ ${project.symbol} logo metadata fixed!`);

                            // Also immediately apply to token object if it exists
                            const token = this.allTokens?.find(t => t.address.toLowerCase() === project.address.toLowerCase());
                            if (token) {
                                token.logo = expectedLogoUrl;
                                console.log(`🎯 Applied logo directly to ${project.symbol} token object`);
                            }
                        } else {
                            console.log(`✅ ${project.symbol} logo already exists:`, currentMetadata.logo);
                        }
                    }

                } catch (error) {
                    console.error('❌ Failed to fix missing logos:', error);
                }
            }

            // Create integrity hash for metadata validation
            createMetadataHash(metadata) {
                const content = JSON.stringify({
                    description: metadata.description || '',
                    website: metadata.website || '',
                    telegram: metadata.telegram || '',
                    x: metadata.x || '',
                    logo: metadata.logo || '',
                    banner: metadata.banner || ''
                });

                // Simple hash function for integrity checking
                let hash = 0;
                for (let i = 0; i < content.length; i++) {
                    const char = content.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return hash.toString(16);
            }

            // Validate metadata integrity
            validateMetadataIntegrity(metadata) {
                if (!metadata.integrityHash) return true; // No hash to check

                const currentHash = this.createMetadataHash(metadata);
                const isValid = currentHash === metadata.integrityHash;

                if (!isValid) {
                    console.warn('⚠️ Metadata integrity check failed - data may be corrupted');
                }

                return isValid;
            }

            async loadTokensWithProgress() {
                console.log('📊 Loading tokens with progress tracking...');
                this.isLoading = true;

                try {
                    // Initialize arrays
                    const allTokens = [];

                    // Load factory tokens
                    const factoryTokens = await this.loadFactoryTokens();
                    allTokens.push(...factoryTokens);

                    // Load whitelist tokens  
                    const whitelistTokens = await this.loadWhitelistTokens();
                    allTokens.push(...whitelistTokens);

                    console.log(`📈 Processing ${allTokens.length} tokens...`);
                    console.log('🔍 All tokens being processed:', allTokens.map(t => t.symbol || t.name || 'unnamed'));

                    // Process tokens in batches for better UX
                    const processedTokens = [];
                    for (let i = 0; i < allTokens.length; i++) {
                        const token = allTokens[i];

                        try {
                            // Update progress
                            this.updateProgress(i + 1, allTokens.length);

                            // Enrich token data
                            const enrichedToken = await this.enrichTokenData(token);
                            if (enrichedToken) {
                                processedTokens.push(enrichedToken);
                                console.log(`✅ Added: ${enrichedToken.symbol} ($${enrichedToken.price?.toFixed(6) || '0'})`);
                            }

                            // Show partial results every few tokens
                            if (processedTokens.length > 0 && (processedTokens.length % 3 === 0 || i === allTokens.length - 1)) {
                                this.tokens = [...processedTokens];
                                this.applyFiltersAndRender();
                            }

                        } catch (error) {
                            console.warn(`❌ Failed to process token ${i + 1} (${token.symbol || token.name || 'unnamed'}):`, error.message);
                            console.log('Token that failed:', token);
                        }
                    }

                    this.tokens = processedTokens;
                    this.allTokens = processedTokens; // Store for metadata operations

                    // Load and apply stored metadata
                    await this.loadStoredMetadata();

                    // Check verification status for all tokens
                    console.log('🔍 Checking verification status...');
                    for (const token of this.tokens) {
                        try {
                            // Check if contract is verified (async check)
                            token.isVerified = await this.isContractVerified(token.address);

                            // Check if has premium Dex data (sync check based on token properties)
                            token.isPremiumDex = this.isPremiumDexData(token);

                            if (token.isVerified) {
                                console.log(`✅ ${token.symbol} - Contract verified`);
                            }
                            if (token.isPremiumDex) {
                                console.log(`⭐ ${token.symbol} - Premium Dexscreener data`);
                            }
                        } catch (error) {
                            console.log(`❌ Verification check failed for ${token.symbol}:`, error.message);
                            token.isVerified = false;
                            token.isPremiumDex = false;
                        }
                    }

                    // Calculate relative trending scores now that all tokens are loaded
                    this.calculateTrendingScores();

                    this.applyFiltersAndRender();

                    console.log(`✅ Successfully loaded ${this.tokens.length} tokens out of ${allTokens.length} total`);
                    console.log('📊 Final tokens:', this.tokens.map(t => t.symbol));

                } catch (error) {
                    console.error('❌ Token loading failed:', error);
                    throw error;
                } finally {
                    this.isLoading = false;
                }
            }

            async loadFactoryTokens() {
                console.log('🏭 Loading factory tokens...');

                try {
                    const factoryContract = new ethers.Contract(
                        this.config.factoryAddress,
                        this.factoryABI,
                        this.provider
                    );

                    const tokenCount = await factoryContract.getTokenCount();
                    console.log(`📊 Factory has ${tokenCount} tokens`);

                    const tokens = [];
                    for (let i = 0; i < tokenCount; i++) {
                        try {
                            const tokenInfo = await factoryContract.allTokens(i);

                            // Debug what we get from the factory
                            console.log(`🔍 Factory token ${i}:`, tokenInfo);
                            console.log(`   - tokenAddress: ${tokenInfo.tokenAddress || tokenInfo[0]}`);
                            console.log(`   - creator: ${tokenInfo.creator || tokenInfo[1]}`);
                            console.log(`   - symbol: ${tokenInfo.symbol || tokenInfo[2]}`);
                            console.log(`   - name: ${tokenInfo.name || tokenInfo[3]}`);

                            // Handle both object and array responses
                            const address = tokenInfo.tokenAddress || tokenInfo[0];
                            const creator = tokenInfo.creator || tokenInfo[1];
                            // Fix: swap symbol and name assignment since contract returns them reversed
                            const symbol = tokenInfo.name || tokenInfo[3];
                            const name = tokenInfo.symbol || tokenInfo[2];
                            const createdAt = tokenInfo.createdAt || tokenInfo[4];
                            const pool = tokenInfo.poolAddress || tokenInfo[5];

                            // Skip blacklisted tokens
                            if (this.config.blacklistedTokens.includes(address.toLowerCase())) {
                                continue;
                            }

                            tokens.push({
                                address: address,
                                creator: creator,
                                symbol: symbol,
                                name: name,
                                createdAt: createdAt ? parseInt(createdAt.toString()) : 0,
                                pool: pool,
                                isFactoryToken: true
                            });

                        } catch (error) {
                            console.warn(`Failed to load factory token ${i}:`, error.message);
                        }
                    }

                    console.log(`✅ Loaded ${tokens.length} factory tokens`);
                    return tokens;

                } catch (error) {
                    console.error('❌ Factory loading failed:', error);
                    return [];
                }
            }

            async loadWhitelistTokens() {
                console.log('📋 Loading whitelist tokens...');

                // Hardcoded creator address for whitelisted tokens (project owner)
                const projectOwnerAddress = '0x9360c80CA79409b5e315A9791bB0208C02D6ae32';

                const tokens = this.config.whitelistTokens.map(token => ({
                    address: token.address,
                    name: token.name,
                    symbol: token.symbol,
                    creator: projectOwnerAddress, // Add creator for edit functionality
                    isFactoryToken: false
                }));

                console.log(`✅ Loaded ${tokens.length} whitelist tokens with project owner as creator`);
                return tokens;
            }

            async enrichTokenData(basicData) {
                try {
                    console.log(`🔍 Enriching ${basicData.symbol || basicData.address}`);

                    // Get basic token info if needed
                    if (!basicData.name || !basicData.symbol) {
                        const tokenContract = new ethers.Contract(
                            basicData.address,
                            [
                                'function name() view returns (string)',
                                'function symbol() view returns (string)',
                                'function decimals() view returns (uint8)',
                                'function totalSupply() view returns (uint256)'
                            ],
                            this.provider
                        );

                        basicData.name = await tokenContract.name();
                        basicData.symbol = await tokenContract.symbol();
                    }

                    // Get trading data
                    const tradingData = await this.getTradingData(basicData);

                    // Calculate age - only use real liquidity age, show 0 for no data
                    let age = null;

                    if (tradingData.realAge !== undefined && tradingData.realAge !== null) {
                        // Use real liquidity age from DexScreener (when first pool was created)
                        age = tradingData.realAge;
                    } else if (tradingData.dataSource === 'NO_DATA') {
                        // If no trading data exists, age should be 0 (not tradeable yet)
                        age = 0;
                    } else if (basicData.createdAt) {
                        // Only use factory creation if we have some trading data but no liquidity timestamp
                        age = (Date.now() / 1000 - basicData.createdAt) / 86400;
                    } else {
                        // No data at all
                        age = 0;
                    }

                    // Note: trending score will be calculated later in batch for relative ranking

                    return {
                        address: basicData.address,
                        name: basicData.name,
                        symbol: basicData.symbol,
                        creator: basicData.creator || null, // Preserve creator information
                        price: tradingData.price,
                        marketCap: tradingData.marketCap,
                        volume24h: tradingData.volume24h,
                        transactions: tradingData.transactions,
                        priceChange24h: tradingData.priceChange24h,
                        age: age,
                        trendingScore: 0, // Will be calculated in batch later
                        dataSource: tradingData.dataSource,
                        isFactoryToken: basicData.isFactoryToken,
                        // Premium Dexscreener features from API
                        hasApiLogo: tradingData.hasApiLogo || false,
                        hasApiWebsite: tradingData.hasApiWebsite || false,
                        hasApiSocials: tradingData.hasApiSocials || false,
                        // Additional metadata fields
                        description: this.truncateDescription(basicData.description || 'No description available'),
                        website: basicData.website || null,
                        telegram: basicData.telegram || null,
                        logo: basicData.logo || null,
                        banner: basicData.banner || null
                    };

                } catch (error) {
                    console.error(`❌ Failed to enrich token data:`, error);
                    return null;
                }
            }

            async getTradingData(tokenData) {
                // Only try DexScreener API for real data
                const dexData = await this.getDexScreenerData(tokenData.address);
                if (dexData) {
                    return dexData;
                }

                // No fake data - return zeros if no real data available
                console.log(`❌ No trading data available for ${tokenData.symbol || tokenData.address}`);
                return {
                    price: 0,
                    marketCap: 0,
                    volume24h: 0,
                    transactions: 0,
                    priceChange24h: 0,
                    dataSource: 'NO_DATA'
                };
            }

            async getDexScreenerData(tokenAddress) {
                try {
                    console.log(`🔍 Checking DexScreener for ${tokenAddress}`);

                    const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Timeout')), 3000)
                    );

                    const fetchPromise = fetch(`https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`);
                    const response = await Promise.race([fetchPromise, timeoutPromise]);

                    if (!response.ok) {
                        return null;
                    }

                    const data = await response.json();

                    if (!data.pairs || data.pairs.length === 0) {
                        return null;
                    }

                    // Get the best pair (highest liquidity)
                    const bestPair = data.pairs.sort((a, b) =>
                        (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0)
                    )[0];

                    if (!bestPair.priceUsd) {
                        return null;
                    }

                    const price = parseFloat(bestPair.priceUsd);
                    const volume24h = parseFloat(bestPair.volume?.h24 || 0);
                    const marketCap = parseFloat(bestPair.marketCap || bestPair.fdv || 0);
                    const priceChange24h = parseFloat(bestPair.priceChange?.h24 || 0);

                    // Extract real age from when liquidity was first added
                    let realAge = null;
                    if (bestPair.pairCreatedAt) {
                        const liquidityAddedTimestamp = bestPair.pairCreatedAt; // This is in milliseconds
                        realAge = (Date.now() - liquidityAddedTimestamp) / (1000 * 86400); // Convert to days
                    }

                    // Get actual transaction count (buys + sells) from DexScreener
                    let transactions = 0;
                    if (bestPair.txns && bestPair.txns.h24) {
                        const buys = parseInt(bestPair.txns.h24.buys || 0);
                        const sells = parseInt(bestPair.txns.h24.sells || 0);
                        transactions = buys + sells;
                    }

                    console.log(`✅ DexScreener: $${price} | Vol: $${volume24h.toLocaleString()} | MC: ${marketCap.toLocaleString()} | Txns: ${transactions} (${bestPair.txns?.h24?.buys || 0} buys, ${bestPair.txns?.h24?.sells || 0} sells) | Liquidity Age: ${realAge ? `${realAge.toFixed(1)} days` : 'Unknown'}`);

                    // Check for premium Dexscreener features from API response
                    const hasApiLogo = bestPair.info?.imageUrl || data.pairs?.[0]?.info?.imageUrl;
                    const apiLogoUrl = bestPair.info?.imageUrl || data.pairs?.[0]?.info?.imageUrl;
                    const hasApiWebsite = bestPair.info?.websites?.length > 0 || data.pairs?.[0]?.info?.websites?.length > 0;
                    const hasApiSocials = bestPair.info?.socials?.length > 0 || data.pairs?.[0]?.info?.socials?.length > 0;

                    if (hasApiLogo || hasApiWebsite || hasApiSocials) {
                        console.log(`⭐ DexScreener API shows premium features for token: Logo: ${!!hasApiLogo}, Website: ${!!hasApiWebsite}, Socials: ${!!hasApiSocials}`);
                    }

                    return {
                        price: price,
                        marketCap: marketCap,
                        volume24h: volume24h,
                        transactions: transactions,
                        priceChange24h: priceChange24h,
                        realAge: realAge, // Include real age from trading data
                        dataSource: 'DEXSCREENER',
                        // Premium indicators from API
                        hasApiLogo: !!hasApiLogo,
                        hasApiWebsite: !!hasApiWebsite,
                        hasApiSocials: !!hasApiSocials,
                        // Store DexScreener logo as backup
                        dexScreenerLogo: apiLogoUrl || null
                    };

                } catch (error) {
                    console.log(`❌ DexScreener failed: ${error.message}`);
                    return null;
                }
            }

            // Check if contract is verified on Basescan
            async isContractVerified(tokenAddress) {
                try {
                    const token = this.tokens.find(t => t.address === tokenAddress);
                    if (!token) return false;

                    // Factory contracts are ALWAYS verified (you deployed them with verified source code)
                    if (token.isFactoryToken) {
                        console.log(`✅ ${token.symbol} - Factory token (automatically verified)`);
                        return true;
                    }

                    // For whitelist/external tokens, use heuristics:
                    // 1. If token has complete social presence (website, telegram, AND twitter)
                    // 2. If token has high market cap (over $50k - lowered threshold)
                    // 3. If token has been trading for more than 3 days (lowered threshold)

                    const hasAllSocials = token.website && token.telegram && token.x;
                    const hasHighMarketCap = token.marketCap > 50000; // $50k+ (lowered from $100k)
                    const isEstablished = token.age > 3; // More than 3 days old (lowered from 7)

                    // Token is considered "verified" if it meets 2 out of 3 criteria
                    const verificationScore = [hasAllSocials, hasHighMarketCap, isEstablished].filter(Boolean).length;

                    return verificationScore >= 2;
                } catch (error) {
                    console.log(`❌ Contract verification check failed: ${error.message}`);
                    return false;
                }
            }

            // Check if project has premium Dexscreener data
            isPremiumDexData(token) {
                try {
                    // PREMIUM INDICATORS: ONLY features that require payment to DexScreener:
                    // 1. Custom logo from DexScreener API (hasApiLogo = true)
                    // 2. Custom banner from DexScreener API (hasApiBanner = true)
                    //
                    // NOTE: 
                    // - token.logo from our GitHub storage doesn't count (that's free)
                    // - token.banner from our GitHub storage doesn't count (that's free)
                    // - Only hasApiLogo and hasApiBanner flags indicate PAID DexScreener features

                    const hasCustomApiBanner = token.hasApiBanner; // Banner from DexScreener API (premium)
                    const hasCustomApiLogo = token.hasApiLogo; // Logo from DexScreener API (premium)

                    // Debug logging for ALL tokens to see what's happening
                    console.log(`🔍 PREMIUM CHECK ${token.symbol} (${token.address.substring(0, 6)}...):`);
                    console.log(`  - GitHub Banner: ${token.banner ? '✅ YES' : '❌ NO'} (FREE - not counted)`);
                    console.log(`  - GitHub Logo: ${token.logo ? '✅ YES' : '❌ NO'} (FREE - not counted)`);
                    console.log(`  - API Banner: ${hasCustomApiBanner ? '✅ YES (PREMIUM)' : '❌ NO'}`);
                    console.log(`  - API Logo: ${hasCustomApiLogo ? '✅ YES (PREMIUM)' : '❌ NO'}`);
                    console.log(`  - API Website: ${token.hasApiWebsite ? '⚠️ YES (BASIC API)' : '❌ NO'} (not counted yet)`);
                    console.log(`  - API Socials: ${token.hasApiSocials ? '⚠️ YES (BASIC API)' : '❌ NO'} (not counted yet)`);

                    // Extra debug for specific problematic tokens
                    if (token.address.toLowerCase().includes('d5fa8927') ||
                        token.address.toLowerCase().includes('8129609e')) {
                        console.log(`🚨 PROBLEM TOKEN DEBUG ${token.symbol}:`);
                        console.log(`  - FULL DATA:`, {
                            banner: token.banner,
                            logo: token.logo,
                            hasApiBanner: token.hasApiBanner,
                            hasApiLogo: token.hasApiLogo,
                            hasApiBanner: token.hasApiBanner,
                            hasApiLogo: token.hasApiLogo,
                            hasApiWebsite: token.hasApiWebsite,
                            hasApiSocials: token.hasApiSocials,
                            website: token.website,
                            telegram: token.telegram,
                            x: token.x
                        });
                    }

                    // Check for ACTUAL premium features (only API features count)
                    if (hasCustomApiBanner) {
                        console.log(`⭐ ${token.symbol} - PREMIUM: Custom API banner detected`);
                        return true;
                    }

                    if (hasCustomApiLogo) {
                        console.log(`⭐ ${token.symbol} - PREMIUM: Custom API logo detected`);
                        return true;
                    }

                    console.log(`❌ ${token.symbol} - NOT PREMIUM: No custom API banner or API logo (GitHub storage doesn't count)`);
                    return false;
                } catch (error) {
                    console.log(`❌ Premium check failed for ${token.symbol}: ${error.message}`);
                    return false;
                }
            }

            calculateTrendingScores() {
                // First pass: collect all values for relative ranking
                const tradingTokens = this.tokens.filter(token =>
                    token.volume24h > 0 || token.transactions > 0 || token.marketCap > 0
                );

                if (tradingTokens.length === 0) {
                    // No trading data available, just assign 0 scores
                    this.tokens.forEach(token => {
                        token.trendingScore = 0;
                    });
                    return;
                }

                // Get arrays of all values for ranking
                const ages = tradingTokens.map(t => t.age).filter(a => a !== null && a > 0);
                const transactions = tradingTokens.map(t => t.transactions).filter(t => t > 0);
                const volumes = tradingTokens.map(t => t.volume24h).filter(v => v > 0);
                const marketCaps = tradingTokens.map(t => t.marketCap).filter(m => m > 0);

                // Calculate scores for each token
                this.tokens.forEach(token => {
                    token.trendingScore = this.calculateRelativeScore(token, {
                        ages, transactions, volumes, marketCaps
                    });
                });

                // Store original trending ranking (before any filtering)
                this.setOriginalRankings();
            }

            setOriginalRankings() {
                // Create a sorted copy of tokens to determine original ranking
                const sortedTokens = [...this.tokens].sort((a, b) => {
                    // Same sorting logic as in applyFiltersAndRender
                    const aHasData = a.volume24h > 0 || a.transactions > 0 || a.marketCap > 0;
                    const bHasData = b.volume24h > 0 || b.transactions > 0 || b.marketCap > 0;

                    if (aHasData && !bHasData) return -1;
                    if (!aHasData && bHasData) return 1;

                    if (aHasData && bHasData) {
                        return (b.trendingScore || 0) - (a.trendingScore || 0);
                    }

                    return (a.symbol || '').localeCompare(b.symbol || '');
                });

                // Assign original rank to each token
                sortedTokens.forEach((token, index) => {
                    token.originalRank = index + 1;
                });

                console.log('🏆 Original trending rankings assigned:');
                sortedTokens.slice(0, 12).forEach((token, i) => {
                    console.log(`  ${i + 1}. ${token.symbol} (score: ${token.trendingScore?.toFixed(2)})`);
                });
            }

            calculateRelativeScore(token, allValues) {
                let ageScore = 0;
                let transactionScore = 0;
                let volumeScore = 0;
                let marketCapScore = 0;

                // Age scoring: rank among all ages (newer = higher score)
                if (token.age !== null && token.age > 0 && allValues.ages.length > 0) {
                    const ageRank = allValues.ages.filter(a => a > token.age).length;
                    ageScore = ((allValues.ages.length - ageRank) / allValues.ages.length) * 100;
                }

                // Transaction scoring: rank among all transaction counts
                if (token.transactions > 0 && allValues.transactions.length > 0) {
                    const txnRank = allValues.transactions.filter(t => t > token.transactions).length;
                    transactionScore = ((allValues.transactions.length - txnRank) / allValues.transactions.length) * 100;
                }

                // Volume scoring: rank among all volumes
                if (token.volume24h > 0 && allValues.volumes.length > 0) {
                    const volumeRank = allValues.volumes.filter(v => v > token.volume24h).length;
                    volumeScore = ((allValues.volumes.length - volumeRank) / allValues.volumes.length) * 100;
                }

                // Market cap scoring: rank among all market caps
                if (token.marketCap > 0 && allValues.marketCaps.length > 0) {
                    const mcRank = allValues.marketCaps.filter(m => m > token.marketCap).length;
                    marketCapScore = ((allValues.marketCaps.length - mcRank) / allValues.marketCaps.length) * 100;
                }

                // Weighted average: 10% age, 30% transactions, 30% volume, 30% market cap
                const trendingScore = (
                    ageScore * 0.10 +
                    transactionScore * 0.30 +
                    volumeScore * 0.30 +
                    marketCapScore * 0.30
                );

                return parseFloat(trendingScore.toFixed(1));
            }

            truncateDescription(description, maxLength) {
                if (!description) return '';
                if (description.length <= maxLength) return description;
                return description.substring(0, maxLength) + '...';
            }

            // Remove the old calculateTrendingScore function since we're replacing it

            applyFiltersAndRender() {
                // Apply search and data filters
                this.filteredTokens = this.tokens.filter(token => {
                    // Search filter
                    if (this.searchQuery) {
                        const matchesSearch = (
                            token.name?.toLowerCase().includes(this.searchQuery) ||
                            token.symbol?.toLowerCase().includes(this.searchQuery) ||
                            token.address?.toLowerCase().includes(this.searchQuery)
                        );
                        if (!matchesSearch) return false;
                    }

                    // Exclude tokens with all zeros (insufficient data for DexScreener)
                    const isWhitelistToken = !token.isFactoryToken; // Whitelist tokens have isFactoryToken: false
                    if (!isWhitelistToken) { // Only apply to factory tokens, always show reference projects
                        // Show all tokens, even those with no trading volume, transactions, market cap, or price
                        // Only filter out blacklisted tokens (already handled in token loading)
                        return true;
                    }

                    return true;
                });

                // Apply sorting based on selected filter
                this.filteredTokens.sort((a, b) => {
                    switch (this.sortFilter) {
                        case 'marketcap-high':
                            return (b.marketCap || 0) - (a.marketCap || 0);
                        case 'marketcap-low':
                            return (a.marketCap || 0) - (b.marketCap || 0);
                        case 'volume-high':
                            return (b.volume24h || 0) - (a.volume24h || 0);
                        case 'volume-low':
                            return (a.volume24h || 0) - (b.volume24h || 0);
                        case 'transactions-high':
                            return (b.transactions || 0) - (a.transactions || 0);
                        case 'transactions-low':
                            return (a.transactions || 0) - (b.transactions || 0);
                        case 'age-new':
                            // Newer = lower age value, so sort ascending for newest first
                            const ageA = a.age || 999999;
                            const ageB = b.age || 999999;
                            return ageA - ageB;
                        case 'age-old':
                            // Older = higher age value, so sort descending for oldest first
                            const ageA2 = a.age || 0;
                            const ageB2 = b.age || 0;
                            return ageB2 - ageA2;
                        case 'trending':
                        default:
                            // Default trending logic: trading tokens first, then by trending score
                            const aHasData = a.volume24h > 0 || a.transactions > 0 || a.marketCap > 0;
                            const bHasData = b.volume24h > 0 || b.transactions > 0 || b.marketCap > 0;

                            if (aHasData && !bHasData) return -1;
                            if (!aHasData && bHasData) return 1;

                            if (aHasData && bHasData) {
                                return (b.trendingScore || 0) - (a.trendingScore || 0);
                            }

                            return (a.symbol || '').localeCompare(b.symbol || '');
                    }
                });

                // Reset pagination
                this.currentPage = 1;

                // Render
                this.renderTokens();
            }

            createPlaceholderToken(rank) {
                return {
                    name: `Token Slot ${rank}`,
                    symbol: 'SOON',
                    address: `placeholder_${rank}`,
                    price: 0,
                    priceChange24h: 0,
                    volume24h: 0,
                    marketCap: 0,
                    transactions: 0,
                    age: 0,
                    logo: null,
                    description: 'New tokens coming soon...',
                    website: null,
                    telegram: null,
                    x: null,
                    banner: null,
                    isPlaceholder: true
                };
            }

            // Helper methods for scroll indicator auto-loading
            hasMoreTokens() {
                const tokensPerPage = 12;
                const startIndex = (this.currentPage - 1) * tokensPerPage;
                const endIndex = startIndex + tokensPerPage;
                return endIndex < this.filteredTokens.length;
            }

            loadMoreTokens() {
                if (this.isLoading) return false;

                if (!this.hasMoreTokens()) {
                    console.log('📄 No more tokens available for auto-loading');
                    return false;
                }

                console.log('🔄 Auto-loading more tokens from scroll indicator...');
                this.currentPage++;
                this.renderTokens();
                return true;
            }

            renderTokens() {
                const content = document.getElementById('trending-content');
                const loadMoreBtn = document.getElementById('load-more-btn');
                const backBtn = document.getElementById('back-btn');

                // Calculate pagination
                const tokensPerPage = 12;
                const startIndex = (this.currentPage - 1) * tokensPerPage;
                const endIndex = startIndex + tokensPerPage;

                // Always show 12 cards for current page
                const tokensToShow = [];

                // Add real tokens for current page
                for (let i = startIndex; i < Math.min(endIndex, this.filteredTokens.length); i++) {
                    tokensToShow.push(this.filteredTokens[i]);
                }

                // Fill remaining slots with placeholder tokens
                for (let i = tokensToShow.length; i < 12; i++) {
                    tokensToShow.push(this.createPlaceholderToken(startIndex + i + 1));
                }

                // Create grid
                const grid = document.createElement('div');
                grid.className = 'trending-grid';

                tokensToShow.forEach((token, index) => {
                    // Use originalRank for visual badges, not display position
                    // Placeholder tokens don't get ranking badges (pass null)
                    const rankForBadge = token.isPlaceholder ? null : (token.originalRank || (startIndex + index + 1));

                    if (!token.isPlaceholder) {
                        console.log(`🏆 ${token.symbol}: Display pos ${startIndex + index + 1}, Original rank ${token.originalRank}, Badge rank ${rankForBadge}`);
                    }

                    const card = this.createTokenCard(token, rankForBadge);
                    grid.appendChild(card);
                });

                content.innerHTML = '';
                content.appendChild(grid);

                // Show/hide back button based on current page
                if (this.currentPage > 1) {
                    backBtn.style.display = 'block';
                    backBtn.textContent = `← BACK TO PREVIOUS 12`;
                } else {
                    backBtn.style.display = 'none';
                }

                // Always show load more button, but update its state
                const hasMoreTokens = endIndex < this.filteredTokens.length;
                const remainingTokens = Math.max(0, this.filteredTokens.length - endIndex);

                loadMoreBtn.style.display = 'block'; // Always visible

                if (hasMoreTokens) {
                    loadMoreBtn.textContent = `Load Next 12 (${Math.min(12, remainingTokens)} more available)`;
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.style.opacity = '1';
                    loadMoreBtn.style.cursor = 'pointer';
                } else {
                    // When no more tokens, just show "Load Next 12" - message only appears on click
                    loadMoreBtn.textContent = `Load Next 12`;
                    loadMoreBtn.disabled = false; // Keep enabled so it can be clicked
                    loadMoreBtn.style.opacity = '0.7'; // Slightly dimmed to hint it's the last page
                    loadMoreBtn.style.cursor = 'pointer';
                }

                // Notify parent window of height change after rendering
                setTimeout(() => {
                    if (window.notifyParentOfHeight) {
                        window.notifyParentOfHeight();
                    }
                }, 300);
            }

            createTokenCard(token, rank) {
                const card = document.createElement('div');
                card.className = 'token-card';

                // Check if this is a placeholder token
                if (token.isPlaceholder) {
                    card.classList.add('placeholder-card');
                    card.innerHTML = `
                        <div class="rank-badge rank-placeholder">${rank}</div>
                        <div class="token-banner placeholder-banner">Coming Soon</div>
                        <div class="token-header">
                            <div style="display: flex; align-items: center;">
                                <div class="token-logo-img placeholder-logo">
                                    <span class="placeholder-icon">?</span>
                                </div>
                                <div class="token-info">
                                    <div class="token-name">Token Slot ${rank}</div>
                                    <div class="token-symbol">$SOON</div>
                                    <div class="token-price">$0.00</div>
                                </div>
                            </div>
                        </div>
                        <div class="token-description">
                            <div class="description-text">New tokens coming soon...</div>
                        </div>
                        <div class="token-links">
                            <div class="token-links-row">
                                <span class="link-placeholder">Links coming soon</span>
                            </div>
                        </div>
                        <div class="token-stats">
                            <div class="stat">
                                <div class="stat-label">Market Cap</div>
                                <div class="stat-value">-</div>
                            </div>
                            <div class="stat">
                                <div class="stat-label">24h Volume</div>
                                <div class="stat-value">-</div>
                            </div>
                            <div class="stat">
                                <div class="stat-label">24h Trades</div>
                                <div class="stat-value">-</div>
                            </div>
                            <div class="stat">
                                <div class="stat-label">Age</div>
                                <div class="stat-value">-</div>
                            </div>
                        </div>
                    `;
                    return card;
                }

                // Check if user is the creator of this token
                const isCreator = this.isTokenCreator(token);

                console.log(`🎴 Creating card for ${token.symbol}, isCreator: ${isCreator}`);

                // Determine rank class (null rank means no badge for placeholders)
                let rankClass = 'rank-default';
                let rankBadgeHtml = '';

                if (rank !== null && rank !== undefined) {
                    if (rank === 1) rankClass = 'rank-1';
                    else if (rank === 2) rankClass = 'rank-2';
                    else if (rank === 3) rankClass = 'rank-3';
                    else if (rank <= 12) rankClass = 'rank-top12';

                    rankBadgeHtml = `<div class="rank-badge ${rankClass}">${rank}</div>`;
                }

                card.innerHTML = `
                    ${rankBadgeHtml}
                    
                    <!-- Base Network Badge for all tokens -->
                    <div class="base-network-badge">
                        <img src="https://avatars.githubusercontent.com/u/108554348" alt="Base" onerror="this.onerror=null; this.src='https://basescan.org/favicon.ico';">
                        BASE
                    </div>
                    
                    ${isCreator ? `<button class="edit-icon" onclick="openEditModal('${token.address}')" title="Update token information">Update Info</button>` : ''}
                    
                    ${token.banner ? `<div class="token-banner" style="background-image: url('${token.banner}')"></div>` : '<div class="token-banner">No Banner</div>'}
                    
                    <div class="token-header">
                     <div class="token-logo-img"
                          id="logo-${token.address}"
                          ${token.logo ? `style="background-image: url('${token.logo}')"` : ''}>
                       ${!token.logo ? (token.symbol || 'UN').substring(0, 2).toUpperCase() : ''}
                     </div>

                     <div class="token-info">
                       <div class="token-name">${token.name || 'Unknown Token'}</div>
                       <div class="token-symbol">$${token.symbol || 'UNKNOWN'}</div>
                       <div class="token-price">$${this.formatPrice(token.price || 0)}</div>
                     </div>

                     <button class="trade-btn"
                             onclick="handleTradeClick('${encodeURIComponent(token.address)}', '${encodeURIComponent(token.symbol || 'TOKEN')}')">
                       Trade
                     </button>
                   </div>


                    <div class="token-description">
                        <div class="description-text">${token.description ? this.truncateDescription(token.description, 58) : '\u00A0'}</div>
                        ${token.description && token.description.length > 58 ?
                        `<button class="description-more-btn" onclick="window.open('token-description.html?name=${encodeURIComponent(token.name || 'Token')}&address=${encodeURIComponent(token.address)}&description=${encodeURIComponent(token.description)}', '_blank')">more</button>` : ''}
                    </div>

                    <div class="token-address" onclick="copyAddress('${token.address}')" title="Click to copy address">
                        ${token.address}
                    </div>

                    <div class="token-links">
                     <!-- Top row: Website, Telegram, X -->
                     <div class="links-row top">
                       <a
                         class="token-link ${token.website ? '' : 'is-disabled'}"
                         href="${token.website || '#'}"
                         target="${token.website ? '_blank' : ''}"
                         rel="${token.website ? 'noopener noreferrer' : ''}"
                         aria-label="Website"
                         ${token.website ? '' : 'aria-disabled="true" tabindex="-1" title="Website not provided"'}
                       >
                         <img src="./images/icons/globe_icon.webp" width="20" height="20" alt="" aria-hidden="true">
                         <span class="link-text">Website</span>
                       </a>

                       <a
                         class="token-link ${token.telegram ? '' : 'is-disabled'}"
                         href="${token.telegram || '#'}"
                         target="${token.telegram ? '_blank' : ''}"
                         rel="${token.telegram ? 'noopener noreferrer' : ''}"
                         aria-label="Telegram"
                         ${token.telegram ? '' : 'aria-disabled="true" tabindex="-1" title="Telegram not provided"'}
                       >
                         <img src="./images/icons/icons8-telegram-app-240_WHITE.png" width="23" height="23" alt="" aria-hidden="true">
                         <span class="link-text">Telegram</span>
                       </a>

                       <a
                         class="token-link ${token.x ? '' : 'is-disabled'}"
                         href="${token.x || '#'}"
                         target="${token.x ? '_blank' : ''}"
                         rel="${token.x ? 'noopener noreferrer' : ''}"
                         aria-label="X (Twitter)"
                         ${token.x ? '' : 'aria-disabled="true" tabindex="-1" title="X not provided"'}
                       >
                         <img src="./images/icons/icons8-twitterx-240_WHITE.png" width="20" height="20" alt="" aria-hidden="true">

                       </a>
                     </div>

                     <!-- Bottom row: DEX Screener, BaseScan -->
                     <div class="links-row bottom">
                       <a
                         href="${token.address ? `https://dexscreener.com/base/${token.address}` : '#'}"
                         target="${token.address ? '_blank' : ''}"
                         rel="${token.address ? 'noopener noreferrer' : ''}"
                         class="token-link dexscreener-link ${this.isPremiumDexData(token) ? 'premium-dex' : ''} ${token.address ? '' : 'is-disabled'}"
                         aria-label="DEX Screener"
                         data-premium="${this.isPremiumDexData(token) ? 'true' : 'false'}"
                         ${token.address ? '' : 'aria-disabled="true" tabindex="-1" title="Address missing"'}
                       >
                         <img src="./images/icons/661375b92a7e161501f4b5e5_dexscreener.322a5a2d_WHITE.png" width="25" height="25" alt="" aria-hidden="true">
                         <span class="link-text">DEX Screener</span>
                       </a>

                       <a
                         href="${token.address ? `https://basescan.org/token/${token.address}` : '#'}"
                         target="${token.address ? '_blank' : ''}"
                         rel="${token.address ? 'noopener noreferrer' : ''}"
                         class="token-link basescan-link ${token.isVerified ? 'verified-contract' : ''} ${token.address ? '' : 'is-disabled'}"
                         aria-label="BaseScan"
                         data-premium="${token.basescanPremium ? 'true' : 'false'}"
                         
                         ${token.address ? '' : 'aria-disabled="true" tabindex="-1" title="Address missing"'}
                       >
                         <img src="./images/icons/logo-symbol-light.png" width="20" height="20" alt="" aria-hidden="true">
                         <span class="link-text">BaseScan</span>
                       </a>
                     </div>
                   </div>



                    <div class="token-stats">
                        <div class="stat">
                            <div class="stat-label">Market Cap</div>
                            <div class="stat-value">$${this.formatNumber(token.marketCap || 0)}</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">24h Volume</div>
                            <div class="stat-value">$${this.formatNumber(token.volume24h || 0)}</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">24h Trades</div>
                            <div class="stat-value">${token.transactions || 0}</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Age</div>
                            <div class="stat-value">${this.formatAge(token.age)}</div>
                        </div>
                    </div>
                `;

                // Bulletproof metadata validation and fixing for ALL stored data
                if (!token.isPlaceholder) {
                    // Validate all metadata after card is rendered
                    setTimeout(async () => {
                        try {
                            const fixes = await this.validateAndFixAllMetadata(token);

                            // Apply logo fix
                            const logoElement = document.getElementById(`logo-${token.address}`);
                            if (logoElement) {
                                if (fixes.logo !== undefined) {
                                    if (fixes.logo) {
                                        logoElement.style.backgroundImage = `url('${fixes.logo}')`;
                                        logoElement.innerHTML = '';
                                    } else {
                                        logoElement.style.backgroundImage = '';
                                        logoElement.innerHTML = (token.symbol || 'UN').substring(0, 2).toUpperCase();
                                    }
                                    console.log(`✅ ${token.symbol}: Logo fix applied`);
                                }
                            }

                            // Apply banner fix
                            const bannerElement = card.querySelector('.token-banner');
                            if (bannerElement && fixes.banner !== undefined) {
                                if (fixes.banner) {
                                    bannerElement.style.backgroundImage = `url('${fixes.banner}')`;
                                    bannerElement.textContent = '';
                                } else {
                                    bannerElement.style.backgroundImage = '';
                                    bannerElement.textContent = 'No Banner';
                                }
                                console.log(`✅ ${token.symbol}: Banner fix applied`);
                            }

                            // If any fixes were applied, potentially re-render the card
                            if (Object.keys(fixes).length > 0) {
                                console.log(`🔧 ${token.symbol}: ${Object.keys(fixes).length} metadata fixes applied`);
                            }

                        } catch (error) {
                            console.error(`Failed to validate metadata for ${token.symbol}:`, error);

                            // Try to recover from backups if validation fails
                            try {
                                const recovered = await this.recoverMetadataFromBackups(token);
                                if (recovered) {
                                    console.log(`🔄 ${token.symbol}: Metadata recovered from backup`);
                                    Object.assign(token, recovered);
                                    // Re-render card with recovered data would happen here
                                }
                            } catch (recoveryError) {
                                console.error(`Failed to recover metadata for ${token.symbol}:`, recoveryError);
                            }
                        }
                    }, 200); // Slight delay to ensure DOM is ready
                }

                return card;
            }

            formatPrice(price) {
                if (price === 0 || price === null || price === undefined || isNaN(price)) {
                    return '0.00';
                }

                if (price < 0.000001) {
                    return price.toExponential(2);
                } else if (price < 0.01) {
                    return price.toFixed(6);
                } else if (price < 1) {
                    return price.toFixed(4);
                } else if (price < 100) {
                    return price.toFixed(2);
                } else {
                    return price.toFixed(0);
                }
            }

            formatNumber(num) {
                if (num === 0 || num === null || num === undefined || isNaN(num)) {
                    return '0';
                }

                if (num >= 1e9) {
                    return (num / 1e9).toFixed(1) + 'B';
                } else if (num >= 1e6) {
                    return (num / 1e6).toFixed(1) + 'M';
                } else if (num >= 1e3) {
                    return (num / 1e3).toFixed(1) + 'K';
                } else if (num >= 1) {
                    return num.toFixed(0);
                } else {
                    return num.toFixed(2);
                }
            }

            truncateDescription(description) {
                if (!description || description.length <= 250) {
                    return description;
                }
                return description.substring(0, 250).trim() + '...';
            }

            formatAge(days) {
                if (days === null || days === undefined || isNaN(days)) {
                    return '0';
                }
                if (days === 0) {
                    return '0';
                }
                if (days < 1) {
                    return `${Math.floor(days * 24)}h`;
                } else if (days < 7) {
                    return `${Math.floor(days)}d`;
                } else if (days < 30) {
                    return `${Math.floor(days / 7)}w`;
                } else {
                    return `${Math.floor(days / 30)}mo`;
                }
            }

            updateProgress(current, total) {
                const progressFill = document.getElementById('progress-fill');
                if (progressFill) {
                    const percentage = (current / total) * 100;
                    progressFill.style.width = `${percentage}%`;
                }
            }

            showErrorState(error) {
                const content = document.getElementById('trending-content');
                content.innerHTML = `
                    <div class="error-state">
                        <h3>⚠️ Failed to Load Trending Tokens</h3>
                        <p>${error.message}</p>
                        <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Retry
                        </button>
                    </div>
                `;
            }

            // Check if the current connected wallet is the creator of a token
            isTokenCreator(token) {
                // Debug logging
                console.log('🔍 Checking token creator for:', token.symbol);
                console.log('   Token address:', token.address);
                console.log('   Token creator:', token.creator);

                // Check for wallet in current window or parent window (if in iframe)
                let walletSystem = window.wildWestWallet;
                if (!walletSystem && window.parent && window.parent !== window) {
                    walletSystem = window.parent.wildWestWallet;
                    console.log('   Checking parent window for wallet...');
                }

                console.log('   Wallet object exists:', !!walletSystem);
                console.log('   Wallet account:', walletSystem?.account);
                console.log('   Wallet connected:', walletSystem?.isConnected);

                // Check if a wallet is connected
                if (!walletSystem || !walletSystem.account || !walletSystem.isConnected) {
                    console.log('❌ No wallet connected or wallet system not available');
                    return false;
                }

                // Check if token has creator address
                if (!token.creator) {
                    console.log('❌ Token has no creator address');
                    return false;
                }

                const connectedAddress = walletSystem.account.toLowerCase();
                const tokenCreator = token.creator.toLowerCase();

                console.log('   Connected address:', connectedAddress);
                console.log('   Token creator address:', tokenCreator);
                console.log('   Match:', connectedAddress === tokenCreator);

                return connectedAddress === tokenCreator;
            }

            // Get token data by address for editing
            getTokenForEdit(address) {
                return this.allTokens.find(token => token.address.toLowerCase() === address.toLowerCase());
            }

            // Load and merge stored metadata with token data
            async loadStoredMetadata() {
                if (!window.tokenMetadataStorage) {
                    console.log('📭 No storage system available for metadata');
                    return;
                }

                try {
                    console.log('📚 Loading stored token metadata...');
                    const storedMetadata = await window.tokenMetadataStorage.loadAllTokenMetadata();

                    // Merge stored metadata with token data
                    this.allTokens.forEach(token => {
                        const stored = storedMetadata[token.address.toLowerCase()];
                        if (stored) {
                            console.log(`🔍 Full stored metadata for ${token.symbol}:`, stored);
                            // Only update fields that exist in stored metadata
                            if (stored.description) token.description = stored.description;
                            if (stored.website) token.website = stored.website;
                            if (stored.telegram) token.telegram = stored.telegram;
                            if (stored.x) token.x = stored.x;
                            if (stored.logo) {
                                token.logo = stored.logo;
                                console.log(`🖼️ Logo found: ${stored.logo}`);
                            }
                            // Note: Don't automatically set logo URL - only if it actually exists

                            if (stored.banner) {
                                token.banner = stored.banner;
                                console.log(`🎨 Banner found: ${stored.banner}`);
                            } else {
                                console.log(`❌ No banner found in metadata for ${token.symbol}`);
                            }

                            console.log(`✅ Applied metadata for ${token.symbol}:`, token.address);
                        }
                    });

                    console.log('🔄 Metadata merge complete');

                } catch (error) {
                    console.warn('⚠️ Failed to load stored metadata:', error);
                }
            }

            // Refresh token display (useful when wallet connection changes)
            refreshTokenDisplay() {
                console.log('🔄 Refreshing token display...');
                this.applyFiltersAndRender();
            }
        }

        // Global functions for edit modal
        let currentEditingToken = null;

        // IMMEDIATE SCROLL FIX - Force scroll to clicked button position
        // IFRAME WIDGET MODAL POSITIONING - Scroll parent page to show iframe
        function scrollToTopOfIframe(buttonElement) {
            console.log('� IFRAME MODAL POSITIONING - Communicating with parent window');

            if (buttonElement) {
                // Send message to parent window to scroll to the iframe
                try {
                    if (window.parent && window.parent !== window) {
                        console.log('� Sending scroll request to parent window');
                        window.parent.postMessage({
                            type: 'scrollToWidget',
                            source: 'trending-widget',
                            action: 'modal-opening'
                        }, '*');
                        console.log('✅ Scroll message sent to parent');
                    } else {
                        console.log('🏠 Running in main window - no parent scroll needed');
                    }
                } catch (error) {
                    console.log('❌ Could not communicate with parent:', error);
                }

                console.log('👀 Modal will appear in widget iframe viewport');

                return true;
            } else {
                console.log('❌ No button element provided');
                return false;
            }
        }

        // COMBINED IFRAME POSITIONING - Scroll parent to show iframe AND scroll iframe to center
        function scrollIframeToTop(buttonElement) {
            console.log('CENTER SCROLL: Combined parent and iframe scroll for perfect modal positioning');

            if (buttonElement) {
                // First: Send message to parent window to scroll to the iframe
                try {
                    if (window.parent && window.parent !== window) {
                        console.log('PARENT: Sending scroll request to parent window');
                        window.parent.postMessage({
                            type: 'scrollToWidget',
                            source: 'trending-widget',
                            action: 'modal-opening'
                        }, '*');
                        console.log('PARENT: Scroll message sent to parent');
                    }
                } catch (error) {
                    console.log('ERROR: Could not communicate with parent:', error);
                }

                // Second: Scroll the iframe content to the center for better modal visibility
                const pageHeight = document.body.scrollHeight;
                const viewportHeight = window.innerHeight;
                const centerPosition = Math.max(0, (pageHeight - viewportHeight) / 2);

                window.scrollTo({
                    top: centerPosition,
                    behavior: 'smooth'
                });

                console.log('SUCCESS: Both parent scrolled to show iframe AND iframe scrolled to center position:', centerPosition);
                return true;
            } else {
                console.log('ERROR: No button element provided');
                return false;
            }
        }

        function scrollToShowModalCacheBust(buttonElement) {
            console.log('� IMMEDIATE SCROLL FIX ACTIVATED');
            console.log('🔍 Button element received:', buttonElement);

            if (buttonElement) {
                const rect = buttonElement.getBoundingClientRect();
                const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                const viewportHeight = window.innerHeight;
                // Position modal in upper 30% of viewport for optimal visibility
                const targetY = scrollY + rect.top - (viewportHeight * 0.3);

                console.log('📍 MODAL VISIBILITY DATA:', {
                    buttonTop: rect.top,
                    currentScroll: scrollY,
                    viewportHeight: viewportHeight,
                    modalTargetPosition: viewportHeight * 0.3,
                    targetScroll: targetY,
                    scrollDistance: Math.abs(scrollY - targetY)
                });

                // Force scroll even if target is close
                const finalTarget = Math.max(0, targetY);

                window.scrollTo({
                    top: finalTarget,
                    behavior: 'smooth'
                });

                console.log('✅ IMMEDIATE SCROLL EXECUTED TO:', finalTarget);
                console.log('📏 Scroll distance:', Math.abs(scrollY - finalTarget), 'pixels');
            } else {
                console.log('❌ No button element provided for scroll');
            }
        }

        // Description modal functions
        function openDescriptionModal(tokenAddress, tokenName, clickedButton = null) {
            console.log('� NEW DESCRIPTION MODAL FUNCTION CALLED');
            console.log('🔍 Parameters:', { tokenAddress, tokenName, clickedButton });

            // Find the token to get full description
            const token = window.trendingSystem.tokens.find(t => t.address === tokenAddress);
            if (!token || !token.description) return;

            // NO SCROLLING - Just show modal without any page movement
            console.log('🎯 Opening description modal without scrolling - modal will appear in current view');

            // Update modal content
            document.getElementById('description-modal-title').textContent = `${tokenName} - Description`;
            document.getElementById('description-modal-text').textContent = token.description;

            // Show modal after scroll
            setTimeout(() => {
                console.log('📄 Showing description modal now...');
                const modal = document.getElementById('description-modal');
                modal.classList.add('show');
                document.body.style.overflow = 'hidden';
                modal.focus();
                console.log('✅ Description modal fully opened');
            }, 800); // Increased delay to see scroll animation clearly
        }

        function closeDescriptionModal() {
            const modal = document.getElementById('description-modal');
            modal.classList.remove('show');
            document.body.style.overflow = 'auto';
        }

        // Trade modal functions
        function openTradeModal(tokenAddress, tokenSymbol, clickedButton = null) {
            console.log(`🔄 Opening trade modal for ${tokenSymbol} (${tokenAddress})`);

            // Detect mobile devices (more precise detection)
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(navigator.userAgent) ||
                window.innerWidth <= 768;

            // Detect wallet browsers (be more specific to avoid false positives)
            const isInWalletBrowser = /MetaMask Mobile|Trust|Coinbase Wallet|Rainbow Wallet|ImToken|TokenPocket|1inch Wallet|Phantom/i.test(navigator.userAgent) ||
                (window.ethereum && window.ethereum.isTrust) ||
                (window.ethereum && window.ethereum.isCoinbaseWallet) ||
                (window.ethereum && window.ethereum.isMetaMask && /Mobile|Android|iPhone/i.test(navigator.userAgent));

            console.log(`Device Detection:`, {
                userAgent: navigator.userAgent,
                windowWidth: window.innerWidth,
                isMobile: isMobile,
                isInWalletBrowser: isInWalletBrowser,
                hasEthereum: !!window.ethereum
            });

            // Create Uniswap URL for Base network
            const uniswapUrl = `https://app.uniswap.org/#/swap?chain=base&inputCurrency=ETH&outputCurrency=${tokenAddress}&theme=dark`;

            // Only use mobile flow for actual mobile devices or confirmed wallet browsers
            if (isMobile || isInWalletBrowser) {
                console.log(`📱 Mobile/Wallet browser detected - redirecting directly to Uniswap`);

                // Direct redirect to Uniswap - no confirmation modal needed on mobile
                window.open(uniswapUrl, '_blank');
                return;
            }

            // Desktop: Use iframe modal with IMMEDIATE SCROLL FIX
            console.log('� NEW TRADE MODAL FUNCTION - DESKTOP MODE');

            // NO SCROLLING - Just show modal without any page movement
            console.log('🎯 Opening trade modal without scrolling - modal will appear in current view');

            // Set modal title
            document.getElementById('trade-modal-title').textContent = `Trade ${tokenSymbol}`;

            // Create iframe with Uniswap widget
            const iframe = `<iframe 
                src="${uniswapUrl}" 
                width="100%" 
                height="600" 
                style="border: none; border-radius: 12px; background: #1a1a1a;" 
                allow="clipboard-read; clipboard-write; web-share; payment" 
                loading="lazy"
                sandbox="allow-scripts allow-same-origin allow-popups allow-forms allow-popups-to-escape-sandbox"
                title="Trade ${tokenSymbol} on Uniswap">
            </iframe>`;

            document.getElementById('trade-modal-widget').innerHTML = iframe;

            // Show modal after scroll
            setTimeout(() => {
                console.log('🚀 Showing trade modal now...');
                document.getElementById('trade-modal').classList.add('show');
                document.body.style.overflow = 'hidden';
                console.log('✅ Trade modal fully opened');
            }, 800); // Increased delay to see scroll animation clearly
        }

        // Mobile-friendly confirmation before opening Uniswap
        function showMobileTradeConfirmation(tokenSymbol, uniswapUrl) {
            // Set modal title
            document.getElementById('trade-modal-title').textContent = `Trade ${tokenSymbol}`;

            // Create mobile-friendly content
            const mobileContent = `
                <div style="text-align: center; padding: 2rem 1rem;">
                    <div style="font-size: 3rem; margin-bottom: 1rem;">🚀</div>
                    <h3 style="color: #00d4ff; margin-bottom: 1rem;">Ready to Trade ${tokenSymbol}?</h3>
                    <p style="color: #ccc; margin-bottom: 2rem; line-height: 1.5;">
                        You'll be taken to Uniswap to complete your trade.<br>
                        <strong>Base ETH</strong> to <strong>${tokenSymbol}</strong>
                    </p>
                    <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                        <button onclick="window.open('${uniswapUrl}', '_blank'); closeTradeModal();" 
                                style="background: linear-gradient(135deg, #00d4ff, #0088ff); 
                                       color: white; border: none; padding: 1rem 2rem; 
                                       border-radius: 12px; font-weight: bold; cursor: pointer;
                                       font-size: 1rem; transition: all 0.3s ease;
                                       box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);"
                                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0, 212, 255, 0.4)';"
                                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0, 212, 255, 0.3)';">
                            🔄 Open Uniswap
                        </button>
                        <button onclick="closeTradeModal();" 
                                style="background: transparent; color: #999; border: 2px solid #333; 
                                       padding: 1rem 2rem; border-radius: 12px; font-weight: bold; 
                                       cursor: pointer; font-size: 1rem; transition: all 0.3s ease;"
                                onmouseover="this.style.color='white'; this.style.borderColor='#555';"
                                onmouseout="this.style.color='#999'; this.style.borderColor='#333';">
                            Cancel
                        </button>
                    </div>
                    <p style="color: #666; font-size: 0.85rem; margin-top: 1.5rem; line-height: 1.4;">
                        💡 <strong>Tip:</strong> Make sure you have Base ETH in your wallet to trade
                    </p>
                </div>
            `;

            document.getElementById('trade-modal-widget').innerHTML = mobileContent;

            // Show modal
            document.getElementById('trade-modal').classList.add('show');
            document.body.style.overflow = 'hidden';

            console.log(`✅ Mobile trade confirmation shown for ${tokenSymbol}`);
        }

        function closeTradeModal() {
            const modal = document.getElementById('trade-modal');
            modal.classList.remove('show');
            document.getElementById('trade-modal-widget').innerHTML = ''; // Clear iframe to stop any ongoing processes
            document.body.style.overflow = 'auto';
            console.log('🔄 Trade modal closed');
        }

        // Close modal when clicking outside
        window.addEventListener('click', function (event) {
            const modal = document.getElementById('description-modal');
            if (event.target === modal) {
                closeDescriptionModal();
            }

            const tradeModal = document.getElementById('trade-modal');
            if (event.target === tradeModal) {
                closeTradeModal();
            }
        });

        // Close modal with Escape key
        window.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('description-modal');
                if (modal.classList.contains('show')) {
                    closeDescriptionModal();
                }

                const tradeModal = document.getElementById('trade-modal');
                if (tradeModal.classList.contains('show')) {
                    closeTradeModal();
                }
            }
        });

        // Copy address to clipboard function
        function copyAddress(address) {
            navigator.clipboard.writeText(address).then(function () {
                // Show temporary feedback
                const event = window.event || {};
                const target = event.target || event.srcElement;
                const addressDiv = target.closest('.token-address');

                if (addressDiv) {
                    const originalBg = addressDiv.style.background;
                    const originalBorder = addressDiv.style.borderColor;
                    addressDiv.style.background = 'rgba(0, 200, 0, 0.1)';
                    addressDiv.style.borderColor = 'rgba(0, 200, 0, 0.3)';

                    setTimeout(() => {
                        addressDiv.style.background = originalBg;
                        addressDiv.style.borderColor = originalBorder;
                    }, 1000);
                }

                console.log('Address copied to clipboard:', address);
            }).catch(function (err) {
                console.error('Failed to copy address:', err);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = address;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Address copied to clipboard!');
            });
        }

        function openEditModal(tokenAddress) {
            const token = window.trendingSystem.getTokenForEdit(tokenAddress);
            if (!token) {
                console.error('Token not found for editing:', tokenAddress);
                return;
            }

            currentEditingToken = token;

            // Populate form with current token data
            document.getElementById('edit-description').value = token.description || '';
            document.getElementById('edit-website').value = token.website || '';
            document.getElementById('edit-telegram').value = token.telegram || '';
            document.getElementById('edit-x').value = token.x || '';

            // Update character counter
            updateCharCounter();

            // Show previews if images exist
            if (token.logo) {
                const logoPreview = document.getElementById('logo-preview');
                console.log('🖼️ Loading existing logo:', token.logo);
                logoPreview.src = token.logo;
                logoPreview.style.display = 'block';

                // Add error handler for broken images
                logoPreview.onerror = function () {
                    console.error('❌ Failed to load existing logo:', token.logo);
                    this.style.display = 'none';
                    alert('Current logo could not be loaded. You may need to upload a new one.');
                };

                logoPreview.onload = function () {
                    console.log('✅ Successfully loaded existing logo');
                };
            } else {
                document.getElementById('logo-preview').style.display = 'none';
            }

            if (token.banner) {
                const bannerPreview = document.getElementById('banner-preview');
                console.log('🖼️ Loading existing banner:', token.banner);
                bannerPreview.src = token.banner;
                bannerPreview.style.display = 'block';

                // Add error handler for broken images
                bannerPreview.onerror = function () {
                    console.error('❌ Failed to load existing banner:', token.banner);
                    this.style.display = 'none';
                    alert('Current banner could not be loaded. You may need to upload a new one.');
                };

                bannerPreview.onload = function () {
                    console.log('✅ Successfully loaded existing banner');
                };
            } else {
                document.getElementById('banner-preview').style.display = 'none';
            }

            // Show modal
            document.getElementById('edit-modal').style.display = 'block';
        }

        function closeEditModal() {
            document.getElementById('edit-modal').style.display = 'none';
            currentEditingToken = null;

            // Reset form
            document.getElementById('edit-token-form').reset();
            document.getElementById('logo-preview').style.display = 'none';
            document.getElementById('banner-preview').style.display = 'none';
            updateCharCounter();
        }

        function updateCharCounter() {
            const description = document.getElementById('edit-description');
            const counter = document.getElementById('char-count');
            const remaining = 250 - description.value.length;
            counter.textContent = remaining;
            counter.style.color = remaining < 20 ? '#ff4444' : '#999';
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.trendingSystem = new WildWestTrendingSystem();

            // Setup edit modal functionality
            setupEditModal();

            // Listen for wallet connection changes
            // Check periodically for wallet connection changes
            setInterval(() => {
                // Check for wallet in current or parent window
                let walletSystem = window.wildWestWallet;
                if (!walletSystem && window.parent && window.parent !== window) {
                    walletSystem = window.parent.wildWestWallet;
                }

                if (walletSystem && window.trendingSystem) {
                    // Simple check - could be enhanced with proper event listeners
                    const currentAccount = walletSystem.account;
                    const currentConnection = walletSystem.isConnected;

                    // Store last known state for comparison
                    if (!window.lastWalletState) {
                        window.lastWalletState = { account: null, connected: false };
                    }

                    // Check if state changed
                    if (window.lastWalletState.account !== currentAccount ||
                        window.lastWalletState.connected !== currentConnection) {

                        console.log('👛 Wallet state changed, refreshing token display...');
                        console.log('   Previous:', window.lastWalletState);
                        console.log('   Current:', { account: currentAccount, connected: currentConnection });
                        window.trendingSystem.refreshTokenDisplay();

                        // Update stored state
                        window.lastWalletState = {
                            account: currentAccount,
                            connected: currentConnection
                        };
                    }
                }
            }, 2000); // Check every 2 seconds

            // Periodic metadata validation system - runs every 5 minutes
            let lastValidationTime = 0;
            setInterval(async () => {
                if (!window.trendingSystem || !window.trendingSystem.tokens) return;

                const now = Date.now();
                // Only run every 5 minutes and not during active loading
                if (now - lastValidationTime < 5 * 60 * 1000 || window.trendingSystem.isLoading) return;

                lastValidationTime = now;
                console.log('🔍 Starting periodic metadata validation...');

                // Validate a few tokens each cycle (to avoid performance impact)
                const tokensToValidate = window.trendingSystem.tokens.slice(0, 3);

                for (const token of tokensToValidate) {
                    if (token.isPlaceholder) continue;

                    try {
                        const fixes = await window.trendingSystem.validateAndFixAllMetadata(token);
                        if (Object.keys(fixes).length > 0) {
                            console.log(`🔧 Periodic validation fixed ${Object.keys(fixes).length} issues for ${token.symbol}`);
                        }
                    } catch (error) {
                        console.warn(`Periodic validation failed for ${token.symbol}:`, error.message);
                    }
                }

                console.log('✅ Periodic metadata validation complete');
            }, 30000); // Check every 30 seconds, but only validate every 5 minutes
        });

        function setupEditModal() {
            // Character counter for description
            document.getElementById('edit-description').addEventListener('input', updateCharCounter);

            // File upload handlers
            const logoUploadArea = document.getElementById('logo-upload-area');
            const logoInput = document.getElementById('edit-logo');
            const logoPreview = document.getElementById('logo-preview');

            const bannerUploadArea = document.getElementById('banner-upload-area');
            const bannerInput = document.getElementById('edit-banner');
            const bannerPreview = document.getElementById('banner-preview');

            // Logo upload
            logoUploadArea.addEventListener('click', () => logoInput.click());
            logoInput.addEventListener('change', (e) => handleFileUpload(e, logoPreview, 500, 500));

            // Banner upload  
            bannerUploadArea.addEventListener('click', () => bannerInput.click());
            bannerInput.addEventListener('change', (e) => handleFileUpload(e, bannerPreview, 1500, 500));

            // Drag and drop
            [logoUploadArea, bannerUploadArea].forEach(area => {
                area.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    area.classList.add('dragover');
                });

                area.addEventListener('dragleave', () => {
                    area.classList.remove('dragover');
                });

                area.addEventListener('drop', (e) => {
                    e.preventDefault();
                    area.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const input = area === logoUploadArea ? logoInput : bannerInput;
                        const preview = area === logoUploadArea ? logoPreview : bannerPreview;
                        const maxWidth = area === logoUploadArea ? 500 : 1500;
                        const maxHeight = 500;

                        input.files = files;
                        handleFileUpload({ target: { files } }, preview, maxWidth, maxHeight);
                    }
                });
            });

            // Form submission
            document.getElementById('edit-token-form').addEventListener('submit', handleFormSubmit);

            // Close modal when clicking outside
            document.getElementById('edit-modal').addEventListener('click', (e) => {
                if (e.target.id === 'edit-modal') {
                    closeEditModal();
                }
            });
        }

        function handleFileUpload(event, preview, maxWidth, maxHeight) {
            const file = event.target.files[0];
            if (!file) {
                console.log('📁 No file selected');
                return;
            }

            console.log('📁 File selected:', file.name, 'Size:', file.size, 'Type:', file.type);

            // Validate file type
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file.');
                console.error('❌ Invalid file type:', file.type);
                return;
            }

            // Validate file size (5MB max)
            if (file.size > 5 * 1024 * 1024) {
                alert('File size must be less than 5MB.');
                console.error('❌ File too large:', file.size, 'bytes');
                return;
            }

            console.log('✅ File validation passed, creating preview...');

            // Validate preview element exists
            if (!preview) {
                console.error('❌ Preview element not found');
                alert('Preview element not found. Please refresh the page.');
                return;
            }

            // Create preview
            const reader = new FileReader();
            reader.onload = (e) => {
                console.log('📤 FileReader loaded, setting preview...');
                preview.src = e.target.result;
                preview.style.display = 'block';
                console.log('✅ Preview set successfully');
            };

            reader.onerror = (e) => {
                console.error('❌ FileReader error:', e);
                alert('Error reading file. Please try again.');
            };

            reader.readAsDataURL(file);
        }

        async function handleFormSubmit(event) {
            event.preventDefault();

            if (!currentEditingToken) {
                alert('No token selected for editing');
                return;
            }

            console.log('🚀 Starting form submission for token:', currentEditingToken.symbol, currentEditingToken.address);

            // Get form data
            const description = document.getElementById('edit-description').value.trim();
            const website = document.getElementById('edit-website').value.trim();
            const telegram = document.getElementById('edit-telegram').value.trim();
            const x = document.getElementById('edit-x').value.trim();
            const logoFile = document.getElementById('edit-logo').files[0];
            const bannerFile = document.getElementById('edit-banner').files[0];

            // Log collected form data
            console.log('📝 Form data collected:');
            console.log('  Description:', description ? `"${description.substring(0, 50)}..."` : 'empty');
            console.log('  Website:', website || 'empty');
            console.log('  Telegram:', telegram || 'empty');
            console.log('  X (Twitter):', x || 'empty');
            console.log('  Logo file:', logoFile ? `${logoFile.name} (${logoFile.size} bytes)` : 'none');
            console.log('  Banner file:', bannerFile ? `${bannerFile.name} (${bannerFile.size} bytes)` : 'none');

            // Validate URLs
            if (website && !isValidUrl(website)) {
                alert('Please enter a valid website URL starting with https://');
                return;
            }

            if (telegram && !isValidUrl(telegram)) {
                alert('Please enter a valid Telegram URL starting with https://');
                return;
            }

            if (x && !isValidUrl(x)) {
                alert('Please enter a valid X (Twitter) URL starting with https://');
                return;
            }

            // Get submit button and store original text outside try block
            const submitBtn = event.target.querySelector('.edit-btn-save');
            const originalText = submitBtn.textContent;

            try {
                // Disable submit button
                submitBtn.disabled = true;
                submitBtn.textContent = 'Saving...';

                // Initialize storage if not available
                if (!window.tokenMetadataStorage) {
                    console.log('🔧 Initializing token metadata storage...');
                    window.tokenMetadataStorage = new TokenMetadataStorage();
                }

                // Verify storage is working
                if (!window.tokenMetadataStorage || typeof window.tokenMetadataStorage.saveTokenMetadata !== 'function') {
                    throw new Error('Storage system not properly initialized');
                }

                // Load existing metadata to get current logo/banner URLs for overwrite comparison
                let existingMetadata = {};
                try {
                    const storedMetadata = await window.tokenMetadataStorage.loadAllTokenMetadata();
                    existingMetadata = storedMetadata[currentEditingToken.address.toLowerCase()] || {};
                    console.log('📋 Loaded existing metadata for overwrite:', existingMetadata);
                } catch (error) {
                    console.warn('⚠️ Could not load existing metadata:', error);
                }

                // Prepare metadata object - SMART OVERWRITE: only overwrite fields with new data
                const metadata = {
                    name: currentEditingToken.name,
                    symbol: currentEditingToken.symbol,
                    creator: currentEditingToken.creator,
                    // Start with existing data
                    description: existingMetadata.description || '',
                    website: existingMetadata.website || '',
                    telegram: existingMetadata.telegram || '',
                    x: existingMetadata.x || '',
                    logo: existingMetadata.logo || null,
                    banner: existingMetadata.banner || null,
                    // Preserve technical fields
                    logoBackup: existingMetadata.logoBackup,
                    logoUploadedAt: existingMetadata.logoUploadedAt,
                    bannerUploadedAt: existingMetadata.bannerUploadedAt
                };

                // SMART OVERWRITE: Only update fields that have new data
                if (description.trim()) {
                    console.log('📝 Overwriting description with new content');
                    metadata.description = description;
                } else if (description === '' && existingMetadata.description) {
                    console.log('📝 Keeping existing description (form field left empty)');
                    // Keep existing description
                }

                if (website.trim()) {
                    console.log('🌐 Overwriting website with new URL');
                    metadata.website = website;
                } else if (website === '' && existingMetadata.website) {
                    console.log('🌐 Keeping existing website (form field left empty)');
                    // Keep existing website
                }

                if (telegram.trim()) {
                    console.log('💬 Overwriting telegram with new URL');
                    metadata.telegram = telegram;
                } else if (telegram === '' && existingMetadata.telegram) {
                    console.log('💬 Keeping existing telegram (form field left empty)');
                    // Keep existing telegram
                }

                if (x.trim()) {
                    console.log('🐦 Overwriting X (Twitter) with new URL');
                    metadata.x = x;
                } else if (x === '' && existingMetadata.x) {
                    console.log('🐦 Keeping existing X (Twitter) (form field left empty)');
                    // Keep existing X link
                }

                // Upload logo image if provided - OVERWRITE existing logo
                if (logoFile) {
                    submitBtn.textContent = 'Uploading new logo...';
                    try {
                        console.log('🚀 Overwriting logo for:', currentEditingToken.symbol);
                        const logoUrl = await window.tokenMetadataStorage.uploadTokenLogo(
                            logoFile,
                            currentEditingToken.address,
                            currentEditingToken.symbol
                        );
                        console.log('📤 New logo upload returned URL:', logoUrl);
                        metadata.logo = logoUrl; // OVERWRITE existing logo
                        // Create backup of logo URL for bulletproof system
                        metadata.logoBackup = logoUrl;
                        metadata.logoUploadedAt = Date.now();
                        console.log('✅ Logo OVERWRITTEN with new upload:', logoUrl);
                    } catch (error) {
                        console.error('❌ Logo upload failed:', error);
                        alert('Logo upload failed. Keeping existing logo...');
                    }
                }

                // Upload banner image if provided - OVERWRITE existing banner
                if (bannerFile) {
                    submitBtn.textContent = 'Uploading new banner...';
                    try {
                        console.log('🚀 Overwriting banner for:', currentEditingToken.symbol);
                        const bannerUrl = await window.tokenMetadataStorage.uploadTokenBanner(
                            bannerFile,
                            currentEditingToken.address,
                            currentEditingToken.symbol
                        );
                        metadata.banner = bannerUrl; // OVERWRITE existing banner
                        metadata.bannerUploadedAt = Date.now();
                        console.log('✅ Banner OVERWRITTEN with new upload:', bannerUrl);
                    } catch (error) {
                        console.error('❌ Banner upload failed:', error);
                        alert('Banner upload failed. Keeping existing banner...');
                    }
                }

                // Save metadata to storage with bulletproof backup system - COMPLETE OVERWRITE
                submitBtn.textContent = 'Saving updated metadata...';
                console.log('💾 About to OVERWRITE metadata:', metadata);
                console.log('🔍 New description:', metadata.description ? `"${metadata.description.substring(0, 50)}..."` : '(cleared)');
                console.log('🔍 New website:', metadata.website || '(cleared)');
                console.log('🔍 New telegram:', metadata.telegram || '(cleared)');
                console.log('🔍 New X field:', metadata.x || '(cleared)');
                console.log('🔍 New logo:', metadata.logo ? 'Updated' : 'No change');
                console.log('🔍 New banner:', metadata.banner ? 'Updated' : 'No change');
                console.log('🔍 Token address:', currentEditingToken.address);
                console.log('🔍 Storage system available:', !!window.tokenMetadataStorage);
                if (metadata.logo) console.log('🖼️ Logo URL being saved:', metadata.logo);
                if (metadata.banner) console.log('🖼️ Banner URL being saved:', metadata.banner);

                // Validate metadata before saving
                if (!currentEditingToken.address || currentEditingToken.address.length < 20) {
                    throw new Error('Invalid token address for saving');
                }

                // Always save - even if clearing fields (empty strings are valid updates)
                console.log('💾 Proceeding with metadata overwrite/update');

                // Create bulletproof metadata with multiple backup layers
                const bulletproofMetadata = {
                    ...metadata,
                    // Add bulletproof backup system
                    backups: {
                        ...(existingMetadata.backups || {}),
                        [Date.now()]: {
                            description: metadata.description,
                            website: metadata.website,
                            telegram: metadata.telegram,
                            x: metadata.x,
                            logo: metadata.logo,
                            banner: metadata.banner,
                            uploadedAt: new Date().toISOString(),
                            userAgent: navigator.userAgent.substring(0, 100), // Track device for debugging
                            origin: window.location.href
                        }
                    },
                    // Validation and integrity data
                    lastUpdated: Date.now(),
                    updateCount: (existingMetadata.updateCount || 0) + 1,
                    validated: false, // Will be validated after save
                    integrityHash: window.trendingSystem.createMetadataHash(metadata)
                };

                // Keep only last 10 backups to prevent storage bloat
                const backupKeys = Object.keys(bulletproofMetadata.backups || {}).sort();
                if (backupKeys.length > 10) {
                    const toKeep = backupKeys.slice(-10);
                    const filteredBackups = {};
                    toKeep.forEach(key => {
                        filteredBackups[key] = bulletproofMetadata.backups[key];
                    });
                    bulletproofMetadata.backups = filteredBackups;
                }

                const result = await window.tokenMetadataStorage.saveTokenMetadata(
                    currentEditingToken.address,
                    bulletproofMetadata
                );

                console.log('✅ Bulletproof metadata saved successfully:', result);

                // Immediately validate the saved data
                submitBtn.textContent = 'Validating saved data...';
                const validationFixes = await window.trendingSystem.validateAndFixAllMetadata({
                    address: currentEditingToken.address,
                    symbol: currentEditingToken.symbol,
                    ...metadata
                });

                if (Object.keys(validationFixes).length > 0) {
                    console.log('🔧 Applied validation fixes after save:', validationFixes);
                    // Save the validated version
                    await window.tokenMetadataStorage.saveTokenMetadata(
                        currentEditingToken.address,
                        { ...bulletproofMetadata, ...validationFixes, validated: true }
                    );
                }

                // Update token data locally in the main tokens array - SMART OVERWRITE
                const tokenIndex = window.trendingSystem.tokens.findIndex(t => t.address === currentEditingToken.address);
                if (tokenIndex !== -1) {
                    const token = window.trendingSystem.tokens[tokenIndex];

                    // SMART OVERWRITE: Only update fields that have new data
                    if (description.trim()) {
                        token.description = description;
                        currentEditingToken.description = description;
                        console.log('🔄 Description updated:', description.substring(0, 30) + '...');
                    } else {
                        console.log('📝 Description unchanged (keeping existing)');
                    }

                    if (website.trim()) {
                        token.website = website;
                        currentEditingToken.website = website;
                        console.log('🔄 Website updated:', website);
                    } else {
                        console.log('🌐 Website unchanged (keeping existing)');
                    }

                    if (telegram.trim()) {
                        token.telegram = telegram;
                        currentEditingToken.telegram = telegram;
                        console.log('🔄 Telegram updated:', telegram);
                    } else {
                        console.log('💬 Telegram unchanged (keeping existing)');
                    }

                    if (x.trim()) {
                        token.x = x;
                        currentEditingToken.x = x;
                        console.log('🔄 X (Twitter) updated:', x);
                    } else {
                        console.log('🐦 X (Twitter) unchanged (keeping existing)');
                    }

                    if (metadata.logo && logoFile) {
                        // Add cache-busting timestamp to force image reload
                        const cacheBuster = `?v=${Date.now()}`;
                        token.logo = metadata.logo + cacheBuster;
                        currentEditingToken.logo = token.logo;
                        console.log('🔄 Logo updated with new image');
                    }

                    if (metadata.banner && bannerFile) {
                        // Add cache-busting timestamp to force image reload
                        const cacheBuster = `?v=${Date.now()}`;
                        token.banner = metadata.banner + cacheBuster;
                        currentEditingToken.banner = token.banner;
                        console.log('🔄 Banner updated with new image');
                    }

                    console.log('✅ Token selectively updated in main array:', token.symbol);
                } else {
                    console.error('❌ Token not found in main array for update');
                }

                // Refresh the display
                console.log('🎨 Force re-rendering tokens with updated data...');
                window.trendingSystem.renderTokens();
                console.log('✨ Display refresh complete - updated information should be visible immediately');

                alert('✅ Token information updated successfully! Only the fields you provided have been updated - existing information in other fields has been preserved.');
                closeEditModal();

            } catch (error) {
                console.error('Error saving token data:', error);

                // Provide more specific error messages
                let errorMessage = 'Failed to save changes. ';
                if (error.message.includes('GitHub token')) {
                    errorMessage += 'Configuration not available. Please check your setup.';
                } else if (error.message.includes('GitHub API')) {
                    errorMessage += 'Server error. Please try again later.';
                } else {
                    errorMessage += error.message;
                }

                alert(errorMessage);
            } finally {
                // Re-enable submit button
                const submitBtn = event.target.querySelector('.edit-btn-save');
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        }

        function isValidUrl(string) {
            try {
                const url = new URL(string);
                return url.protocol === 'https:';
            } catch (_) {
                return false;
            }
        }

        // SIMPLE WALLET BROWSER DETECTION - based on working examples from session
        function isWalletBrowser() {
            const userAgent = navigator.userAgent;
            console.log('🔍 Simple wallet detection - User Agent:', userAgent);
            console.log('🔍 Window ethereum available:', !!window.ethereum);

            // FIRST: Check if it's desktop - desktop browsers are NEVER wallet browsers
            const isDesktop = /Windows|Mac|Linux|X11/i.test(userAgent) &&
                window.screen.width >= 1024 &&
                window.screen.height >= 768;

            if (isDesktop) {
                console.log('🖥️ Desktop detected - NOT a wallet browser');
                return false;
            }

            // Check for wallet-specific user agent patterns (case insensitive)
            const walletPatterns = /MetaMask|Trust|Coinbase|Rainbow|ImToken|TokenPocket|1inch|Phantom|Zerion|Argent|Exodus|Atomic/i;
            const hasWalletPattern = walletPatterns.test(userAgent);

            // Check for wallet provider properties
            const hasWalletProvider = window.ethereum && (
                window.ethereum.isMetaMask ||
                window.ethereum.isCoinbaseWallet ||
                window.ethereum.isTrust ||
                window.ethereum.isRainbow
            );

            // Check if mobile device
            const isMobile = /Mobile|Android|iPhone|iPad/i.test(userAgent);

            // Simple logic: wallet pattern OR (mobile + ethereum provider)
            const isWallet = hasWalletPattern || hasWalletProvider || (isMobile && window.ethereum);

            console.log('🔍 Wallet detection results:', {
                isDesktop,
                hasWalletPattern,
                hasWalletProvider,
                isMobile,
                windowEthereum: !!window.ethereum,
                finalResult: isWallet
            });

            return isWallet;
        }

        // Handle trade button clicks - ALWAYS go directly to Uniswap with ETH -> Token swap
        function handleTradeClick(tokenAddress, tokenSymbol) {
            console.log('🎯 Trade button clicked - going directly to Uniswap:', { tokenAddress, tokenSymbol });
            const uniswapUrl = `https://app.uniswap.org/#/swap?inputCurrency=ETH&outputCurrency=${tokenAddress}&chain=base`;
            window.open(uniswapUrl, '_blank');
        }

        // PARENT COMMUNICATION: Listen for scroll messages from parent window
        window.addEventListener('message', function (event) {
            if (event.data && event.data.type === 'scrollIframeToCenter' && event.data.source === 'parent-window') {
                console.log('📥 Received scroll-to-center message from parent');
                const pageHeight = document.body.scrollHeight;
                const viewportHeight = window.innerHeight;
                const centerPosition = Math.max(0, (pageHeight - viewportHeight) / 2);

                window.scrollTo({
                    top: centerPosition,
                    behavior: 'smooth'
                });
                console.log('✅ Iframe scrolled to center via parent message:', centerPosition);
            }
        });

        // HEIGHT NOTIFICATION: Single throttled system to notify parent window
        let lastHeight = 0;
        let heightNotificationTimeout = null;

        function notifyParentOfHeight() {
            try {
                const marker = document.getElementById('iframe-height-marker');
                if (marker) {
                    const markerPosition = marker.offsetTop + marker.offsetHeight;
                    const totalHeight = Math.max(markerPosition, document.documentElement.scrollHeight, document.body.scrollHeight) + 20;

                    // Only send if height actually changed significantly
                    if (Math.abs(totalHeight - lastHeight) > 10) {
                        lastHeight = totalHeight;
                        console.log('📏 Sending height to parent:', totalHeight, 'px');

                        if (window.parent && window.parent !== window) {
                            window.parent.postMessage({
                                type: 'resize',
                                height: totalHeight,
                                source: 'trending-widget'
                            }, '*');
                        }
                    }
                }
            } catch (error) {
                console.log('Height notification error:', error);
            }
        }

        // Throttled height notification to prevent loops
        function throttledHeightNotification() {
            if (heightNotificationTimeout) {
                clearTimeout(heightNotificationTimeout);
            }
            heightNotificationTimeout = setTimeout(notifyParentOfHeight, 300);
        }

        // Make function available globally
        window.notifyParentOfHeight = throttledHeightNotification;

        // Debounce function to prevent excessive calls
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Initial height notification when page loads
        window.addEventListener('load', () => {
            setTimeout(window.notifyParentOfHeightChange, 500);
        });
    </script>

    <script>
        // Trigger initial height notification on page load
        window.addEventListener('load', () => {
            setTimeout(() => window.notifyParentOfHeight(), 500);
        });

        // Minimal content change detection - only for major changes
        const observer = new MutationObserver((mutations) => {
            // Only notify if significant content was added/removed
            let significantChange = false;
            mutations.forEach(mutation => {
                if (mutation.type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
                    for (let node of mutation.addedNodes) {
                        if (node.nodeType === 1 && (node.classList.contains('token-card') || node.tagName === 'DIV')) {
                            significantChange = true;
                            break;
                        }
                    }
                }
            });

            if (significantChange) {
                window.notifyParentOfHeight();
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: false // Only watch direct children to reduce noise
        });
    </script>
</body>

</html>